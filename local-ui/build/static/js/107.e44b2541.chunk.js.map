{"version":3,"file":"static/js/107.e44b2541.chunk.js","mappings":"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","sources":["services/PlaybackCoreMSE.js","services/PlaybackCoreV2.js","pages/Playback.js","utils/time.js","api.js"],"sourcesContent":["/**\r\n * PlaybackCoreMSE - ENTERPRISE MSE PLAYER (Trassir Style)\r\n * \r\n * Profile Enforcement:\r\n * --playback-engine mse-direct\r\n * --playback-reset-on-seek true\r\n * --playback-abort-on-stop true\r\n */\r\nexport default class PlaybackCoreMSE {\r\n    constructor(videoElement, camId, baseUrl = '/api') {\r\n        this.video = videoElement;\r\n        this.camId = camId;\r\n        this.baseUrl = baseUrl;\r\n\r\n        this.mediaSource = null;\r\n        this.sourceBuffer = null;\r\n        this.queue = [];\r\n        this.isAppending = false;\r\n        this.isPlaying = false;\r\n\r\n        this.manifest = null;\r\n        this.currentIndex = -1;\r\n        this.currentEpochMs = 0;\r\n\r\n        this.abortController = null;\r\n    }\r\n\r\n    async play(startTime = null) {\r\n        if (this.isPlaying) return;\r\n        this.isPlaying = true;\r\n\r\n        console.log(`[MSE] Starting play for ${this.camId} at ${startTime}`);\r\n\r\n        try {\r\n            // 1. Fetch Manifest (JSON)\r\n            const start = startTime || Date.now() - 60000;\r\n            const url = `${this.baseUrl}/playback/playlist/${this.camId}?start=${start}`;\r\n\r\n            this.abortController = new AbortController();\r\n            const res = await fetch(url, { signal: this.abortController.signal });\r\n\r\n            if (!res.ok) throw new Error(`HTTP ${res.status}`);\r\n\r\n            const txt = await res.text();\r\n            // ANTIGRAVITY-3: HTML GUARD\r\n            if (txt.trim().startsWith('<')) {\r\n                console.error(\"[MSE] Received HTML instead of JSON manifest. Routing error?\");\r\n                throw new Error('API returned HTML (fallback)');\r\n            }\r\n\r\n            this.manifest = JSON.parse(txt);\r\n\r\n            if (!this.manifest.segments || !this.manifest.segments.length) {\r\n                console.warn(\"[MSE] No segments found\");\r\n                this.isPlaying = false;\r\n                return;\r\n            }\r\n\r\n            this.currentIndex = 0;\r\n            this._initMSE();\r\n        } catch (e) {\r\n            if (e.name === 'AbortError') return;\r\n            console.error(\"[MSE] Play failed:\", e);\r\n            this.isPlaying = false;\r\n        }\r\n    }\r\n\r\n    _initMSE() {\r\n        // Cleanup previous if any (though stop() should have handled it)\r\n        if (this.mediaSource) {\r\n            this.video.src = '';\r\n            this.mediaSource = null;\r\n        }\r\n\r\n        this.mediaSource = new MediaSource();\r\n        this.video.src = URL.createObjectURL(this.mediaSource);\r\n\r\n        this.mediaSource.addEventListener('sourceopen', () => {\r\n            console.log(\"[MSE] SourceOpen\");\r\n            // AVC1.42E01E = H.264 Baseline L3.0\r\n            this.sourceBuffer = this.mediaSource.addSourceBuffer('video/mp4; codecs=\"avc1.42E01E\"');\r\n            this.sourceBuffer.mode = 'sequence';\r\n\r\n            this.sourceBuffer.addEventListener('updateend', () => {\r\n                this.isAppending = false;\r\n                this._processQueue();\r\n            });\r\n\r\n            this.sourceBuffer.addEventListener('error', (e) => {\r\n                console.error(\"[MSE] SourceBuffer Error\", e);\r\n            });\r\n\r\n            this._loadNext();\r\n        });\r\n    }\r\n\r\n    async _loadNext() {\r\n        if (!this.isPlaying || !this.manifest || this.currentIndex >= this.manifest.segments.length) {\r\n            if (this.currentIndex >= this.manifest.segments.length && this.mediaSource?.readyState === 'open') {\r\n                console.log(\"[MSE] No more segments, closing stream\");\r\n                // Don't call endOfStream immediately, wait for buffer to drain if needed\r\n            }\r\n            return;\r\n        }\r\n\r\n        const segment = this.manifest.segments[this.currentIndex];\r\n        this.currentIndex++;\r\n\r\n        try {\r\n            const response = await fetch(segment.url, { signal: this.abortController?.signal });\r\n            if (!response.ok) throw new Error(`Segment fetch failed: ${response.status}`);\r\n\r\n            const data = await response.arrayBuffer();\r\n\r\n            // Validate data is not HTML\r\n            const view = new Uint8Array(data.slice(0, 10));\r\n            const firstChars = String.fromCharCode(...view);\r\n            if (firstChars.includes('<html') || firstChars.includes('<!DOC')) {\r\n                throw new Error('Segment data is HTML (routing error)');\r\n            }\r\n\r\n            this.queue.push({\r\n                data,\r\n                start_ts: segment.start_ts\r\n            });\r\n            this._processQueue();\r\n\r\n            // Buffer management: fetch ahead but don't flood\r\n            if (this.queue.length < 5) {\r\n                this._loadNext();\r\n            }\r\n        } catch (e) {\r\n            if (e.name !== 'AbortError') {\r\n                console.error(\"[MSE] Segment load error:\", e);\r\n                // Try next segment after a small delay\r\n                setTimeout(() => this._loadNext(), 1000);\r\n            }\r\n        }\r\n    }\r\n\r\n    _processQueue() {\r\n        if (this.isAppending || this.queue.length === 0 || !this.sourceBuffer || this.sourceBuffer.updating) return;\r\n\r\n        this.isAppending = true;\r\n        const item = this.queue.shift();\r\n\r\n        try {\r\n            this.sourceBuffer.appendBuffer(item.data);\r\n            this.currentEpochMs = item.start_ts;\r\n\r\n            if (this.video.paused && this.isPlaying) {\r\n                this.video.play().catch(err => {\r\n                    if (err.name !== 'NotAllowedError') console.warn(\"[MSE] Auto-play blocked\", err);\r\n                });\r\n            }\r\n        } catch (e) {\r\n            console.error(\"[MSE] AppendBuffer failed:\", e);\r\n            this.isAppending = false;\r\n            // If buffer is full, we might need to remove some old data\r\n            if (e.name === 'QuotaExceededError') {\r\n                console.warn(\"[MSE] Buffer Full, clearing...\");\r\n                const removeStart = 0;\r\n                const removeEnd = this.video.currentTime - 10;\r\n                if (removeEnd > removeStart) {\r\n                    this.sourceBuffer.remove(removeStart, removeEnd);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // ANTIGRAVITY-4: SEEK = HARD RESET\r\n    seek(epochMs) {\r\n        console.log(`[MSE] Seek to ${epochMs}`);\r\n        this.stop();\r\n        this.play(epochMs);\r\n    }\r\n\r\n    pause() {\r\n        console.log(\"[MSE] Pause\");\r\n        this.video.pause();\r\n    }\r\n\r\n    stop() {\r\n        console.log(\"[MSE] Stop/Reset\");\r\n        this.isPlaying = false;\r\n\r\n        // 1. Abort any pending fetches\r\n        if (this.abortController) {\r\n            this.abortController.abort();\r\n            this.abortController = null;\r\n        }\r\n\r\n        // 2. Clear state\r\n        this.queue = [];\r\n        this.currentIndex = -1;\r\n        this.manifest = null;\r\n        this.isAppending = false;\r\n\r\n        // 3. Reset MediaSource/SourceBuffer\r\n        if (this.sourceBuffer) {\r\n            try {\r\n                if (!this.sourceBuffer.updating) {\r\n                    this.sourceBuffer.abort();\r\n                }\r\n            } catch (e) { }\r\n            this.sourceBuffer = null;\r\n        }\r\n\r\n        if (this.mediaSource) {\r\n            try {\r\n                if (this.mediaSource.readyState === 'open') {\r\n                    this.mediaSource.endOfStream();\r\n                }\r\n            } catch (e) { }\r\n            this.mediaSource = null;\r\n        }\r\n\r\n        // 4. Reset Video Element\r\n        if (this.video) {\r\n            this.video.pause();\r\n            this.video.src = '';\r\n            this.video.load();\r\n        }\r\n    }\r\n\r\n    getCurrentEpochMs() {\r\n        if (!this.currentEpochMs) return 0;\r\n        // In sequence mode, currentTime starts from 0 for the whole sequence\r\n        return this.currentEpochMs + (this.video.currentTime * 1000);\r\n    }\r\n\r\n    destroy() {\r\n        this.stop();\r\n    }\r\n}\r\n","import PlaybackCoreMSE from './PlaybackCoreMSE';\r\n\r\n/**\r\n * PlaybackCoreV2 - Wrapper for PlaybackCoreMSE (Enterprise Stable)\r\n */\r\nexport default class PlaybackCoreV2 extends PlaybackCoreMSE {\r\n    // Inherits everything from MSE version\r\n}\r\n","import React, { useEffect, useRef, useState, useCallback } from 'react';\r\nimport API from '../api';\r\nimport PlaybackCoreV2 from '../services/PlaybackCoreV2';\r\nimport { getLocalDayStart, formatLocalTime } from '../utils/time';\r\n\r\n/**\r\n * PLAYBACK PAGE - VM AUTHORITATIVE TIMELINE\r\n * \r\n * Profile: timeline-vm-authoritative-final\r\n *   --timeline-time-model absolute\r\n *   --timeline-time-source vm\r\n *   --timeline-vm-time-authoritative true\r\n *   --timeline-disable-browser-time true\r\n *   --timeline-now-marker enable\r\n *   --timeline-zoom-anchor mouse\r\n *   --timeline-zoom-math anchored\r\n *   --timeline-preserve-anchor-on-zoom true\r\n */\r\n\r\nconst DAY_MS = 86400000;\r\nconst HOUR_MS = 3600000;\r\nconst MIN_MS = 60000;\r\n\r\nconst Playback = () => {\r\n    const urlParams = new URLSearchParams(window.location.hash.split('?')[1]);\r\n    const initCam = urlParams.get('camId');\r\n\r\n    const [cameras, setCameras] = useState([]);\r\n    const [selectedCams, setSelectedCams] = useState(initCam ? [initCam] : []);\r\n    const [timelineSegments, setTimelineSegments] = useState([]);\r\n    const [selectedDate, setSelectedDate] = useState(new Date().toISOString().split('T')[0]);\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n\r\n    // VM TIME AUTHORITY - all time comes from VM, not browser\r\n    const [vmTimezone, setVmTimezone] = useState(null);\r\n    const [vmNowMs, setVmNowMs] = useState(0);  // Current VM time (epoch ms)\r\n    const [vmDayStartMs, setVmDayStartMs] = useState(0);  // VM day anchor\r\n\r\n    // TIMELINE STATE\r\n    const [zoom, setZoom] = useState(1);  // 1 = full day, 24 = 1 hour view\r\n    const [viewStartMs, setViewStartMs] = useState(0);  // Left edge of timeline (relative to day start)\r\n    const [displayPlayheadMs, setDisplayPlayheadMs] = useState(null);\r\n\r\n    const playersRef = useRef({});\r\n    const videoRefs = useRef({});\r\n    const canvasRef = useRef(null);\r\n    const hasStartedRef = useRef(false);\r\n    const animationRef = useRef(null);\r\n    const lastRenderRef = useRef(0);\r\n\r\n    // --- VM TIME SYNC (on-load) ---\r\n    useEffect(() => {\r\n        const syncVmTime = () => {\r\n            API.get('/system/time').then(res => {\r\n                if (res.data?.raw?.['Time zone']) {\r\n                    const tz = res.data.raw['Time zone'].split(' ')[0];\r\n                    setVmTimezone(tz);\r\n                }\r\n                // Get current VM time\r\n                if (res.data?.epoch) {\r\n                    setVmNowMs(res.data.epoch);\r\n                } else if (res.data?.iso) {\r\n                    setVmNowMs(new Date(res.data.iso).getTime());\r\n                } else {\r\n                    // Fallback: estimate from server response\r\n                    setVmNowMs(Date.now());\r\n                }\r\n            }).catch(() => {\r\n                setVmNowMs(Date.now());\r\n            });\r\n        };\r\n\r\n        syncVmTime();\r\n        // Periodic sync every 60s\r\n        const interval = setInterval(syncVmTime, 60000);\r\n        return () => clearInterval(interval);\r\n    }, []);\r\n\r\n    // Runtime clock using performance.now() for smooth animations\r\n    useEffect(() => {\r\n        if (!vmNowMs) return;\r\n        const baseVmTime = vmNowMs;\r\n        const basePerf = performance.now();\r\n\r\n        const tick = () => {\r\n            const elapsed = performance.now() - basePerf;\r\n            setVmNowMs(baseVmTime + elapsed);\r\n            animationRef.current = requestAnimationFrame(tick);\r\n        };\r\n\r\n        animationRef.current = requestAnimationFrame(tick);\r\n        return () => {\r\n            if (animationRef.current) cancelAnimationFrame(animationRef.current);\r\n        };\r\n    }, []);\r\n\r\n    // --- CALCULATE VM DAY ANCHOR ---\r\n    useEffect(() => {\r\n        if (!vmTimezone) return;\r\n        const dayStart = getLocalDayStart(selectedDate, vmTimezone);\r\n        setVmDayStartMs(dayStart);\r\n        setViewStartMs(0);  // Reset view to start of day\r\n        hasStartedRef.current = false;\r\n    }, [selectedDate, vmTimezone]);\r\n\r\n    // --- HELPERS ---\r\n    const formatTimeDisplay = (ms) => formatLocalTime(ms, vmTimezone);\r\n\r\n    // Visible duration based on zoom\r\n    const getVisibleDurationMs = () => DAY_MS / zoom;\r\n\r\n    // Convert timeline position (relative ms from day start) to canvas X\r\n    const timeToX = useCallback((relativeMs, canvasWidth) => {\r\n        const visibleMs = getVisibleDurationMs();\r\n        return ((relativeMs - viewStartMs) / visibleMs) * canvasWidth;\r\n    }, [zoom, viewStartMs]);\r\n\r\n    // Convert canvas X to timeline position (relative ms from day start)\r\n    const xToTime = useCallback((x, canvasWidth) => {\r\n        const visibleMs = getVisibleDurationMs();\r\n        return viewStartMs + (x / canvasWidth) * visibleMs;\r\n    }, [zoom, viewStartMs]);\r\n\r\n    // --- LOAD CAMERAS ---\r\n    useEffect(() => {\r\n        API.get('/cameras').then(res => {\r\n            setCameras(res.data);\r\n            if (selectedCams.length === 0 && res.data.length > 0) {\r\n                setSelectedCams([res.data[0].id]);\r\n            }\r\n        }).catch(console.error);\r\n    }, []);\r\n\r\n    // --- LOAD TIMELINE SEGMENTS ---\r\n    useEffect(() => {\r\n        if (selectedCams.length === 0) return;\r\n        API.get(`/playback/timeline-day/${selectedCams[0]}/${selectedDate}?_ts=${Date.now()}`)\r\n            .then(res => {\r\n                setTimelineSegments(res.data.segments || []);\r\n            })\r\n            .catch(console.error);\r\n    }, [selectedCams, selectedDate]);\r\n\r\n    // --- CREATE/DESTROY PLAYERS ---\r\n    useEffect(() => {\r\n        selectedCams.forEach(id => {\r\n            if (!playersRef.current[id] && videoRefs.current[id]) {\r\n                const baseURL = (API.defaults.baseURL || '/api').replace(/\\/$/, '');\r\n                playersRef.current[id] = new PlaybackCoreV2(videoRefs.current[id], id, baseURL);\r\n            }\r\n        });\r\n\r\n        // Destroy players for deselected cameras\r\n        Object.keys(playersRef.current).forEach(id => {\r\n            if (!selectedCams.includes(id)) {\r\n                playersRef.current[id].destroy();\r\n                delete playersRef.current[id];\r\n            }\r\n        });\r\n    }, [selectedCams]);\r\n\r\n    // --- FULL CLEANUP ON UNMOUNT ---\r\n    useEffect(() => {\r\n        return () => {\r\n            console.log('[Playback] Unmounting, stopping all players');\r\n            Object.values(playersRef.current).forEach(player => {\r\n                if (player) {\r\n                    player.stop(); // ANTIGRAVITY-5: OBLIGATORIU\r\n                    player.destroy();\r\n                }\r\n            });\r\n            playersRef.current = {};\r\n        };\r\n    }, []);\r\n\r\n    // --- AUTO-START PLAYBACK ---\r\n    useEffect(() => {\r\n        if (hasStartedRef.current) return;\r\n        if (selectedCams.length === 0 || timelineSegments.length === 0) return;\r\n\r\n        selectedCams.forEach(id => {\r\n            if (playersRef.current[id]) {\r\n                playersRef.current[id].play();\r\n            }\r\n        });\r\n\r\n        hasStartedRef.current = true;\r\n        setIsPlaying(true);\r\n    }, [selectedCams, timelineSegments]);\r\n\r\n    // --- DISPLAY SYNC LOOP ---\r\n    useEffect(() => {\r\n        const interval = setInterval(() => {\r\n            if (selectedCams.length === 0 || !vmDayStartMs) return;\r\n            const core = playersRef.current[selectedCams[0]];\r\n            if (!core) return;\r\n            const currentEpoch = core.getCurrentEpochMs();\r\n            if (currentEpoch > 0) {\r\n                setDisplayPlayheadMs(currentEpoch - vmDayStartMs);\r\n            }\r\n        }, 500);\r\n        return () => clearInterval(interval);\r\n    }, [vmDayStartMs, selectedCams]);\r\n\r\n    // --- USER ACTIONS ---\r\n    const handlePlay = () => {\r\n        selectedCams.forEach(id => {\r\n            if (playersRef.current[id]) playersRef.current[id].play();\r\n        });\r\n        setIsPlaying(true);\r\n    };\r\n\r\n    const handlePause = () => {\r\n        selectedCams.forEach(id => {\r\n            if (playersRef.current[id]) playersRef.current[id].pause();\r\n        });\r\n        setIsPlaying(false);\r\n    };\r\n\r\n    const handleStop = () => {\r\n        selectedCams.forEach(id => {\r\n            if (playersRef.current[id]) playersRef.current[id].stop();\r\n        });\r\n        setIsPlaying(false);\r\n        hasStartedRef.current = false;\r\n    };\r\n\r\n    const handleSeek = (epochMs) => {\r\n        console.log(`[UI] User SEEK to ${new Date(epochMs).toLocaleTimeString()}`);\r\n        selectedCams.forEach(id => {\r\n            if (playersRef.current[id]) {\r\n                playersRef.current[id].seek(epochMs);\r\n            }\r\n        });\r\n        setDisplayPlayheadMs(epochMs - vmDayStartMs);\r\n        setIsPlaying(true);\r\n    };\r\n\r\n    const handleSkip = (seconds) => {\r\n        if (displayPlayheadMs === null || !vmDayStartMs) return;\r\n        const newEpoch = vmDayStartMs + displayPlayheadMs + (seconds * 1000);\r\n        handleSeek(newEpoch);\r\n    };\r\n\r\n    // --- TIMELINE CLICK ---\r\n    const handleCanvasClick = (e) => {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas || !vmDayStartMs) return;\r\n        const rect = canvas.getBoundingClientRect();\r\n        const x = (e.clientX - rect.left) * (canvas.width / rect.width);\r\n        const clickedRelativeMs = xToTime(x, canvas.width);\r\n        const clickedEpoch = vmDayStartMs + clickedRelativeMs;\r\n        handleSeek(clickedEpoch);\r\n    };\r\n\r\n    // --- TIMELINE ZOOM (mouse-anchored) ---\r\n    const handleWheel = (e) => {\r\n        e.preventDefault();\r\n        const canvas = canvasRef.current;\r\n        if (!canvas) return;\r\n\r\n        const rect = canvas.getBoundingClientRect();\r\n        const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);\r\n\r\n        // Time under mouse cursor BEFORE zoom\r\n        const timeUnderMouse = xToTime(mouseX, canvas.width);\r\n\r\n        // Calculate new zoom\r\n        const zoomFactor = e.deltaY > 0 ? 0.85 : 1.18;\r\n        const newZoom = Math.max(1, Math.min(48, zoom * zoomFactor));\r\n\r\n        // Calculate new view start to keep timeUnderMouse at same screen position\r\n        const newVisibleMs = DAY_MS / newZoom;\r\n        const mouseRatio = mouseX / canvas.width;\r\n        const newViewStart = timeUnderMouse - (mouseRatio * newVisibleMs);\r\n\r\n        // Clamp to valid range\r\n        const clampedViewStart = Math.max(0, Math.min(DAY_MS - newVisibleMs, newViewStart));\r\n\r\n        setZoom(newZoom);\r\n        setViewStartMs(clampedViewStart);\r\n    };\r\n\r\n    // Toggle camera selection\r\n    const toggleCamera = (camId) => {\r\n        if (selectedCams.includes(camId)) {\r\n            setSelectedCams(selectedCams.filter(id => id !== camId));\r\n        } else {\r\n            setSelectedCams([...selectedCams, camId]);\r\n        }\r\n        hasStartedRef.current = false;\r\n    };\r\n\r\n    // --- DRAW TIMELINE (continuous render) ---\r\n    const draw = useCallback(() => {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas || !vmDayStartMs) return;\r\n\r\n        const ctx = canvas.getContext('2d');\r\n        const width = canvas.width;\r\n        const height = canvas.height;\r\n        const visibleMs = getVisibleDurationMs();\r\n\r\n        // Background\r\n        ctx.fillStyle = '#0a0a0a';\r\n        ctx.fillRect(0, 0, width, height);\r\n\r\n        // Grid lines and time labels\r\n        const msPerPixel = visibleMs / width;\r\n        let gridInterval;\r\n        if (msPerPixel < 1000) gridInterval = MIN_MS;           // 1 min\r\n        else if (msPerPixel < 5000) gridInterval = MIN_MS * 5;  // 5 min  \r\n        else if (msPerPixel < 15000) gridInterval = MIN_MS * 15; // 15 min\r\n        else if (msPerPixel < 60000) gridInterval = HOUR_MS;    // 1 hour\r\n        else gridInterval = HOUR_MS * 2;                        // 2 hours\r\n\r\n        const startGrid = Math.floor(viewStartMs / gridInterval) * gridInterval;\r\n\r\n        ctx.font = '10px monospace';\r\n        for (let t = startGrid; t <= viewStartMs + visibleMs; t += gridInterval) {\r\n            const x = timeToX(t, width);\r\n            if (x < 0 || x > width) continue;\r\n\r\n            const isMajor = t % HOUR_MS === 0;\r\n            ctx.strokeStyle = isMajor ? '#333' : '#1a1a1a';\r\n            ctx.lineWidth = 1;\r\n            ctx.beginPath();\r\n            ctx.moveTo(x, 0);\r\n            ctx.lineTo(x, height);\r\n            ctx.stroke();\r\n\r\n            if (isMajor || gridInterval <= MIN_MS * 5) {\r\n                const hours = Math.floor(t / HOUR_MS);\r\n                const mins = Math.floor((t % HOUR_MS) / MIN_MS);\r\n                const label = `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;\r\n                ctx.fillStyle = '#666';\r\n                ctx.fillText(label, x + 2, 10);\r\n            }\r\n        }\r\n\r\n        // Segments\r\n        ctx.fillStyle = '#2ecc71';\r\n        timelineSegments.forEach(seg => {\r\n            const segStart = seg.start_ts - vmDayStartMs;\r\n            const segEnd = seg.end_ts - vmDayStartMs;\r\n            const x1 = timeToX(segStart, width);\r\n            const x2 = timeToX(segEnd, width);\r\n\r\n            if (x2 >= 0 && x1 <= width) {\r\n                const drawX1 = Math.max(0, x1);\r\n                const drawX2 = Math.min(width, x2);\r\n                ctx.fillRect(drawX1, height - 14, drawX2 - drawX1, 14);\r\n            }\r\n        });\r\n\r\n        // NOW marker (VM time)\r\n        const nowRelative = vmNowMs - vmDayStartMs;\r\n        if (nowRelative >= 0 && nowRelative <= DAY_MS) {\r\n            const nowX = timeToX(nowRelative, width);\r\n            if (nowX >= 0 && nowX <= width) {\r\n                ctx.strokeStyle = '#3498db';\r\n                ctx.lineWidth = 1;\r\n                ctx.setLineDash([3, 3]);\r\n                ctx.beginPath();\r\n                ctx.moveTo(nowX, 0);\r\n                ctx.lineTo(nowX, height);\r\n                ctx.stroke();\r\n                ctx.setLineDash([]);\r\n\r\n                // NOW label\r\n                ctx.fillStyle = '#3498db';\r\n                ctx.font = '9px sans-serif';\r\n                ctx.fillText('NOW', nowX + 2, height - 16);\r\n            }\r\n        }\r\n\r\n        // Playhead\r\n        if (displayPlayheadMs !== null) {\r\n            const px = timeToX(displayPlayheadMs, width);\r\n            if (px >= 0 && px <= width) {\r\n                ctx.strokeStyle = '#e74c3c';\r\n                ctx.lineWidth = 2;\r\n                ctx.beginPath();\r\n                ctx.moveTo(px, 0);\r\n                ctx.lineTo(px, height);\r\n                ctx.stroke();\r\n\r\n                // Playhead time label\r\n                ctx.fillStyle = '#e74c3c';\r\n                ctx.font = 'bold 10px monospace';\r\n                const timeLabel = formatTimeDisplay(vmDayStartMs + displayPlayheadMs);\r\n                ctx.fillText(timeLabel, px + 4, 22);\r\n            }\r\n        }\r\n    }, [vmDayStartMs, vmNowMs, timelineSegments, displayPlayheadMs, zoom, viewStartMs, timeToX, vmTimezone]);\r\n\r\n    // Continuous render loop\r\n    useEffect(() => {\r\n        let frameId;\r\n        const render = () => {\r\n            const now = performance.now();\r\n            if (now - lastRenderRef.current > 50) {  // ~20fps for timeline\r\n                draw();\r\n                lastRenderRef.current = now;\r\n            }\r\n            frameId = requestAnimationFrame(render);\r\n        };\r\n        frameId = requestAnimationFrame(render);\r\n        return () => cancelAnimationFrame(frameId);\r\n    }, [draw]);\r\n\r\n    // --- STYLES ---\r\n    const sidebarWidth = 260;\r\n    const btnStyle = {\r\n        padding: '6px 12px',\r\n        background: '#222',\r\n        color: '#fff',\r\n        border: '1px solid #333',\r\n        borderRadius: 4,\r\n        cursor: 'pointer',\r\n        fontSize: 12\r\n    };\r\n    const activeBtnStyle = { ...btnStyle, background: '#2ecc71', borderColor: '#27ae60' };\r\n\r\n    return (\r\n        <div style={{\r\n            height: 'calc(100vh - 64px)',\r\n            display: 'flex',\r\n            flexDirection: 'row',\r\n            background: '#0a0a0a',\r\n            color: '#eee',\r\n            overflow: 'hidden'\r\n        }}>\r\n\r\n            {/* LEFT SIDEBAR */}\r\n            <div style={{\r\n                width: sidebarWidth,\r\n                minWidth: sidebarWidth,\r\n                background: '#111',\r\n                borderRight: '1px solid #1a1a1a',\r\n                display: 'flex',\r\n                flexDirection: 'column',\r\n                overflow: 'hidden'\r\n            }}>\r\n                <div style={{ padding: '12px', borderBottom: '1px solid #1a1a1a' }}>\r\n                    <div style={{ fontSize: 10, color: '#555', textTransform: 'uppercase', letterSpacing: 1 }}>\r\n                        Cameras ({selectedCams.length})\r\n                    </div>\r\n                </div>\r\n\r\n                <div style={{ flex: 1, overflowY: 'auto', padding: '8px' }}>\r\n                    {cameras.map(cam => {\r\n                        const isSelected = selectedCams.includes(cam.id);\r\n                        return (\r\n                            <div\r\n                                key={cam.id}\r\n                                onClick={() => toggleCamera(cam.id)}\r\n                                style={{\r\n                                    padding: '10px 12px',\r\n                                    marginBottom: 4,\r\n                                    background: isSelected ? 'rgba(46, 204, 113, 0.1)' : '#151515',\r\n                                    border: `1px solid ${isSelected ? '#2ecc71' : '#1a1a1a'}`,\r\n                                    borderRadius: 6,\r\n                                    cursor: 'pointer',\r\n                                    display: 'flex',\r\n                                    alignItems: 'center',\r\n                                    gap: 10\r\n                                }}\r\n                            >\r\n                                <div style={{\r\n                                    width: 8, height: 8, borderRadius: '50%',\r\n                                    background: isSelected ? '#2ecc71' : '#333'\r\n                                }} />\r\n                                <div style={{ flex: 1, minWidth: 0 }}>\r\n                                    <div style={{\r\n                                        fontSize: 12,\r\n                                        fontWeight: isSelected ? 600 : 400,\r\n                                        color: isSelected ? '#2ecc71' : '#888',\r\n                                        overflow: 'hidden',\r\n                                        textOverflow: 'ellipsis',\r\n                                        whiteSpace: 'nowrap'\r\n                                    }}>\r\n                                        {cam.name || cam.id}\r\n                                    </div>\r\n                                </div>\r\n                            </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n\r\n                <div style={{ padding: '12px', borderTop: '1px solid #1a1a1a' }}>\r\n                    <div style={{ fontSize: 9, color: '#444', marginBottom: 6 }}>DATE</div>\r\n                    <input\r\n                        type=\"date\"\r\n                        value={selectedDate}\r\n                        onChange={e => setSelectedDate(e.target.value)}\r\n                        style={{\r\n                            width: '100%', padding: '8px',\r\n                            background: '#1a1a1a', color: '#fff',\r\n                            border: '1px solid #222', borderRadius: 4, fontSize: 12\r\n                        }}\r\n                    />\r\n                    <div style={{ fontSize: 9, color: '#444', marginTop: 8 }}>\r\n                        VM Time: {vmTimezone || 'syncing...'}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n\r\n            {/* MAIN CONTENT */}\r\n            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden', padding: 12 }}>\r\n\r\n                {/* Video Grid */}\r\n                <div style={{\r\n                    flex: 1, minHeight: 0,\r\n                    display: 'grid',\r\n                    gridTemplateColumns: selectedCams.length > 1 ? 'repeat(2, 1fr)' : '1fr',\r\n                    gridTemplateRows: selectedCams.length > 2 ? 'repeat(2, 1fr)' : '1fr',\r\n                    gap: 4, background: '#000', borderRadius: 6, padding: 4, marginBottom: 10\r\n                }}>\r\n                    {selectedCams.length === 0 ? (\r\n                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', color: '#333' }}>\r\n                            Select cameras from sidebar\r\n                        </div>\r\n                    ) : (\r\n                        selectedCams.map(id => (\r\n                            <div key={id} style={{ position: 'relative', background: '#0a0a0a', borderRadius: 4, overflow: 'hidden', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>\r\n                                <video\r\n                                    ref={el => videoRefs.current[id] = el}\r\n                                    autoPlay playsInline muted\r\n                                    style={{ width: '100%', height: '100%', objectFit: 'contain' }}\r\n                                />\r\n                                <div style={{ position: 'absolute', top: 4, left: 4, background: 'rgba(0,0,0,0.8)', padding: '2px 8px', borderRadius: 4, fontSize: 10 }}>\r\n                                    {cameras.find(c => c.id === id)?.name || id}\r\n                                </div>\r\n                            </div>\r\n                        ))\r\n                    )}\r\n                </div>\r\n\r\n                {/* Timeline */}\r\n                <div style={{\r\n                    width: '100%', height: 48,\r\n                    border: '1px solid #1a1a1a', borderRadius: 4,\r\n                    overflow: 'hidden', background: '#0a0a0a', marginBottom: 10\r\n                }}>\r\n                    <canvas\r\n                        ref={canvasRef}\r\n                        width={2000}\r\n                        height={48}\r\n                        style={{ width: '100%', height: '100%', cursor: 'crosshair' }}\r\n                        onClick={handleCanvasClick}\r\n                        onWheel={handleWheel}\r\n                    />\r\n                </div>\r\n\r\n                {/* Controls */}\r\n                <div style={{\r\n                    display: 'flex', gap: 6, alignItems: 'center',\r\n                    background: '#111', padding: '8px 12px', borderRadius: 4, border: '1px solid #1a1a1a'\r\n                }}>\r\n                    <button onClick={() => handleSkip(-30)} style={btnStyle}>-30s</button>\r\n                    <button onClick={() => handleSkip(-10)} style={btnStyle}>-10s</button>\r\n                    <button onClick={handleStop} style={btnStyle}>⏹</button>\r\n                    <button onClick={isPlaying ? handlePause : handlePlay} style={isPlaying ? activeBtnStyle : btnStyle}>\r\n                        {isPlaying ? '⏸' : '▶'}\r\n                    </button>\r\n                    <button onClick={() => handleSkip(10)} style={btnStyle}>+10s</button>\r\n                    <button onClick={() => handleSkip(30)} style={btnStyle}>+30s</button>\r\n\r\n                    <div style={{ flex: 1 }} />\r\n\r\n                    <div style={{ fontSize: 10, color: '#555', marginRight: 10 }}>\r\n                        Zoom: {zoom.toFixed(1)}x\r\n                    </div>\r\n\r\n                    <div style={{\r\n                        fontSize: 13, fontFamily: 'monospace', color: '#2ecc71',\r\n                        background: '#0a0a0a', padding: '6px 12px', borderRadius: 4, border: '1px solid #1a1a1a'\r\n                    }}>\r\n                        {displayPlayheadMs !== null ? formatTimeDisplay(vmDayStartMs + displayPlayheadMs) : '--:--:--'}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Playback;\r\n","/* Standard DSS Time Utilities using Luxon */\r\nimport { DateTime } from 'luxon';\r\n\r\n/**\r\n * Returns the UTC Timestamp (ms) for a given Date (\"YYYY-MM-DD\") and Time (\"HH:MM\")\r\n * in the NVR's Timezone.\r\n * Usage: UI Click -> Backend Request.\r\n * timeStr format: \"HH:mm\" or \"HH:mm:ss\"\r\n */\r\nexport function localToUtcTs(dateStr, timeStr, timezone) {\r\n    if (!timezone) {\r\n        // Fallback safely if TZ not loaded yet\r\n        return DateTime.fromISO(`${dateStr}T${timeStr}`).toMillis();\r\n    }\r\n    return DateTime.fromISO(`${dateStr}T${timeStr}`, { zone: timezone }).toMillis();\r\n}\r\n\r\n/**\r\n * Returns the Epoch (ms) corresponding to 00:00:00 in the Target Timezone.\r\n * Usage: Setting the Timeline anchor (x=0).\r\n */\r\nexport function getLocalDayStart(dateStr, timezone) {\r\n    if (!timezone) return DateTime.fromISO(dateStr).startOf('day').toMillis();\r\n    return DateTime.fromISO(dateStr, { zone: timezone }).startOf('day').toMillis();\r\n}\r\n\r\n/**\r\n * Formats a UTC Timestamp into \"HH:mm:ss\" in the Target Timezone.\r\n * Usage: Displaying Playhead time, Debug info.\r\n */\r\nexport function formatLocalTime(ts, timezone) {\r\n    if (!ts) return \"--:--:--\";\r\n    const opts = timezone ? { zone: timezone } : {};\r\n    return DateTime.fromMillis(ts, opts).toFormat('HH:mm:ss');\r\n}\r\n\r\n/**\r\n * Formats a UTC Timestamp into \"yyyy-MM-dd\" in the Target Timezone.\r\n */\r\nexport function formatLocalDate(ts, timezone) {\r\n    if (!ts) return \"\";\r\n    const opts = timezone ? { zone: timezone } : {};\r\n    return DateTime.fromMillis(ts, opts).toFormat('yyyy-MM-dd');\r\n}\r\n","import axios from \"axios\";\r\n\r\n// Use relative path or detect Proxy base\r\nlet baseURL = \"\";\r\nif (typeof window !== 'undefined') {\r\n    // Check for proxy in full URL (HashRouter compatibility)\r\n    const match = window.location.href.match(/(\\/api\\/proxy\\/[^\\/]+)/);\r\n    if (match) {\r\n        baseURL = match[1];\r\n    } else if (window.location.hash.includes(\"#/\")) {\r\n        // Fallback for local dev or direct access\r\n        baseURL = \"\";\r\n    }\r\n}\r\n\r\nconst API = axios.create({\r\n    baseURL: baseURL\r\n});\r\n\r\nexport { API, baseURL };\r\nexport default API;\r\n"],"names":["PlaybackCoreMSE","constructor","videoElement","camId","baseUrl","arguments","length","undefined","this","video","mediaSource","sourceBuffer","queue","isAppending","isPlaying","manifest","currentIndex","currentEpochMs","abortController","play","startTime","console","log","concat","start","Date","now","url","AbortController","res","fetch","signal","ok","Error","status","txt","text","trim","startsWith","error","JSON","parse","segments","warn","_initMSE","e","name","src","MediaSource","URL","createObjectURL","addEventListener","addSourceBuffer","mode","_processQueue","_loadNext","_this$mediaSource","readyState","segment","_this$abortController","response","data","arrayBuffer","view","Uint8Array","slice","firstChars","String","fromCharCode","includes","push","start_ts","setTimeout","updating","item","shift","appendBuffer","paused","catch","err","removeStart","removeEnd","currentTime","remove","seek","epochMs","stop","pause","abort","endOfStream","load","getCurrentEpochMs","destroy","PlaybackCoreV2","DAY_MS","HOUR_MS","MIN_MS","Playback","initCam","URLSearchParams","window","location","hash","split","get","cameras","setCameras","useState","selectedCams","setSelectedCams","timelineSegments","setTimelineSegments","selectedDate","setSelectedDate","toISOString","setIsPlaying","vmTimezone","setVmTimezone","vmNowMs","setVmNowMs","vmDayStartMs","setVmDayStartMs","zoom","setZoom","viewStartMs","setViewStartMs","displayPlayheadMs","setDisplayPlayheadMs","playersRef","useRef","videoRefs","canvasRef","hasStartedRef","animationRef","lastRenderRef","useEffect","syncVmTime","API","then","_res$data","_res$data$raw","_res$data2","_res$data3","raw","tz","epoch","iso","getTime","interval","setInterval","clearInterval","baseVmTime","basePerf","performance","tick","elapsed","current","requestAnimationFrame","cancelAnimationFrame","dayStart","dateStr","timezone","DateTime","fromISO","zone","startOf","toMillis","formatTimeDisplay","ms","ts","opts","fromMillis","toFormat","formatLocalTime","getVisibleDurationMs","timeToX","useCallback","relativeMs","canvasWidth","visibleMs","xToTime","x","id","forEach","baseURL","defaults","replace","Object","keys","values","player","core","currentEpoch","handleSeek","toLocaleTimeString","handleSkip","seconds","draw","canvas","ctx","getContext","width","height","fillStyle","fillRect","msPerPixel","gridInterval","startGrid","Math","floor","font","t","isMajor","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","hours","mins","label","toString","padStart","fillText","seg","segStart","segEnd","end_ts","x1","x2","drawX1","max","drawX2","min","nowRelative","nowX","setLineDash","px","timeLabel","frameId","render","btnStyle","padding","background","color","border","borderRadius","cursor","fontSize","activeBtnStyle","_objectSpread","borderColor","_jsxs","style","display","flexDirection","overflow","children","minWidth","borderRight","_jsx","borderBottom","textTransform","letterSpacing","flex","overflowY","map","cam","isSelected","onClick","toggleCamera","filter","marginBottom","alignItems","gap","fontWeight","textOverflow","whiteSpace","borderTop","type","value","onChange","target","marginTop","minHeight","gridTemplateColumns","gridTemplateRows","justifyContent","_cameras$find","position","ref","el","autoPlay","playsInline","muted","objectFit","top","left","find","c","rect","getBoundingClientRect","clientX","clickedRelativeMs","onWheel","preventDefault","mouseX","timeUnderMouse","zoomFactor","deltaY","newZoom","newVisibleMs","newViewStart","clampedViewStart","handleStop","handlePause","handlePlay","marginRight","toFixed","fontFamily","match","href","axios","create"],"ignoreList":[],"sourceRoot":""}