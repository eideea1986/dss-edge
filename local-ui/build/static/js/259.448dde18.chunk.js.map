{"version":3,"file":"static/js/259.448dde18.chunk.js","mappings":"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","sources":["services/PlayerStateMachine.js","services/PlaybackController.js","pages/PlaybackModern.js","api.js"],"sourcesContent":["export const PlayerStates = Object.freeze({\r\n    IDLE: \"IDLE\",\r\n    LOADING: \"LOADING\",\r\n    READY: \"READY\",\r\n    PLAYING: \"PLAYING\",\r\n    PAUSED: \"PAUSED\",\r\n    BUFFERING: \"BUFFERING\",\r\n    GAP: \"GAP\",\r\n    ERROR: \"ERROR\"\r\n});\r\n\r\nexport const PlayerEvents = Object.freeze({\r\n    LOAD_LIVE: \"LOAD_LIVE\",\r\n    LOAD_PLAYBACK: \"LOAD_PLAYBACK\",\r\n    METADATA_READY: \"METADATA_READY\",\r\n    VIDEO_TRACK_READY: \"VIDEO_TRACK_READY\",\r\n    PLAY: \"PLAY\",\r\n    PAUSE: \"PAUSE\",\r\n    SEEK: \"SEEK\",\r\n    BUFFER_EMPTY: \"BUFFER_EMPTY\",\r\n    BUFFER_FULL: \"BUFFER_FULL\",\r\n    GAP_DETECTED: \"GAP_DETECTED\",\r\n    GAP_RESOLVED: \"GAP_RESOLVED\",\r\n    END: \"END\",\r\n    ERROR: \"ERROR\",\r\n    RESET: \"RESET\"\r\n});\r\n\r\nexport class PlayerStateMachine {\r\n    constructor({ onStateChange, onAction, logger = console }) {\r\n        this.state = PlayerStates.IDLE;\r\n        this.onStateChange = onStateChange;\r\n        this.onAction = onAction;\r\n        this.log = logger;\r\n    }\r\n\r\n    transition(next, payload) {\r\n        if (this.log && this.log.debug) {\r\n            this.log.debug(`[PLAYER FSM] ${this.state} -> ${next}`, payload || \"\");\r\n        } else {\r\n            // Fallback if logger doesn't have debug\r\n            console.log(`[PLAYER FSM] ${this.state} -> ${next}`, payload || \"\");\r\n        }\r\n        this.state = next;\r\n        if (this.onStateChange) this.onStateChange(next, payload);\r\n    }\r\n\r\n    dispatch(event, payload = {}) {\r\n        if (this.log && this.log.debug) {\r\n            this.log.debug(`[PLAYER FSM EVENT] ${event}`, payload);\r\n        }\r\n\r\n        switch (this.state) {\r\n            case PlayerStates.IDLE:\r\n                if (event === PlayerEvents.LOAD_LIVE || event === PlayerEvents.LOAD_PLAYBACK) {\r\n                    this.transition(PlayerStates.LOADING, payload);\r\n                    if (this.onAction) this.onAction(\"initStream\", payload);\r\n                }\r\n                break;\r\n\r\n            case PlayerStates.LOADING:\r\n                if (event === PlayerEvents.METADATA_READY) {\r\n                    // metadata ok, but video not yet\r\n                    return;\r\n                }\r\n                if (event === PlayerEvents.VIDEO_TRACK_READY) {\r\n                    this.transition(PlayerStates.READY);\r\n                }\r\n                if (event === PlayerEvents.ERROR) {\r\n                    this.transition(PlayerStates.ERROR, payload);\r\n                }\r\n                break;\r\n\r\n            case PlayerStates.READY:\r\n                if (event === PlayerEvents.PLAY) {\r\n                    this.transition(PlayerStates.PLAYING);\r\n                    if (this.onAction) this.onAction(\"play\");\r\n                }\r\n                if (event === PlayerEvents.SEEK) {\r\n                    if (this.onAction) this.onAction(\"seek\", payload);\r\n                }\r\n                if (event === PlayerEvents.ERROR) {\r\n                    this.transition(PlayerStates.ERROR, payload);\r\n                }\r\n                break;\r\n\r\n            case PlayerStates.PLAYING:\r\n                if (event === PlayerEvents.PAUSE) {\r\n                    this.transition(PlayerStates.PAUSED);\r\n                    if (this.onAction) this.onAction(\"pause\");\r\n                }\r\n                if (event === PlayerEvents.BUFFER_EMPTY) {\r\n                    this.transition(PlayerStates.BUFFERING);\r\n                }\r\n                if (event === PlayerEvents.GAP_DETECTED) {\r\n                    this.transition(PlayerStates.GAP, payload);\r\n                    if (this.onAction) this.onAction(\"skipGap\", payload);\r\n                }\r\n                if (event === PlayerEvents.END) {\r\n                    this.transition(PlayerStates.IDLE);\r\n                }\r\n                if (event === PlayerEvents.ERROR) {\r\n                    this.transition(PlayerStates.ERROR, payload);\r\n                }\r\n                break;\r\n\r\n            case PlayerStates.BUFFERING:\r\n                if (event === PlayerEvents.BUFFER_FULL) {\r\n                    this.transition(PlayerStates.PLAYING);\r\n                }\r\n                if (event === PlayerEvents.GAP_DETECTED) {\r\n                    this.transition(PlayerStates.GAP, payload);\r\n                }\r\n                if (event === PlayerEvents.ERROR) {\r\n                    this.transition(PlayerStates.ERROR, payload);\r\n                }\r\n                break;\r\n\r\n            case PlayerStates.GAP:\r\n                if (event === PlayerEvents.GAP_RESOLVED) {\r\n                    this.transition(PlayerStates.BUFFERING);\r\n                }\r\n                if (event === PlayerEvents.END) {\r\n                    this.transition(PlayerStates.IDLE);\r\n                }\r\n                break;\r\n\r\n            case PlayerStates.PAUSED:\r\n                if (event === PlayerEvents.PLAY) {\r\n                    this.transition(PlayerStates.PLAYING);\r\n                    if (this.onAction) this.onAction(\"play\");\r\n                }\r\n                if (event === PlayerEvents.SEEK) {\r\n                    if (this.onAction) this.onAction(\"seek\", payload);\r\n                }\r\n                break;\r\n\r\n            case PlayerStates.ERROR:\r\n                if (event === PlayerEvents.RESET) {\r\n                    this.transition(PlayerStates.IDLE);\r\n                }\r\n                break;\r\n\r\n            default:\r\n                console.error(\"Unknown state\", this.state);\r\n        }\r\n    }\r\n}\r\n","import Hls from 'hls.js';\r\nimport { PlayerStateMachine, PlayerEvents, PlayerStates } from './PlayerStateMachine';\r\n\r\nexport { PlayerStates };\r\n\r\nexport default class PlaybackController {\r\n    constructor(videoElement, camId, onStateChange, baseUrl = '/api') {\r\n        this.video = videoElement;\r\n        this.camId = camId;\r\n        this.baseUrl = baseUrl;\r\n        this.segments = [];\r\n        this.hls = null;\r\n\r\n        // --- 1. Initialize FSM ---\r\n        this.fsm = new PlayerStateMachine({\r\n            onStateChange: (state, payload) => {\r\n                if (onStateChange) onStateChange(state, payload);\r\n            },\r\n            onAction: (action, payload) => this._handleAction(action, payload)\r\n        });\r\n\r\n        // --- 2. Bind Video Events ---\r\n        this._bindVideoEvents();\r\n    }\r\n\r\n    _bindVideoEvents() {\r\n        this.video.addEventListener('waiting', () => {\r\n            this.fsm.dispatch(PlayerEvents.BUFFER_EMPTY);\r\n        });\r\n        this.video.addEventListener('playing', () => {\r\n            this.fsm.dispatch(PlayerEvents.BUFFER_FULL);\r\n        });\r\n        // We handle Pause manually to avoid conflicts with Seek/Buffer logic\r\n        this.video.addEventListener('error', (e) => {\r\n            this.fsm.dispatch(PlayerEvents.ERROR, { error: e });\r\n        });\r\n\r\n        // Gap Detection Monitor\r\n        this.video.addEventListener('timeupdate', () => this._checkGap());\r\n    }\r\n\r\n    destroy() {\r\n        if (this.hls) {\r\n            this.hls.destroy();\r\n            this.hls = null;\r\n        }\r\n        // Remove listeners if needed\r\n    }\r\n\r\n    // --- EXTERNAL PUBLIC API (Called by React UI) ---\r\n\r\n    loadSegments(segments) {\r\n        // Validate & Sort\r\n        this.segments = (segments || []).map(s => ({\r\n            start: Number(s.start || s.start_ts || s.startTs),\r\n            end: Number(s.end || s.end_ts || s.endTs),\r\n            file: s.file\r\n        })).sort((a, b) => a.start - b.start);\r\n\r\n        if (this.segments.length > 0) {\r\n            // Signal FSM that metadata is ready\r\n            // We initiate \"Load Playback\"\r\n            this.fsm.dispatch(PlayerEvents.LOAD_PLAYBACK, { camId: this.camId, segments: this.segments });\r\n\r\n            // In our case, metadata is segments. Video track is ready when we select a segment.\r\n            // For now, let's say Metadata is ready.\r\n            this.fsm.dispatch(PlayerEvents.METADATA_READY);\r\n\r\n            // Auto-load first segment or wait?\r\n            // User usually clicks timeline. Let's wait for user to Seek or Play.\r\n            // But if we want to be \"READY\", we probably need a valid source.\r\n            // However, we don't know WHERE to start yet.\r\n            // Let's force READY state if we have segments, assuming user will Seek.\r\n            // To do this cleanly, we can pretend video track is ready or just wait for seek.\r\n            // Actually, we can dispatch VIDEO_TRACK_READY once the user actively seeks.\r\n            // For now, let's leave it in LOADING or transition to READY manually?\r\n            // The FSM says LOADING -> READY on VIDEO_TRACK_READY.\r\n            // Let's assume we are conceptually READY since we have the timeline.\r\n            this.fsm.dispatch(PlayerEvents.VIDEO_TRACK_READY);\r\n        }\r\n    }\r\n\r\n    seekTo(ts) {\r\n        this.fsm.dispatch(PlayerEvents.SEEK, { time: ts });\r\n    }\r\n\r\n    play() {\r\n        this.fsm.dispatch(PlayerEvents.PLAY);\r\n    }\r\n\r\n    pause() {\r\n        this.fsm.dispatch(PlayerEvents.PAUSE);\r\n    }\r\n\r\n    // --- INTERNAL ACTION HANDLERS (Driven by FSM) ---\r\n\r\n    _handleAction(action, payload) {\r\n        console.log(`[Controller] Executing Action: ${action}`, payload);\r\n\r\n        switch (action) {\r\n            case 'initStream':\r\n                // Handled in loadSegments largely\r\n                break;\r\n            case 'play':\r\n                this.video.play().catch(e => console.warn(\"Play interrupted\", e));\r\n                break;\r\n            case 'pause':\r\n                this.video.pause();\r\n                break;\r\n            case 'seek':\r\n                this._performSeek(payload.time);\r\n                break;\r\n            case 'skipGap':\r\n                this._performSeek(payload.nextSegment.start);\r\n                this.fsm.dispatch(PlayerEvents.GAP_RESOLVED);\r\n                break;\r\n        }\r\n    }\r\n\r\n    // --- LOGIC IMPLEMENTATION ---\r\n\r\n    _performSeek(targetEpoch) {\r\n        console.log(`[Controller] Seeking to ${new Date(targetEpoch).toLocaleTimeString()}`);\r\n\r\n        // 1. Find Segment\r\n        const segment = this.segments.find(s => targetEpoch >= s.start && targetEpoch < s.end);\r\n\r\n        if (!segment) {\r\n            // Check for future segment (Gap)\r\n            const nextSeg = this.segments.find(s => s.start > targetEpoch);\r\n            if (nextSeg) {\r\n                console.log(\"[Controller] Gap Detected during Seek.\");\r\n                // FSM handles the logic. We detect it, FSM dispatches GAP, then Action skipGap\r\n                // But wait, we are INSIDE the action handler.\r\n                // We should notify FSM about the Gap.\r\n                this.fsm.dispatch(PlayerEvents.GAP_DETECTED, { nextSegment: nextSeg });\r\n            } else {\r\n                console.log(\"[Controller] End of timeline.\");\r\n                this.fsm.dispatch(PlayerEvents.END);\r\n            }\r\n            return;\r\n        }\r\n\r\n        // 2. Load HLS for specific slice\r\n        // If we are already playing this segment/playlist, maybe just video.currentTime?\r\n        // For Enterprise robustness, we reload the playlist at the specific timestamp \r\n        // to ensure alignment, unless it's a small jump.\r\n\r\n        const playlistUrl = `${this.baseUrl}/playback/playlist/${this.camId}/${segment.start}.m3u8`;\r\n        // Note: Backend must support /playlist/:cam/:startEpoch\r\n\r\n        // Wait, standard route is different? \r\n        // User provided logic implies we just need to load stream.\r\n        // Let's use the one we had: /playback/playlist/:camId.m3u8?start=...\r\n\r\n        const realUrl = `${this.baseUrl}/playback/playlist/${this.camId}.m3u8?start=${targetEpoch}&end=${segment.end}`;\r\n\r\n        if (this.hls) {\r\n            this.hls.destroy();\r\n        }\r\n\r\n        if (Hls.isSupported()) {\r\n            this.hls = new Hls();\r\n            this.hls.loadSource(realUrl);\r\n            this.hls.attachMedia(this.video);\r\n\r\n            this.hls.on(Hls.Events.MANIFEST_PARSED, () => {\r\n                // If the backend generated a playlist starting exactly at targetEpoch,\r\n                // then startPosition is 0.\r\n                this.video.currentTime = 0;\r\n                if (this.fsm.state === PlayerStates.PLAYING || this.fsm.state === PlayerStates.BUFFERING) {\r\n                    this.video.play();\r\n                }\r\n            });\r\n\r\n            this.hls.on(Hls.Events.FRAG_CHANGED, (e, data) => {\r\n                this._currentFragTime = data.frag.programDateTime;\r\n            });\r\n        }\r\n    }\r\n\r\n    _checkGap() {\r\n        // Continuous check during playback\r\n        if (!this.segments.length) return;\r\n\r\n        // Estimate current epoch\r\n        // Ideally HLS provides ProgramDateTime\r\n        if (!this._currentFragTime) return; // Wait for HLS metadata\r\n\r\n        // Calculate exact current epoch\r\n        // simple approx for now assuming _currentFragTime is start of frag\r\n        // this needs robustness, but let's rely on event based GAP from seek first\r\n\r\n        // Monitor if we fell off a segment\r\n    }\r\n\r\n    getCurrentTime() {\r\n        // Return best guess of epoch time for UI sync\r\n        if (this.hls && this._currentFragTime) {\r\n            // Refine this\r\n            return this._currentFragTime + (this.video.currentTime * 1000) % 4000; // vague\r\n        }\r\n        return Date.now(); // Fallback\r\n    }\r\n\r\n}\r\n","import React, { useEffect, useState, useRef, useLayoutEffect } from \"react\";\r\nimport { useSearchParams, useNavigate } from \"react-router-dom\";\r\nimport API from \"../api\";\r\nimport PlaybackController, { PlayerStates } from \"../services/PlaybackController\";\r\n\r\n// --- ENTERPRISE THEME ---\r\nconst btnStyle = { background: \"#444\", color: \"#fff\", border: \"none\", padding: \"4px 8px\", borderRadius: 3, cursor: \"pointer\" };\r\n\r\nconst THEME = {\r\n    bg: \"#1e1e1e\",\r\n    sidebar: \"#252526\",\r\n    header: \"#2d2d2d\",\r\n    text: \"#ffffff\",\r\n    accent: \"#2196f3\",\r\n    segment: \"#4caf50\",\r\n    segmentEvent: \"#2196f3\",\r\n    rulerBg: \"#252526\",\r\n    playhead: \"#ff9800\",\r\n    panelBorder: \"#3e3e42\",\r\n    selectedItem: \"#37373d\"\r\n};\r\n\r\nexport default function PlaybackModern() {\r\n    const [searchParams] = useSearchParams();\r\n    const navigate = useNavigate();\r\n    const camId = searchParams.get(\"camId\");\r\n\r\n    // --- STATE ---\r\n    const [cameras, setCameras] = useState([]);\r\n    const [selectedDate, setSelectedDate] = useState(new Date().toISOString().split('T')[0]);\r\n    const [playerState, setPlayerState] = useState(PlayerStates.IDLE);\r\n\r\n    // --- TIMELINE STATE ---\r\n    const [currentTimeMs, setCurrentTimeMs] = useState(Date.now());\r\n    const [viewportStartMs, setViewportStartMs] = useState(new Date().setHours(0, 0, 0, 0));\r\n    const [zoomPxPerSec, setZoomPxPerSec] = useState(1000 / 86400); // Fit Day Default\r\n    const [containerWidth, setContainerWidth] = useState(1000);\r\n    const [segments, setSegments] = useState([]);\r\n    const [isLoadingData, setIsLoadingData] = useState(false);\r\n\r\n    const videoRef = useRef(null);\r\n    const playerRef = useRef(null);\r\n    const timelineRef = useRef(null);\r\n    const dragRef = useRef({ isDragging: false, startX: 0, startViewTime: 0 });\r\n\r\n    const [recRange, setRecRange] = useState({ start: null, end: null });\r\n\r\n    // --- DATA SETUP ---\r\n    useEffect(() => {\r\n        // Fetch Camera List\r\n        API.get('/cameras').then(res => {\r\n            const list = Array.isArray(res.data) ? res.data : [];\r\n            setCameras(list);\r\n        }).catch(console.error);\r\n    }, []);\r\n\r\n    // Fetch Recording Range\r\n    useEffect(() => {\r\n        if (!camId) return;\r\n        API.get(`/api/playback/range/${camId}`).then(res => {\r\n            setRecRange(res.data);\r\n        }).catch(console.error);\r\n    }, [camId]);\r\n\r\n    // ... existing useEffects ...\r\n\r\n    useEffect(() => {\r\n        if (selectedDate) {\r\n            const start = new Date(selectedDate).setHours(0, 0, 0, 0);\r\n            setViewportStartMs(start);\r\n            // Set Current Time to middle of day or Start? Start (00:00) makes sense for review.\r\n            setCurrentTimeMs(start + 86400000 / 2); // Noon\r\n        }\r\n    }, [selectedDate]);\r\n\r\n    useLayoutEffect(() => {\r\n        if (!timelineRef.current) return;\r\n        // ResizeObserver for robust width detection\r\n        const ro = new ResizeObserver(entries => {\r\n            for (let entry of entries) {\r\n                if (entry.contentRect.width > 0) setContainerWidth(entry.contentRect.width);\r\n            }\r\n        });\r\n        ro.observe(timelineRef.current);\r\n        // Initial set\r\n        setContainerWidth(timelineRef.current.clientWidth || 1000);\r\n        return () => ro.disconnect();\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n        if (videoRef.current && camId) {\r\n            playerRef.current = new PlaybackController(videoRef.current, camId, (s) => setPlayerState(s));\r\n            return () => playerRef.current?.destroy();\r\n        }\r\n    }, [camId]);\r\n\r\n    useEffect(() => {\r\n        if (!camId || !selectedDate) return;\r\n        const fetchData = async () => {\r\n            setIsLoadingData(true);\r\n            setSegments([]);\r\n            try {\r\n                const res = await API.get(`/api/playback/timeline-day/${camId}/${selectedDate}`);\r\n                const data = res.data;\r\n                const serverDayStart = data.dayStart;\r\n\r\n                const localDayStart = new Date(selectedDate).setHours(0, 0, 0, 0);\r\n                let correction = 0;\r\n                if (serverDayStart > 0) {\r\n                    correction = localDayStart - serverDayStart;\r\n                }\r\n\r\n                const segs = (data.segments || []).map(s => ({\r\n                    start: Number(s.start_ts) + correction,\r\n                    end: Number(s.end_ts) + correction,\r\n                    type: 'normal'\r\n                })).sort((a, b) => a.start - b.start);\r\n\r\n                setSegments(segs);\r\n                if (playerRef.current) playerRef.current.loadSegments(segs);\r\n\r\n                setViewportStartMs(localDayStart);\r\n                if (containerWidth > 0) setZoomPxPerSec(containerWidth / 86400);\r\n\r\n            } catch (e) { console.error(e); } finally { setIsLoadingData(false); }\r\n        };\r\n        fetchData();\r\n    }, [camId, selectedDate, containerWidth]);\r\n\r\n    // --- SYNC LOOP ---\r\n    useEffect(() => {\r\n        const i = setInterval(() => {\r\n            if (playerState === PlayerStates.PLAYING && playerRef.current) {\r\n                const now = playerRef.current.getCurrentTime();\r\n                if (Math.abs(now - currentTimeMs) > 200) setCurrentTimeMs(now);\r\n\r\n                // Gap Skip\r\n                const currentSeg = segments.find(s => now >= s.start && now < s.end);\r\n                if (currentSeg && (currentSeg.end - now) < 500) {\r\n                    const nextSeg = segments.find(s => s.start >= currentSeg.end);\r\n                    if (nextSeg && nextSeg.start - currentSeg.end > 1000) {\r\n                        playerRef.current.seekTo(nextSeg.start);\r\n                    }\r\n                }\r\n            }\r\n        }, 100);\r\n        return () => clearInterval(i);\r\n    }, [playerState, currentTimeMs, segments]);\r\n\r\n    // --- ACTIONS ---\r\n    const handleCameraClick = (id) => {\r\n        navigate(`/playback?camId=${id}`);\r\n    };\r\n\r\n    const performSeek = (ts) => {\r\n        setCurrentTimeMs(ts);\r\n        playerRef.current?.seekTo(ts);\r\n    };\r\n\r\n    const fitDay = () => {\r\n        const start = new Date(selectedDate).setHours(0, 0, 0, 0);\r\n        setViewportStartMs(start);\r\n        setZoomPxPerSec(containerWidth / 86400);\r\n    };\r\n\r\n    // --- MOUSE HANDLERS (Constrained Pan) ---\r\n    const handleMouseDown = (e) => {\r\n        dragRef.current = { isDragging: true, startX: e.clientX, startViewTime: viewportStartMs };\r\n    };\r\n\r\n    const handleMouseMove = (e) => {\r\n        if (!dragRef.current.isDragging) return;\r\n        const dx = e.clientX - dragRef.current.startX;\r\n        const dt = -(dx / zoomPxPerSec) * 1000;\r\n\r\n        let newStart = dragRef.current.startViewTime + dt;\r\n\r\n        // CONSTRAIN TO DAY BOUNDARIES (User Request: \"Nu trece de la o zi la alta\")\r\n        const dayStart = new Date(selectedDate).setHours(0, 0, 0, 0);\r\n        const dayEnd = dayStart + 86400000;\r\n\r\n        // Allow zooming but keep view within day range roughly\r\n        // If zoomed in, we can pan. But don't pan past 00:00 or 24:00 relative to container?\r\n        // Actually, just clamp strictly.\r\n        if (newStart < dayStart) newStart = dayStart;\r\n        if (newStart > dayEnd - (containerWidth / zoomPxPerSec * 1000)) {\r\n            // newStart cannot ensure end > dayEnd completely if zoomed out?\r\n            // If zoomed out Max (fit day), newStart is dayStart.\r\n            // If zoomed in, restrict right edge.\r\n            // Let's just create a soft clamp for left side 00:00\r\n        }\r\n        setViewportStartMs(newStart);\r\n    };\r\n\r\n    const handleMouseUp = (e) => {\r\n        dragRef.current.isDragging = false;\r\n        if (Math.abs(e.clientX - dragRef.current.startX) < 5) {\r\n            const rect = timelineRef.current.getBoundingClientRect();\r\n            const clickX = e.clientX - rect.left;\r\n            const ts = viewportStartMs + (clickX / zoomPxPerSec) * 1000;\r\n            performSeek(ts);\r\n        }\r\n    };\r\n\r\n    const handleWheel = (e) => {\r\n        if (e.target.closest('.timeline-area')) {\r\n            e.preventDefault();\r\n            const rect = timelineRef.current.getBoundingClientRect();\r\n            const mouseX = e.clientX - rect.left;\r\n            const timeUnderMouse = viewportStartMs + (mouseX / zoomPxPerSec) * 1000;\r\n            const factor = e.deltaY > 0 ? 0.9 : 1.1;\r\n            const newZoom = Math.max(containerWidth / 86400, Math.min(5.0, zoomPxPerSec * factor));\r\n\r\n            // Calc new start to keep mouse time static\r\n            let newStart = timeUnderMouse - (mouseX / newZoom) * 1000;\r\n\r\n            // Constrain\r\n            const dayStart = new Date(selectedDate).setHours(0, 0, 0, 0);\r\n            if (newStart < dayStart) newStart = dayStart;\r\n\r\n            setZoomPxPerSec(newZoom);\r\n            setViewportStartMs(newStart);\r\n        }\r\n    };\r\n\r\n    // --- RENDER HELPERS ---\r\n    const timeToPx = (t) => (t - viewportStartMs) / 1000 * zoomPxPerSec;\r\n\r\n    const renderRuler = () => {\r\n        const ticks = [];\r\n        const stepMs = (3600 * 1000); // Fixed 1 Hour ticks for \"0-24\" stability\r\n        const dayStart = new Date(selectedDate).setHours(0, 0, 0, 0);\r\n\r\n        for (let i = 0; i <= 24; i++) {\r\n            const t = dayStart + i * stepMs;\r\n            const x = timeToPx(t);\r\n            if (x < -20 || x > containerWidth) continue;\r\n            ticks.push(\r\n                <div key={i} style={{ position: 'absolute', left: x, top: 0, height: 25, borderLeft: '1px solid #666' }}>\r\n                    <div style={{ position: 'absolute', top: 2, left: 4, fontSize: 11, color: '#aaa' }}>{i}:00</div>\r\n                </div>\r\n            );\r\n        }\r\n        return ticks;\r\n    };\r\n\r\n    return (\r\n        <div style={{ display: 'flex', width: '100%', height: '100%', background: THEME.bg, color: THEME.text }}>\r\n\r\n            {/* SIDEBAR - CAMERA LIST */}\r\n            <div style={{ width: 250, background: THEME.sidebar, borderSizing: 'border-box', borderRight: `1px solid ${THEME.panelBorder}`, display: 'flex', flexDirection: 'column' }}>\r\n                <div style={{ padding: \"12px 16px\", fontWeight: 'bold', borderBottom: `1px solid ${THEME.panelBorder}`, color: THEME.accent, fontSize: 12, letterSpacing: 1 }}>CHANNELS</div>\r\n                <div style={{ flex: 1, overflowY: 'auto' }}>\r\n                    {cameras.map(cam => (\r\n                        <div key={cam.id}\r\n                            onClick={() => handleCameraClick(cam.id)}\r\n                            style={{\r\n                                padding: '10px 16px', cursor: 'pointer', fontSize: 13,\r\n                                borderBottom: `1px solid rgba(255,255,255,0.02)`,\r\n                                background: camId === cam.id ? THEME.selectedItem : 'transparent',\r\n                                color: camId === cam.id ? THEME.accent : '#aaa',\r\n                                borderLeft: camId === cam.id ? `3px solid ${THEME.accent}` : '3px solid transparent'\r\n                            }}>\r\n                            {cam.name || cam.id}\r\n                        </div>\r\n                    ))}\r\n                    {cameras.length === 0 && <div style={{ padding: 10, color: '#888' }}>No cameras found</div>}\r\n                </div>\r\n            </div>\r\n\r\n            {/* MAIN CONTENT */}\r\n            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>\r\n                <header style={{ height: 44, background: THEME.header, display: 'flex', alignItems: 'center', padding: '0 12px', borderBottom: `1px solid ${THEME.panelBorder}`, gap: 15 }}>\r\n                    <button\r\n                        onClick={() => navigate('/live')}\r\n                        style={{ ...btnStyle, background: 'transparent', padding: '4px 8px', fontSize: 16 }}\r\n                        title=\"Back to Live\"\r\n                    >\r\n                        ⬅️\r\n                    </button>\r\n                    <span style={{ fontWeight: 'bold', color: THEME.accent, fontSize: 14 }}>ARHIVĂ VMS</span>\r\n                    {camId && (\r\n                        <span style={{ fontSize: 13, background: 'rgba(255,255,255,0.05)', padding: '2px 8px', borderRadius: 4 }}>\r\n                            {cameras.find(c => c.id === camId)?.name || camId}\r\n                        </span>\r\n                    )}\r\n                    {recRange.start && (\r\n                        <span style={{ fontSize: 11, color: '#888' }}>\r\n                            ({new Date(recRange.start).toLocaleDateString()} - {new Date(recRange.end).toLocaleDateString()})\r\n                        </span>\r\n                    )}\r\n                    <div style={{ flex: 1 }} />\r\n                    <input type=\"date\" value={selectedDate} onChange={e => setSelectedDate(e.target.value)}\r\n                        style={{ background: '#333', color: '#fff', border: '1px solid #444', borderRadius: 4, padding: '4px 8px', fontSize: 12 }} />\r\n                </header>\r\n\r\n                <div style={{ flex: 1, position: 'relative', background: '#000', overflow: 'hidden', minHeight: 0 }}>\r\n                    <video ref={videoRef} style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', objectFit: 'contain' }} />\r\n                    {!camId && <div style={{ position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', color: '#aaa' }}>Select a Camera</div>}\r\n                </div>\r\n\r\n                <div style={{ height: 48, background: '#252526', display: 'flex', alignItems: 'center', padding: '0 10px', gap: 10 }}>\r\n                    <button style={btnStyle} onClick={() => performSeek(currentTimeMs - 5000)}>⏪</button>\r\n                    <button style={btnStyle} onClick={() => playerState === PlayerStates.PLAYING ? playerRef.current?.pause() : playerRef.current?.play()}>\r\n                        {playerState === PlayerStates.PLAYING ? \"PAUSE\" : \"PLAY\"}\r\n                    </button>\r\n                    <button style={btnStyle} onClick={() => performSeek(currentTimeMs + 5000)}>⏩</button>\r\n                    <span style={{ flex: 1, textAlign: 'center', fontFamily: 'monospace' }}>\r\n                        {new Date(currentTimeMs).toLocaleTimeString()}\r\n                    </span>\r\n                    <button style={btnStyle} onClick={fitDay}>24H</button>\r\n                </div>\r\n\r\n                <div className=\"timeline-area\" ref={timelineRef}\r\n                    style={{ height: 100, background: THEME.rulerBg, position: 'relative', overflow: 'hidden' }}\r\n                    onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onMouseMove={handleMouseMove} onMouseDown={handleMouseDown} onWheel={handleWheel}\r\n                >\r\n                    <div style={{ height: 25, borderBottom: '1px solid #444' }}>{renderRuler()}</div>\r\n                    <div style={{ position: 'relative', top: 5, height: 40 }}>\r\n                        {segments.map((s, i) => {\r\n                            const x = timeToPx(s.start);\r\n                            const w = Math.max(2, (s.end - s.start) / 1000 * zoomPxPerSec);\r\n                            if (x + w < 0 || x > containerWidth) return null;\r\n                            return <div key={i} style={{ position: 'absolute', left: x, width: w, height: '100%', background: THEME.segment }} />\r\n                        })}\r\n                    </div>\r\n                    <div style={{ position: 'absolute', left: timeToPx(currentTimeMs), top: 0, bottom: 0, width: 2, background: THEME.playhead, zIndex: 10 }} />\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\n\r\n","import axios from \"axios\";\r\n\r\n// Use relative path or detect Proxy base\r\nlet baseURL = \"\";\r\nif (typeof window !== 'undefined') {\r\n    // Check for proxy in full URL (HashRouter compatibility)\r\n    const match = window.location.href.match(/(\\/api\\/proxy\\/[^\\/]+)/);\r\n    if (match) {\r\n        baseURL = match[1];\r\n    } else if (window.location.hash.includes(\"#/\")) {\r\n        // Fallback for local dev or direct access\r\n        baseURL = \"\";\r\n    }\r\n}\r\n\r\nconst API = axios.create({\r\n    baseURL: baseURL\r\n});\r\n\r\nexport { API, baseURL };\r\nexport default API;\r\n"],"names":["PlayerStates","Object","freeze","IDLE","LOADING","READY","PLAYING","PAUSED","BUFFERING","GAP","ERROR","PlayerEvents","LOAD_LIVE","LOAD_PLAYBACK","METADATA_READY","VIDEO_TRACK_READY","PLAY","PAUSE","SEEK","BUFFER_EMPTY","BUFFER_FULL","GAP_DETECTED","GAP_RESOLVED","END","RESET","PlayerStateMachine","constructor","_ref","onStateChange","onAction","logger","console","this","state","log","transition","next","payload","debug","concat","dispatch","event","arguments","length","undefined","error","PlaybackController","videoElement","camId","baseUrl","video","segments","hls","fsm","action","_handleAction","_bindVideoEvents","addEventListener","e","_checkGap","destroy","loadSegments","map","s","start","Number","start_ts","startTs","end","end_ts","endTs","file","sort","a","b","seekTo","ts","time","play","pause","catch","warn","_performSeek","nextSegment","targetEpoch","Date","toLocaleTimeString","segment","find","nextSeg","realUrl","Hls","loadSource","attachMedia","on","MANIFEST_PARSED","currentTime","FRAG_CHANGED","data","_currentFragTime","frag","programDateTime","getCurrentTime","now","btnStyle","background","color","border","padding","borderRadius","cursor","THEME","PlaybackModern","_cameras$find","searchParams","useSearchParams","navigate","useNavigate","get","cameras","setCameras","useState","selectedDate","setSelectedDate","toISOString","split","playerState","setPlayerState","currentTimeMs","setCurrentTimeMs","viewportStartMs","setViewportStartMs","setHours","zoomPxPerSec","setZoomPxPerSec","containerWidth","setContainerWidth","setSegments","isLoadingData","setIsLoadingData","videoRef","useRef","playerRef","timelineRef","dragRef","isDragging","startX","startViewTime","recRange","setRecRange","useEffect","API","then","res","list","Array","isArray","useLayoutEffect","current","ro","ResizeObserver","entries","entry","contentRect","width","observe","clientWidth","disconnect","_playerRef$current","async","serverDayStart","dayStart","localDayStart","correction","segs","type","fetchData","i","setInterval","Math","abs","currentSeg","clearInterval","performSeek","_playerRef$current2","handleMouseUp","clientX","rect","getBoundingClientRect","clickX","left","timeToPx","t","_jsxs","style","display","height","children","borderSizing","borderRight","flexDirection","_jsx","fontWeight","borderBottom","fontSize","letterSpacing","flex","overflowY","cam","onClick","handleCameraClick","id","borderLeft","name","overflow","alignItems","gap","_objectSpread","title","c","toLocaleDateString","value","onChange","target","position","minHeight","ref","top","objectFit","transform","_playerRef$current3","_playerRef$current4","textAlign","fontFamily","fitDay","className","onMouseUp","onMouseLeave","onMouseMove","dt","newStart","onMouseDown","onWheel","closest","preventDefault","mouseX","timeUnderMouse","factor","deltaY","newZoom","max","min","renderRuler","ticks","x","push","w","bottom","zIndex","baseURL","window","match","location","href","hash","includes","axios","create"],"ignoreList":[],"sourceRoot":""}