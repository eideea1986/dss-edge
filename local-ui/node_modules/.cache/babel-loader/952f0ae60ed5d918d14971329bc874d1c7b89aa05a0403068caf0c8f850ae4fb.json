{"ast":null,"code":"import Hls from 'hls.js';\nimport { PlayerStateMachine, PlayerEvents, PlayerStates } from './PlayerStateMachine';\nexport { PlayerStates };\nexport default class PlaybackController {\n  constructor(videoElement, camId, onStateChange, baseUrl = '/api') {\n    this.video = videoElement;\n    this.camId = camId;\n    this.baseUrl = baseUrl;\n    this.segments = [];\n    this.hls = null;\n\n    // --- 1. Initialize FSM ---\n    this.fsm = new PlayerStateMachine({\n      onStateChange: (state, payload) => {\n        if (onStateChange) onStateChange(state, payload);\n      },\n      onAction: (action, payload) => this._handleAction(action, payload)\n    });\n\n    // --- 2. Bind Video Events ---\n    this._bindVideoEvents();\n  }\n  _bindVideoEvents() {\n    this.video.addEventListener('waiting', () => {\n      this.fsm.dispatch(PlayerEvents.BUFFER_EMPTY);\n    });\n    this.video.addEventListener('playing', () => {\n      this.fsm.dispatch(PlayerEvents.BUFFER_FULL);\n    });\n    // We handle Pause manually to avoid conflicts with Seek/Buffer logic\n    this.video.addEventListener('error', e => {\n      this.fsm.dispatch(PlayerEvents.ERROR, {\n        error: e\n      });\n    });\n\n    // Gap Detection Monitor\n    this.video.addEventListener('timeupdate', () => this._checkGap());\n  }\n  destroy() {\n    if (this.hls) {\n      this.hls.destroy();\n      this.hls = null;\n    }\n    // Remove listeners if needed\n  }\n\n  // --- EXTERNAL PUBLIC API (Called by React UI) ---\n\n  loadSegments(segments) {\n    // Validate & Sort\n    this.segments = (segments || []).map(s => ({\n      start: Number(s.start || s.start_ts || s.startTs),\n      end: Number(s.end || s.end_ts || s.endTs),\n      file: s.file\n    })).sort((a, b) => a.start - b.start);\n    if (this.segments.length > 0) {\n      // Signal FSM that metadata is ready\n      // We initiate \"Load Playback\"\n      this.fsm.dispatch(PlayerEvents.LOAD_PLAYBACK, {\n        camId: this.camId,\n        segments: this.segments\n      });\n\n      // In our case, metadata is segments. Video track is ready when we select a segment.\n      // For now, let's say Metadata is ready.\n      this.fsm.dispatch(PlayerEvents.METADATA_READY);\n\n      // Auto-load first segment or wait?\n      // User usually clicks timeline. Let's wait for user to Seek or Play.\n      // But if we want to be \"READY\", we probably need a valid source.\n      // However, we don't know WHERE to start yet.\n      // Let's force READY state if we have segments, assuming user will Seek.\n      // To do this cleanly, we can pretend video track is ready or just wait for seek.\n      // Actually, we can dispatch VIDEO_TRACK_READY once the user actively seeks.\n      // For now, let's leave it in LOADING or transition to READY manually?\n      // The FSM says LOADING -> READY on VIDEO_TRACK_READY.\n      // Let's assume we are conceptually READY since we have the timeline.\n      this.fsm.dispatch(PlayerEvents.VIDEO_TRACK_READY);\n    }\n  }\n  seekTo(ts) {\n    this.fsm.dispatch(PlayerEvents.SEEK, {\n      time: ts\n    });\n  }\n  play() {\n    this.fsm.dispatch(PlayerEvents.PLAY);\n  }\n  pause() {\n    this.fsm.dispatch(PlayerEvents.PAUSE);\n  }\n\n  // --- INTERNAL ACTION HANDLERS (Driven by FSM) ---\n\n  _handleAction(action, payload) {\n    console.log(`[Controller] Executing Action: ${action}`, payload);\n    switch (action) {\n      case 'initStream':\n        // Handled in loadSegments largely\n        break;\n      case 'play':\n        this.video.play().catch(e => console.warn(\"Play interrupted\", e));\n        break;\n      case 'pause':\n        this.video.pause();\n        break;\n      case 'seek':\n        this._performSeek(payload.time);\n        break;\n      case 'skipGap':\n        this._performSeek(payload.nextSegment.start);\n        this.fsm.dispatch(PlayerEvents.GAP_RESOLVED);\n        break;\n    }\n  }\n\n  // --- LOGIC IMPLEMENTATION ---\n\n  _performSeek(targetEpoch) {\n    console.log(`[Controller] Seeking to ${new Date(targetEpoch).toLocaleTimeString()}`);\n\n    // 1. Find Segment\n    const segment = this.segments.find(s => targetEpoch >= s.start && targetEpoch < s.end);\n    if (!segment) {\n      // Check for future segment (Gap)\n      const nextSeg = this.segments.find(s => s.start > targetEpoch);\n      if (nextSeg) {\n        console.log(\"[Controller] Gap Detected during Seek.\");\n        // FSM handles the logic. We detect it, FSM dispatches GAP, then Action skipGap\n        // But wait, we are INSIDE the action handler.\n        // We should notify FSM about the Gap.\n        this.fsm.dispatch(PlayerEvents.GAP_DETECTED, {\n          nextSegment: nextSeg\n        });\n      } else {\n        console.log(\"[Controller] End of timeline.\");\n        this.fsm.dispatch(PlayerEvents.END);\n      }\n      return;\n    }\n\n    // 2. Load HLS for specific slice\n    // If we are already playing this segment/playlist, maybe just video.currentTime?\n    // For Enterprise robustness, we reload the playlist at the specific timestamp \n    // to ensure alignment, unless it's a small jump.\n\n    const playlistUrl = `${this.baseUrl}/playback/playlist/${this.camId}/${segment.start}.m3u8`;\n    // Note: Backend must support /playlist/:cam/:startEpoch\n\n    // Wait, standard route is different? \n    // User provided logic implies we just need to load stream.\n    // Let's use the one we had: /playback/playlist/:camId.m3u8?start=...\n\n    const realUrl = `${this.baseUrl}/playback/playlist/${this.camId}.m3u8?start=${targetEpoch}&end=${segment.end}`;\n    if (this.hls) {\n      this.hls.destroy();\n    }\n    if (Hls.isSupported()) {\n      this.hls = new Hls();\n      this.hls.loadSource(realUrl);\n      this.hls.attachMedia(this.video);\n      this.hls.on(Hls.Events.MANIFEST_PARSED, () => {\n        // If the backend generated a playlist starting exactly at targetEpoch,\n        // then startPosition is 0.\n        this.video.currentTime = 0;\n        if (this.fsm.state === PlayerStates.PLAYING || this.fsm.state === PlayerStates.BUFFERING) {\n          this.video.play();\n        }\n      });\n      this.hls.on(Hls.Events.FRAG_CHANGED, (e, data) => {\n        this._currentFragTime = data.frag.programDateTime;\n      });\n    }\n  }\n  _checkGap() {\n    // Continuous check during playback\n    if (!this.segments.length) return;\n\n    // Estimate current epoch\n    // Ideally HLS provides ProgramDateTime\n    if (!this._currentFragTime) return; // Wait for HLS metadata\n\n    // Calculate exact current epoch\n    // simple approx for now assuming _currentFragTime is start of frag\n    // this needs robustness, but let's rely on event based GAP from seek first\n\n    // Monitor if we fell off a segment\n  }\n  getCurrentTime() {\n    // Return best guess of epoch time for UI sync\n    if (this.hls && this._currentFragTime) {\n      // Refine this\n      return this._currentFragTime + this.video.currentTime * 1000 % 4000; // vague\n    }\n    return Date.now(); // Fallback\n  }\n}","map":{"version":3,"names":["Hls","PlayerStateMachine","PlayerEvents","PlayerStates","PlaybackController","constructor","videoElement","camId","onStateChange","baseUrl","video","segments","hls","fsm","state","payload","onAction","action","_handleAction","_bindVideoEvents","addEventListener","dispatch","BUFFER_EMPTY","BUFFER_FULL","e","ERROR","error","_checkGap","destroy","loadSegments","map","s","start","Number","start_ts","startTs","end","end_ts","endTs","file","sort","a","b","length","LOAD_PLAYBACK","METADATA_READY","VIDEO_TRACK_READY","seekTo","ts","SEEK","time","play","PLAY","pause","PAUSE","console","log","catch","warn","_performSeek","nextSegment","GAP_RESOLVED","targetEpoch","Date","toLocaleTimeString","segment","find","nextSeg","GAP_DETECTED","END","playlistUrl","realUrl","isSupported","loadSource","attachMedia","on","Events","MANIFEST_PARSED","currentTime","PLAYING","BUFFERING","FRAG_CHANGED","data","_currentFragTime","frag","programDateTime","getCurrentTime","now"],"sources":["I:/dispecerat/github_release/dss-edge/local-ui/src/services/PlaybackController.js"],"sourcesContent":["import Hls from 'hls.js';\r\nimport { PlayerStateMachine, PlayerEvents, PlayerStates } from './PlayerStateMachine';\r\n\r\nexport { PlayerStates };\r\n\r\nexport default class PlaybackController {\r\n    constructor(videoElement, camId, onStateChange, baseUrl = '/api') {\r\n        this.video = videoElement;\r\n        this.camId = camId;\r\n        this.baseUrl = baseUrl;\r\n        this.segments = [];\r\n        this.hls = null;\r\n\r\n        // --- 1. Initialize FSM ---\r\n        this.fsm = new PlayerStateMachine({\r\n            onStateChange: (state, payload) => {\r\n                if (onStateChange) onStateChange(state, payload);\r\n            },\r\n            onAction: (action, payload) => this._handleAction(action, payload)\r\n        });\r\n\r\n        // --- 2. Bind Video Events ---\r\n        this._bindVideoEvents();\r\n    }\r\n\r\n    _bindVideoEvents() {\r\n        this.video.addEventListener('waiting', () => {\r\n            this.fsm.dispatch(PlayerEvents.BUFFER_EMPTY);\r\n        });\r\n        this.video.addEventListener('playing', () => {\r\n            this.fsm.dispatch(PlayerEvents.BUFFER_FULL);\r\n        });\r\n        // We handle Pause manually to avoid conflicts with Seek/Buffer logic\r\n        this.video.addEventListener('error', (e) => {\r\n            this.fsm.dispatch(PlayerEvents.ERROR, { error: e });\r\n        });\r\n\r\n        // Gap Detection Monitor\r\n        this.video.addEventListener('timeupdate', () => this._checkGap());\r\n    }\r\n\r\n    destroy() {\r\n        if (this.hls) {\r\n            this.hls.destroy();\r\n            this.hls = null;\r\n        }\r\n        // Remove listeners if needed\r\n    }\r\n\r\n    // --- EXTERNAL PUBLIC API (Called by React UI) ---\r\n\r\n    loadSegments(segments) {\r\n        // Validate & Sort\r\n        this.segments = (segments || []).map(s => ({\r\n            start: Number(s.start || s.start_ts || s.startTs),\r\n            end: Number(s.end || s.end_ts || s.endTs),\r\n            file: s.file\r\n        })).sort((a, b) => a.start - b.start);\r\n\r\n        if (this.segments.length > 0) {\r\n            // Signal FSM that metadata is ready\r\n            // We initiate \"Load Playback\"\r\n            this.fsm.dispatch(PlayerEvents.LOAD_PLAYBACK, { camId: this.camId, segments: this.segments });\r\n\r\n            // In our case, metadata is segments. Video track is ready when we select a segment.\r\n            // For now, let's say Metadata is ready.\r\n            this.fsm.dispatch(PlayerEvents.METADATA_READY);\r\n\r\n            // Auto-load first segment or wait?\r\n            // User usually clicks timeline. Let's wait for user to Seek or Play.\r\n            // But if we want to be \"READY\", we probably need a valid source.\r\n            // However, we don't know WHERE to start yet.\r\n            // Let's force READY state if we have segments, assuming user will Seek.\r\n            // To do this cleanly, we can pretend video track is ready or just wait for seek.\r\n            // Actually, we can dispatch VIDEO_TRACK_READY once the user actively seeks.\r\n            // For now, let's leave it in LOADING or transition to READY manually?\r\n            // The FSM says LOADING -> READY on VIDEO_TRACK_READY.\r\n            // Let's assume we are conceptually READY since we have the timeline.\r\n            this.fsm.dispatch(PlayerEvents.VIDEO_TRACK_READY);\r\n        }\r\n    }\r\n\r\n    seekTo(ts) {\r\n        this.fsm.dispatch(PlayerEvents.SEEK, { time: ts });\r\n    }\r\n\r\n    play() {\r\n        this.fsm.dispatch(PlayerEvents.PLAY);\r\n    }\r\n\r\n    pause() {\r\n        this.fsm.dispatch(PlayerEvents.PAUSE);\r\n    }\r\n\r\n    // --- INTERNAL ACTION HANDLERS (Driven by FSM) ---\r\n\r\n    _handleAction(action, payload) {\r\n        console.log(`[Controller] Executing Action: ${action}`, payload);\r\n\r\n        switch (action) {\r\n            case 'initStream':\r\n                // Handled in loadSegments largely\r\n                break;\r\n            case 'play':\r\n                this.video.play().catch(e => console.warn(\"Play interrupted\", e));\r\n                break;\r\n            case 'pause':\r\n                this.video.pause();\r\n                break;\r\n            case 'seek':\r\n                this._performSeek(payload.time);\r\n                break;\r\n            case 'skipGap':\r\n                this._performSeek(payload.nextSegment.start);\r\n                this.fsm.dispatch(PlayerEvents.GAP_RESOLVED);\r\n                break;\r\n        }\r\n    }\r\n\r\n    // --- LOGIC IMPLEMENTATION ---\r\n\r\n    _performSeek(targetEpoch) {\r\n        console.log(`[Controller] Seeking to ${new Date(targetEpoch).toLocaleTimeString()}`);\r\n\r\n        // 1. Find Segment\r\n        const segment = this.segments.find(s => targetEpoch >= s.start && targetEpoch < s.end);\r\n\r\n        if (!segment) {\r\n            // Check for future segment (Gap)\r\n            const nextSeg = this.segments.find(s => s.start > targetEpoch);\r\n            if (nextSeg) {\r\n                console.log(\"[Controller] Gap Detected during Seek.\");\r\n                // FSM handles the logic. We detect it, FSM dispatches GAP, then Action skipGap\r\n                // But wait, we are INSIDE the action handler.\r\n                // We should notify FSM about the Gap.\r\n                this.fsm.dispatch(PlayerEvents.GAP_DETECTED, { nextSegment: nextSeg });\r\n            } else {\r\n                console.log(\"[Controller] End of timeline.\");\r\n                this.fsm.dispatch(PlayerEvents.END);\r\n            }\r\n            return;\r\n        }\r\n\r\n        // 2. Load HLS for specific slice\r\n        // If we are already playing this segment/playlist, maybe just video.currentTime?\r\n        // For Enterprise robustness, we reload the playlist at the specific timestamp \r\n        // to ensure alignment, unless it's a small jump.\r\n\r\n        const playlistUrl = `${this.baseUrl}/playback/playlist/${this.camId}/${segment.start}.m3u8`;\r\n        // Note: Backend must support /playlist/:cam/:startEpoch\r\n\r\n        // Wait, standard route is different? \r\n        // User provided logic implies we just need to load stream.\r\n        // Let's use the one we had: /playback/playlist/:camId.m3u8?start=...\r\n\r\n        const realUrl = `${this.baseUrl}/playback/playlist/${this.camId}.m3u8?start=${targetEpoch}&end=${segment.end}`;\r\n\r\n        if (this.hls) {\r\n            this.hls.destroy();\r\n        }\r\n\r\n        if (Hls.isSupported()) {\r\n            this.hls = new Hls();\r\n            this.hls.loadSource(realUrl);\r\n            this.hls.attachMedia(this.video);\r\n\r\n            this.hls.on(Hls.Events.MANIFEST_PARSED, () => {\r\n                // If the backend generated a playlist starting exactly at targetEpoch,\r\n                // then startPosition is 0.\r\n                this.video.currentTime = 0;\r\n                if (this.fsm.state === PlayerStates.PLAYING || this.fsm.state === PlayerStates.BUFFERING) {\r\n                    this.video.play();\r\n                }\r\n            });\r\n\r\n            this.hls.on(Hls.Events.FRAG_CHANGED, (e, data) => {\r\n                this._currentFragTime = data.frag.programDateTime;\r\n            });\r\n        }\r\n    }\r\n\r\n    _checkGap() {\r\n        // Continuous check during playback\r\n        if (!this.segments.length) return;\r\n\r\n        // Estimate current epoch\r\n        // Ideally HLS provides ProgramDateTime\r\n        if (!this._currentFragTime) return; // Wait for HLS metadata\r\n\r\n        // Calculate exact current epoch\r\n        // simple approx for now assuming _currentFragTime is start of frag\r\n        // this needs robustness, but let's rely on event based GAP from seek first\r\n\r\n        // Monitor if we fell off a segment\r\n    }\r\n\r\n    getCurrentTime() {\r\n        // Return best guess of epoch time for UI sync\r\n        if (this.hls && this._currentFragTime) {\r\n            // Refine this\r\n            return this._currentFragTime + (this.video.currentTime * 1000) % 4000; // vague\r\n        }\r\n        return Date.now(); // Fallback\r\n    }\r\n\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}