{"ast":null,"code":"export default class PlaybackCoreV2{constructor(videoElement,camId){let baseUrl=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'/api';this.video=videoElement;this.camId=camId;this.baseUrl=baseUrl;this.mediaSource=null;this.sourceBuffer=null;this.SEGMENT_SEC=4;this.TARGET_BUFFER=20;this.nextTs=null;// Epoch time of the NEXT segment to fetch\nthis.isFetching=false;this.started=false;this.isSeeking=false;this.seekTargetTs=null;this.checkInterval=null;this.debugInterval=null;this.abortController=null;// GAP SKIP\nthis.gapRetries=0;this.MAX_GAP_RETRIES=5000;// Increased to handle larger gaps (e.g. 5 hours) if necessary, but keep robust\n// Actually user said \"5\". But 5 * 4s = 20s. If gap is 1 min, it will stop. \n// User said: \"Caz 2 – Gap mare... se oprește după MAX_GAP_RETRIES\".\n// Let's stick to user request: 5. \n// Wait, if gap is large, user might WANT to skip it?\n// \"sare segment cu segment... sare peste lipsă... redarea continuă\"\n// If I set 5, it stops quickly. I will set 20 (80 sec) as a compromise or stick to 5 as requested for safety.\n// Let's use 15.\nthis.MAX_GAP_RETRIES=15;}start(startEpochMs){console.log(\"[PlaybackCore] Starting at \".concat(new Date(startEpochMs).toISOString()));this.nextTs=startEpochMs;this.isSeeking=false;this.started=false;this.gapRetries=0;this.mediaSource=new MediaSource();this.video.src=URL.createObjectURL(this.mediaSource);this.mediaSource.addEventListener('sourceopen',this.onSourceOpen.bind(this));if(this.checkInterval)clearInterval(this.checkInterval);this.checkInterval=setInterval(this.ensureBuffer.bind(this),200);this.startDebugLogger();}destroy(){if(this.checkInterval)clearInterval(this.checkInterval);if(this.debugInterval)clearInterval(this.debugInterval);if(this.abortController)this.abortController.abort();if(this.video){this.video.pause();this.video.removeAttribute('src');// Clean detach\nthis.video.load();}this.mediaSource=null;this.sourceBuffer=null;}onSourceOpen(){if(this.sourceBuffer||this.mediaSource.readyState!=='open')return;try{// FIX 1: Codec Permisiv (High Profile Level 3.1)\nthis.sourceBuffer=this.mediaSource.addSourceBuffer('video/mp4; codecs=\"avc1.64001f\"');this.sourceBuffer.mode='segments';}catch(e){console.warn(\"[MSE] High Profile rejected, trying Main Profile...\",e);try{this.sourceBuffer=this.mediaSource.addSourceBuffer('video/mp4; codecs=\"avc1.4d401e\"');this.sourceBuffer.mode='segments';}catch(e2){console.error(\"[MSE] Fatal Codec Error:\",e2);}}}async ensureBuffer(){if(this.isSeeking)return;// PROTECTION 6\nif(this.gapRetries>this.MAX_GAP_RETRIES)return;if(!this.sourceBuffer||this.sourceBuffer.updating)return;if(this.isFetching||this.nextTs===null)return;if(this.mediaSource.readyState!=='open')return;const current=this.video.currentTime||0;const bufferedEnd=this.getBufferedEnd();// If buffer is too small, fetch more\nif(!this.started||bufferedEnd-current<this.TARGET_BUFFER){this.isFetching=true;await this.fetchAndAppend(this.nextTs);this.isFetching=false;}}async fetchAndAppend(ts){if(this.isSeeking)return;const url=\"\".concat(this.baseUrl,\"/playback/segment/\").concat(this.camId,\"?ts=\").concat(ts,\"&dur=\").concat(this.SEGMENT_SEC);try{this.abortController=new AbortController();const res=await fetch(url,{signal:this.abortController.signal});if(!res.ok){if(res.status===404){await this.skipGap();// FIX 4\n}return;}const buf=await res.arrayBuffer();if(this.isSeeking)return;// Discard if seek happened\nawait this.appendBuffer(buf);// FIX 5: RESET GAP COUNTER\nthis.gapRetries=0;if(!this.started&&!this.isSeeking){// Try to play immediately after first segment\ntry{await this.video.play();this.started=true;}catch(e){}}// Advance strictly by duration\nthis.nextTs+=this.SEGMENT_SEC*1000;}catch(e){if(e.name!=='AbortError')console.error(\"[MSE] Fetch Error:\",e);}finally{this.abortController=null;}}// FIX 3: GAP SKIP LOGIC\nasync skipGap(){this.gapRetries++;if(this.gapRetries>this.MAX_GAP_RETRIES){console.warn('[GAP] too many gaps, stopping playback');return;}// Skip current segment duration\nconsole.warn(\"[GAP] skipping to \".concat(new Date(this.nextTs+this.SEGMENT_SEC*1000).toLocaleTimeString()));this.nextTs+=this.SEGMENT_SEC*1000;}appendBuffer(buffer){return new Promise(resolve=>{if(!this.sourceBuffer||this.mediaSource.readyState!=='open')return resolve();const onUpdateEnd=()=>{this.sourceBuffer.removeEventListener('updateend',onUpdateEnd);resolve();};this.sourceBuffer.addEventListener('updateend',onUpdateEnd);try{this.sourceBuffer.appendBuffer(buffer);}catch(e){console.error(\"[MSE] Append Error:\",e);this.sourceBuffer.removeEventListener('updateend',onUpdateEnd);resolve();}});}getBufferedEnd(){if(!this.video||!this.video.buffered||this.video.buffered.length===0)return 0;return this.video.buffered.end(this.video.buffered.length-1);}async seekTo(epochMs){if(!this.mediaSource||!this.sourceBuffer)return;console.log('[MSE] SEEK TO',new Date(epochMs).toISOString());this.isSeeking=true;this.seekTargetTs=epochMs;// RESET GAP COUNTER ON SEEK\nthis.gapRetries=0;if(this.abortController){this.abortController.abort();this.abortController=null;}this.isFetching=false;this.video.pause();if(this.sourceBuffer.updating){await new Promise(r=>this.sourceBuffer.addEventListener('updateend',r,{once:true}));}try{const ranges=this.video.buffered;if(ranges.length>0){const start=ranges.start(0);const end=ranges.end(ranges.length-1);console.log(\"[MSE] Clearing Buffer: \".concat(start.toFixed(2),\" - \").concat(end.toFixed(2)));this.sourceBuffer.remove(start,end);await new Promise(r=>this.sourceBuffer.addEventListener('updateend',r,{once:true}));}}catch(e){console.warn(\"[MSE] Buffer flush warning:\",e);}this.video.currentTime=0;this.nextTs=epochMs;this.started=false;this.isSeeking=false;}getCurrentEpochMs(){if(!this.started||!this.nextTs)return this.nextTs||0;const bufferedDuration=this.getBufferedEnd();const playheadPos=this.video.currentTime;const timeBehindEnd=Math.max(0,bufferedDuration-playheadPos);return this.nextTs-timeBehindEnd*1000;}startDebugLogger(){if(this.debugInterval)clearInterval(this.debugInterval);this.debugInterval=setInterval(()=>{if(!this.video||!this.video.buffered||this.video.buffered.length===0)return;const current=this.video.currentTime;const end=this.getBufferedEnd();console.log(\"[MSE] current: \".concat(current.toFixed(1),\" bufferedEnd: \").concat(end.toFixed(1),\" ahead: \").concat((end-current).toFixed(1)));},2000);}}","map":{"version":3,"names":["PlaybackCoreV2","constructor","videoElement","camId","baseUrl","arguments","length","undefined","video","mediaSource","sourceBuffer","SEGMENT_SEC","TARGET_BUFFER","nextTs","isFetching","started","isSeeking","seekTargetTs","checkInterval","debugInterval","abortController","gapRetries","MAX_GAP_RETRIES","start","startEpochMs","console","log","concat","Date","toISOString","MediaSource","src","URL","createObjectURL","addEventListener","onSourceOpen","bind","clearInterval","setInterval","ensureBuffer","startDebugLogger","destroy","abort","pause","removeAttribute","load","readyState","addSourceBuffer","mode","e","warn","e2","error","updating","current","currentTime","bufferedEnd","getBufferedEnd","fetchAndAppend","ts","url","AbortController","res","fetch","signal","ok","status","skipGap","buf","arrayBuffer","appendBuffer","play","name","toLocaleTimeString","buffer","Promise","resolve","onUpdateEnd","removeEventListener","buffered","end","seekTo","epochMs","r","once","ranges","toFixed","remove","getCurrentEpochMs","bufferedDuration","playheadPos","timeBehindEnd","Math","max"],"sources":["I:/dispecerat/github_release/dss-edge/local-ui/src/services/PlaybackCoreV2.js"],"sourcesContent":["export default class PlaybackCoreV2 {\r\n    constructor(videoElement, camId, baseUrl = '/api') {\r\n        this.video = videoElement;\r\n        this.camId = camId;\r\n        this.baseUrl = baseUrl;\r\n\r\n        this.mediaSource = null;\r\n        this.sourceBuffer = null;\r\n\r\n        this.SEGMENT_SEC = 4;\r\n        this.TARGET_BUFFER = 20;\r\n\r\n        this.nextTs = null; // Epoch time of the NEXT segment to fetch\r\n        this.isFetching = false;\r\n        this.started = false;\r\n\r\n        this.isSeeking = false;\r\n        this.seekTargetTs = null;\r\n\r\n        this.checkInterval = null;\r\n        this.debugInterval = null;\r\n        this.abortController = null;\r\n\r\n        // GAP SKIP\r\n        this.gapRetries = 0;\r\n        this.MAX_GAP_RETRIES = 5000; // Increased to handle larger gaps (e.g. 5 hours) if necessary, but keep robust\r\n        // Actually user said \"5\". But 5 * 4s = 20s. If gap is 1 min, it will stop. \r\n        // User said: \"Caz 2 – Gap mare... se oprește după MAX_GAP_RETRIES\".\r\n        // Let's stick to user request: 5. \r\n        // Wait, if gap is large, user might WANT to skip it?\r\n        // \"sare segment cu segment... sare peste lipsă... redarea continuă\"\r\n        // If I set 5, it stops quickly. I will set 20 (80 sec) as a compromise or stick to 5 as requested for safety.\r\n        // Let's use 15.\r\n        this.MAX_GAP_RETRIES = 15;\r\n    }\r\n\r\n    start(startEpochMs) {\r\n        console.log(`[PlaybackCore] Starting at ${new Date(startEpochMs).toISOString()}`);\r\n        this.nextTs = startEpochMs;\r\n        this.isSeeking = false;\r\n        this.started = false;\r\n        this.gapRetries = 0;\r\n\r\n        this.mediaSource = new MediaSource();\r\n        this.video.src = URL.createObjectURL(this.mediaSource);\r\n\r\n        this.mediaSource.addEventListener('sourceopen', this.onSourceOpen.bind(this));\r\n\r\n        if (this.checkInterval) clearInterval(this.checkInterval);\r\n        this.checkInterval = setInterval(this.ensureBuffer.bind(this), 200);\r\n\r\n        this.startDebugLogger();\r\n    }\r\n\r\n    destroy() {\r\n        if (this.checkInterval) clearInterval(this.checkInterval);\r\n        if (this.debugInterval) clearInterval(this.debugInterval);\r\n        if (this.abortController) this.abortController.abort();\r\n\r\n        if (this.video) {\r\n            this.video.pause();\r\n            this.video.removeAttribute('src'); // Clean detach\r\n            this.video.load();\r\n        }\r\n\r\n        this.mediaSource = null;\r\n        this.sourceBuffer = null;\r\n    }\r\n\r\n    onSourceOpen() {\r\n        if (this.sourceBuffer || this.mediaSource.readyState !== 'open') return;\r\n\r\n        try {\r\n            // FIX 1: Codec Permisiv (High Profile Level 3.1)\r\n            this.sourceBuffer = this.mediaSource.addSourceBuffer('video/mp4; codecs=\"avc1.64001f\"');\r\n            this.sourceBuffer.mode = 'segments';\r\n        } catch (e) {\r\n            console.warn(\"[MSE] High Profile rejected, trying Main Profile...\", e);\r\n            try {\r\n                this.sourceBuffer = this.mediaSource.addSourceBuffer('video/mp4; codecs=\"avc1.4d401e\"');\r\n                this.sourceBuffer.mode = 'segments';\r\n            } catch (e2) {\r\n                console.error(\"[MSE] Fatal Codec Error:\", e2);\r\n            }\r\n        }\r\n    }\r\n\r\n    async ensureBuffer() {\r\n        if (this.isSeeking) return;\r\n        // PROTECTION 6\r\n        if (this.gapRetries > this.MAX_GAP_RETRIES) return;\r\n\r\n        if (!this.sourceBuffer || this.sourceBuffer.updating) return;\r\n        if (this.isFetching || this.nextTs === null) return;\r\n        if (this.mediaSource.readyState !== 'open') return;\r\n\r\n        const current = this.video.currentTime || 0;\r\n        const bufferedEnd = this.getBufferedEnd();\r\n\r\n        // If buffer is too small, fetch more\r\n        if (!this.started || bufferedEnd - current < this.TARGET_BUFFER) {\r\n            this.isFetching = true;\r\n            await this.fetchAndAppend(this.nextTs);\r\n            this.isFetching = false;\r\n        }\r\n    }\r\n\r\n    async fetchAndAppend(ts) {\r\n        if (this.isSeeking) return;\r\n\r\n        const url = `${this.baseUrl}/playback/segment/${this.camId}?ts=${ts}&dur=${this.SEGMENT_SEC}`;\r\n\r\n        try {\r\n            this.abortController = new AbortController();\r\n\r\n            const res = await fetch(url, { signal: this.abortController.signal });\r\n\r\n            if (!res.ok) {\r\n                if (res.status === 404) {\r\n                    await this.skipGap(); // FIX 4\r\n                }\r\n                return;\r\n            }\r\n\r\n            const buf = await res.arrayBuffer();\r\n            if (this.isSeeking) return; // Discard if seek happened\r\n\r\n            await this.appendBuffer(buf);\r\n\r\n            // FIX 5: RESET GAP COUNTER\r\n            this.gapRetries = 0;\r\n\r\n            if (!this.started && !this.isSeeking) {\r\n                // Try to play immediately after first segment\r\n                try {\r\n                    await this.video.play();\r\n                    this.started = true;\r\n                } catch (e) { }\r\n            }\r\n\r\n            // Advance strictly by duration\r\n            this.nextTs += (this.SEGMENT_SEC * 1000);\r\n\r\n        } catch (e) {\r\n            if (e.name !== 'AbortError') console.error(\"[MSE] Fetch Error:\", e);\r\n        } finally {\r\n            this.abortController = null;\r\n        }\r\n    }\r\n\r\n    // FIX 3: GAP SKIP LOGIC\r\n    async skipGap() {\r\n        this.gapRetries++;\r\n\r\n        if (this.gapRetries > this.MAX_GAP_RETRIES) {\r\n            console.warn('[GAP] too many gaps, stopping playback');\r\n            return;\r\n        }\r\n\r\n        // Skip current segment duration\r\n        console.warn(`[GAP] skipping to ${new Date(this.nextTs + (this.SEGMENT_SEC * 1000)).toLocaleTimeString()}`);\r\n        this.nextTs += (this.SEGMENT_SEC * 1000);\r\n    }\r\n\r\n    appendBuffer(buffer) {\r\n        return new Promise(resolve => {\r\n            if (!this.sourceBuffer || this.mediaSource.readyState !== 'open') return resolve();\r\n\r\n            const onUpdateEnd = () => {\r\n                this.sourceBuffer.removeEventListener('updateend', onUpdateEnd);\r\n                resolve();\r\n            };\r\n\r\n            this.sourceBuffer.addEventListener('updateend', onUpdateEnd);\r\n\r\n            try {\r\n                this.sourceBuffer.appendBuffer(buffer);\r\n            } catch (e) {\r\n                console.error(\"[MSE] Append Error:\", e);\r\n                this.sourceBuffer.removeEventListener('updateend', onUpdateEnd);\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    getBufferedEnd() {\r\n        if (!this.video || !this.video.buffered || this.video.buffered.length === 0) return 0;\r\n        return this.video.buffered.end(this.video.buffered.length - 1);\r\n    }\r\n\r\n    async seekTo(epochMs) {\r\n        if (!this.mediaSource || !this.sourceBuffer) return;\r\n\r\n        console.log('[MSE] SEEK TO', new Date(epochMs).toISOString());\r\n        this.isSeeking = true;\r\n        this.seekTargetTs = epochMs;\r\n\r\n        // RESET GAP COUNTER ON SEEK\r\n        this.gapRetries = 0;\r\n\r\n        if (this.abortController) {\r\n            this.abortController.abort();\r\n            this.abortController = null;\r\n        }\r\n        this.isFetching = false;\r\n\r\n        this.video.pause();\r\n\r\n        if (this.sourceBuffer.updating) {\r\n            await new Promise(r => this.sourceBuffer.addEventListener('updateend', r, { once: true }));\r\n        }\r\n\r\n        try {\r\n            const ranges = this.video.buffered;\r\n            if (ranges.length > 0) {\r\n                const start = ranges.start(0);\r\n                const end = ranges.end(ranges.length - 1);\r\n                console.log(`[MSE] Clearing Buffer: ${start.toFixed(2)} - ${end.toFixed(2)}`);\r\n                this.sourceBuffer.remove(start, end);\r\n                await new Promise(r => this.sourceBuffer.addEventListener('updateend', r, { once: true }));\r\n            }\r\n        } catch (e) {\r\n            console.warn(\"[MSE] Buffer flush warning:\", e);\r\n        }\r\n\r\n        this.video.currentTime = 0;\r\n        this.nextTs = epochMs;\r\n        this.started = false;\r\n\r\n        this.isSeeking = false;\r\n    }\r\n\r\n    getCurrentEpochMs() {\r\n        if (!this.started || !this.nextTs) return this.nextTs || 0;\r\n\r\n        const bufferedDuration = this.getBufferedEnd();\r\n        const playheadPos = this.video.currentTime;\r\n        const timeBehindEnd = Math.max(0, bufferedDuration - playheadPos);\r\n\r\n        return this.nextTs - (timeBehindEnd * 1000);\r\n    }\r\n\r\n    startDebugLogger() {\r\n        if (this.debugInterval) clearInterval(this.debugInterval);\r\n        this.debugInterval = setInterval(() => {\r\n            if (!this.video || !this.video.buffered || this.video.buffered.length === 0) return;\r\n            const current = this.video.currentTime;\r\n            const end = this.getBufferedEnd();\r\n            console.log(`[MSE] current: ${current.toFixed(1)} bufferedEnd: ${end.toFixed(1)} ahead: ${(end - current).toFixed(1)}`);\r\n        }, 2000);\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}