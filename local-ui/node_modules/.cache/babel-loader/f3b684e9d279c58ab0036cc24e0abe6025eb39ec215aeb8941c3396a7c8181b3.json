{"ast":null,"code":"import _objectSpread from\"I:/dispecerat/github_release/dss-edge/local-ui/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{useEffect,useRef,useState}from\"react\";/**\r\n * SMART DUAL STREAM MANAGER - Trassir-like with Smart Warm Standby\r\n * \r\n * ARCHITECTURE:\r\n * - Grid: substream only (low CPU)\r\n * - Hover: pre-connect main stream (warm standby)\r\n * - Fullscreen: instant switch (main already connected)\r\n * \r\n * CPU OPTIMIZATION:\r\n * - Only 1 main stream in warm standby at a time\r\n * - Grid idle: minimal overhead (25 substreams only)\r\n * - Switch: <200ms (connection already established)\r\n */import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const GO2RTC_API=\"\".concat(window.location.origin,\"/rtc\");const streamPool=new Map();/**\r\n * Acquire WebRTC stream (reuses existing connections)\r\n */async function acquireStream(camId){let type=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"sub\";const key=\"\".concat(camId,\"_\").concat(type);if(streamPool.has(key)){const entry=streamPool.get(key);entry.refs++;console.log(\"[SmartDual] Reusing \".concat(key,\", refs: \").concat(entry.refs));return entry;}console.log(\"[SmartDual] Creating WebRTC for \".concat(key));const pc=new RTCPeerConnection({iceServers:[]});const media=new MediaStream();pc.ontrack=e=>{console.log(\"[SmartDual] Track received for \".concat(key));media.addTrack(e.track);};pc.addTransceiver(\"video\",{direction:\"recvonly\"});try{const offer=await pc.createOffer();await pc.setLocalDescription(offer);const res=await fetch(\"\".concat(GO2RTC_API,\"/api/webrtc?src=\").concat(key),{method:\"POST\",headers:{\"Content-Type\":\"application/sdp\"},body:offer.sdp});if(!res.ok){throw new Error(\"WebRTC failed: \".concat(res.status));}const answer=await res.text();await pc.setRemoteDescription({type:\"answer\",sdp:answer});const entry={pc,media,refs:1};streamPool.set(key,entry);return entry;}catch(err){pc.close();throw err;}}/**\r\n * Release stream (with grace period)\r\n */function releaseStream(camId){let type=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"sub\";const key=\"\".concat(camId,\"_\").concat(type);const entry=streamPool.get(key);if(!entry)return;entry.refs--;console.log(\"[SmartDual] Released \".concat(key,\", refs: \").concat(entry.refs));if(entry.refs<=0){setTimeout(()=>{const currentEntry=streamPool.get(key);if(currentEntry&&currentEntry.refs<=0){console.log(\"[SmartDual] Closing idle \".concat(key));currentEntry.pc.close();streamPool.delete(key);}},5000);// 5s grace period (shorter for faster cleanup)\n}}/**\r\n * SMART DUAL STREAM PLAYER\r\n */export default function SmartDualStreamPlayer(_ref){let{camId,isFullscreen,isHidden,isHovered,style}=_ref;const videoRef=useRef(null);const[subStream,setSubStream]=useState(null);const[mainStream,setMainStream]=useState(null);const[currentStream,setCurrentStream]=useState(\"sub\");// Always acquire substream\nuseEffect(()=>{if(isHidden||!camId)return;let active=true;let subEntry;acquireStream(camId,\"sub\").then(sub=>{if(!active){releaseStream(camId,\"sub\");return;}subEntry=sub;setSubStream(sub);// Attach substream to video if not fullscreen\nif(videoRef.current&&!isFullscreen){videoRef.current.srcObject=sub.media;videoRef.current.play().catch(()=>{});}}).catch(err=>{console.error(\"[SmartDual] Error for sub \".concat(camId,\":\"),err);});return()=>{active=false;if(subEntry)releaseStream(camId,\"sub\");};},[camId,isHidden,isFullscreen]);// SMART WARM STANDBY with DEBOUNCE: Pre-connect main stream on sustained HOVER or FULLSCREEN\nuseEffect(()=>{let debounceTimer;let mainEntry;const cleanup=()=>{if(debounceTimer)clearTimeout(debounceTimer);if(mainEntry)releaseStream(camId,\"hd\");};// Immediate connection for fullscreen\nif(isFullscreen&&!isHidden&&camId){acquireStream(camId,\"hd\").then(main=>{mainEntry=main;setMainStream(main);if(videoRef.current){videoRef.current.srcObject=main.media;videoRef.current.play().catch(()=>{});setCurrentStream(\"main\");}}).catch(err=>console.error(\"[SmartDual] Error for main \".concat(camId,\":\"),err));}// Debounced connection for hover (800ms delay)\nelse if(isHovered&&!isHidden&&camId&&!isFullscreen){debounceTimer=setTimeout(()=>{console.log(\"[SmartDual] Hover sustained - pre-connecting main for \".concat(camId));acquireStream(camId,\"hd\").then(main=>{mainEntry=main;setMainStream(main);// Don't attach - warm standby only\n}).catch(err=>console.error(\"[SmartDual] Error for main \".concat(camId,\":\"),err));},800);}// Release main stream when not needed\nelse if(mainStream&&!isFullscreen&&!isHovered){releaseStream(camId,\"hd\");setMainStream(null);}return cleanup;},[isHovered,isFullscreen,camId,isHidden]);// INSTANT SWITCH when fullscreen changes\nuseEffect(()=>{if(!videoRef.current)return;if(isFullscreen&&mainStream){// Switch to main\nconsole.log(\"[SmartDual] Switching to MAIN for \".concat(camId));videoRef.current.srcObject=mainStream.media;videoRef.current.play().catch(()=>{});setCurrentStream(\"main\");}else if(!isFullscreen&&subStream){// Switch back to sub\nconsole.log(\"[SmartDual] Switching to SUB for \".concat(camId));videoRef.current.srcObject=subStream.media;videoRef.current.play().catch(()=>{});setCurrentStream(\"sub\");}},[isFullscreen,subStream,mainStream,camId]);return/*#__PURE__*/_jsxs(\"div\",{style:_objectSpread(_objectSpread({},style),{},{position:\"relative\",background:\"#000\",width:\"100%\",height:\"100%\"}),children:[/*#__PURE__*/_jsx(\"video\",{ref:videoRef,autoPlay:true,muted:true,playsInline:true,style:{width:\"100%\",height:\"100%\",objectFit:\"fill\"}}),process.env.NODE_ENV==='development'&&/*#__PURE__*/_jsxs(\"div\",{style:{position:\"absolute\",top:4,right:4,background:\"rgba(0,0,0,0.7)\",color:mainStream?\"#0f0\":\"#ff0\",padding:\"2px 6px\",fontSize:10,fontFamily:\"monospace\"},children:[currentStream.toUpperCase(),\" \",mainStream&&!isFullscreen?\"(STANDBY)\":\"\"]})]});}","map":{"version":3,"names":["React","useEffect","useRef","useState","jsx","_jsx","jsxs","_jsxs","GO2RTC_API","concat","window","location","origin","streamPool","Map","acquireStream","camId","type","arguments","length","undefined","key","has","entry","get","refs","console","log","pc","RTCPeerConnection","iceServers","media","MediaStream","ontrack","e","addTrack","track","addTransceiver","direction","offer","createOffer","setLocalDescription","res","fetch","method","headers","body","sdp","ok","Error","status","answer","text","setRemoteDescription","set","err","close","releaseStream","setTimeout","currentEntry","delete","SmartDualStreamPlayer","_ref","isFullscreen","isHidden","isHovered","style","videoRef","subStream","setSubStream","mainStream","setMainStream","currentStream","setCurrentStream","active","subEntry","then","sub","current","srcObject","play","catch","error","debounceTimer","mainEntry","cleanup","clearTimeout","main","_objectSpread","position","background","width","height","children","ref","autoPlay","muted","playsInline","objectFit","process","env","NODE_ENV","top","right","color","padding","fontSize","fontFamily","toUpperCase"],"sources":["I:/dispecerat/github_release/dss-edge/local-ui/src/components/DualStreamPlayer.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\r\n\r\n/**\r\n * SMART DUAL STREAM MANAGER - Trassir-like with Smart Warm Standby\r\n * \r\n * ARCHITECTURE:\r\n * - Grid: substream only (low CPU)\r\n * - Hover: pre-connect main stream (warm standby)\r\n * - Fullscreen: instant switch (main already connected)\r\n * \r\n * CPU OPTIMIZATION:\r\n * - Only 1 main stream in warm standby at a time\r\n * - Grid idle: minimal overhead (25 substreams only)\r\n * - Switch: <200ms (connection already established)\r\n */\r\n\r\nconst GO2RTC_API = `${window.location.origin}/rtc`;\r\nconst streamPool = new Map();\r\n\r\n/**\r\n * Acquire WebRTC stream (reuses existing connections)\r\n */\r\nasync function acquireStream(camId, type = \"sub\") {\r\n    const key = `${camId}_${type}`;\r\n\r\n    if (streamPool.has(key)) {\r\n        const entry = streamPool.get(key);\r\n        entry.refs++;\r\n        console.log(`[SmartDual] Reusing ${key}, refs: ${entry.refs}`);\r\n        return entry;\r\n    }\r\n\r\n    console.log(`[SmartDual] Creating WebRTC for ${key}`);\r\n    const pc = new RTCPeerConnection({ iceServers: [] });\r\n    const media = new MediaStream();\r\n\r\n    pc.ontrack = (e) => {\r\n        console.log(`[SmartDual] Track received for ${key}`);\r\n        media.addTrack(e.track);\r\n    };\r\n\r\n    pc.addTransceiver(\"video\", { direction: \"recvonly\" });\r\n\r\n    try {\r\n        const offer = await pc.createOffer();\r\n        await pc.setLocalDescription(offer);\r\n\r\n        const res = await fetch(`${GO2RTC_API}/api/webrtc?src=${key}`, {\r\n            method: \"POST\",\r\n            headers: { \"Content-Type\": \"application/sdp\" },\r\n            body: offer.sdp\r\n        });\r\n\r\n        if (!res.ok) {\r\n            throw new Error(`WebRTC failed: ${res.status}`);\r\n        }\r\n\r\n        const answer = await res.text();\r\n        await pc.setRemoteDescription({ type: \"answer\", sdp: answer });\r\n\r\n        const entry = { pc, media, refs: 1 };\r\n        streamPool.set(key, entry);\r\n        return entry;\r\n    } catch (err) {\r\n        pc.close();\r\n        throw err;\r\n    }\r\n}\r\n\r\n/**\r\n * Release stream (with grace period)\r\n */\r\nfunction releaseStream(camId, type = \"sub\") {\r\n    const key = `${camId}_${type}`;\r\n    const entry = streamPool.get(key);\r\n    if (!entry) return;\r\n\r\n    entry.refs--;\r\n    console.log(`[SmartDual] Released ${key}, refs: ${entry.refs}`);\r\n\r\n    if (entry.refs <= 0) {\r\n        setTimeout(() => {\r\n            const currentEntry = streamPool.get(key);\r\n            if (currentEntry && currentEntry.refs <= 0) {\r\n                console.log(`[SmartDual] Closing idle ${key}`);\r\n                currentEntry.pc.close();\r\n                streamPool.delete(key);\r\n            }\r\n        }, 5000); // 5s grace period (shorter for faster cleanup)\r\n    }\r\n}\r\n\r\n/**\r\n * SMART DUAL STREAM PLAYER\r\n */\r\nexport default function SmartDualStreamPlayer({ camId, isFullscreen, isHidden, isHovered, style }) {\r\n    const videoRef = useRef(null);\r\n    const [subStream, setSubStream] = useState(null);\r\n    const [mainStream, setMainStream] = useState(null);\r\n    const [currentStream, setCurrentStream] = useState(\"sub\");\r\n\r\n    // Always acquire substream\r\n    useEffect(() => {\r\n        if (isHidden || !camId) return;\r\n\r\n        let active = true;\r\n        let subEntry;\r\n\r\n        acquireStream(camId, \"sub\")\r\n            .then((sub) => {\r\n                if (!active) {\r\n                    releaseStream(camId, \"sub\");\r\n                    return;\r\n                }\r\n                subEntry = sub;\r\n                setSubStream(sub);\r\n\r\n                // Attach substream to video if not fullscreen\r\n                if (videoRef.current && !isFullscreen) {\r\n                    videoRef.current.srcObject = sub.media;\r\n                    videoRef.current.play().catch(() => { });\r\n                }\r\n            })\r\n            .catch((err) => {\r\n                console.error(`[SmartDual] Error for sub ${camId}:`, err);\r\n            });\r\n\r\n        return () => {\r\n            active = false;\r\n            if (subEntry) releaseStream(camId, \"sub\");\r\n        };\r\n    }, [camId, isHidden, isFullscreen]);\r\n\r\n    // SMART WARM STANDBY with DEBOUNCE: Pre-connect main stream on sustained HOVER or FULLSCREEN\r\n    useEffect(() => {\r\n        let debounceTimer;\r\n        let mainEntry;\r\n\r\n        const cleanup = () => {\r\n            if (debounceTimer) clearTimeout(debounceTimer);\r\n            if (mainEntry) releaseStream(camId, \"hd\");\r\n        };\r\n\r\n        // Immediate connection for fullscreen\r\n        if (isFullscreen && !isHidden && camId) {\r\n            acquireStream(camId, \"hd\")\r\n                .then((main) => {\r\n                    mainEntry = main;\r\n                    setMainStream(main);\r\n                    if (videoRef.current) {\r\n                        videoRef.current.srcObject = main.media;\r\n                        videoRef.current.play().catch(() => { });\r\n                        setCurrentStream(\"main\");\r\n                    }\r\n                })\r\n                .catch((err) => console.error(`[SmartDual] Error for main ${camId}:`, err));\r\n        }\r\n        // Debounced connection for hover (800ms delay)\r\n        else if (isHovered && !isHidden && camId && !isFullscreen) {\r\n            debounceTimer = setTimeout(() => {\r\n                console.log(`[SmartDual] Hover sustained - pre-connecting main for ${camId}`);\r\n                acquireStream(camId, \"hd\")\r\n                    .then((main) => {\r\n                        mainEntry = main;\r\n                        setMainStream(main);\r\n                        // Don't attach - warm standby only\r\n                    })\r\n                    .catch((err) => console.error(`[SmartDual] Error for main ${camId}:`, err));\r\n            }, 800);\r\n        }\r\n        // Release main stream when not needed\r\n        else if (mainStream && !isFullscreen && !isHovered) {\r\n            releaseStream(camId, \"hd\");\r\n            setMainStream(null);\r\n        }\r\n\r\n        return cleanup;\r\n    }, [isHovered, isFullscreen, camId, isHidden]);\r\n\r\n    // INSTANT SWITCH when fullscreen changes\r\n    useEffect(() => {\r\n        if (!videoRef.current) return;\r\n\r\n        if (isFullscreen && mainStream) {\r\n            // Switch to main\r\n            console.log(`[SmartDual] Switching to MAIN for ${camId}`);\r\n            videoRef.current.srcObject = mainStream.media;\r\n            videoRef.current.play().catch(() => { });\r\n            setCurrentStream(\"main\");\r\n        } else if (!isFullscreen && subStream) {\r\n            // Switch back to sub\r\n            console.log(`[SmartDual] Switching to SUB for ${camId}`);\r\n            videoRef.current.srcObject = subStream.media;\r\n            videoRef.current.play().catch(() => { });\r\n            setCurrentStream(\"sub\");\r\n        }\r\n    }, [isFullscreen, subStream, mainStream, camId]);\r\n\r\n    return (\r\n        <div style={{ ...style, position: \"relative\", background: \"#000\", width: \"100%\", height: \"100%\" }}>\r\n            <video\r\n                ref={videoRef}\r\n                autoPlay\r\n                muted\r\n                playsInline\r\n                style={{\r\n                    width: \"100%\",\r\n                    height: \"100%\",\r\n                    objectFit: \"fill\"\r\n                }}\r\n            />\r\n            {/* Debug indicator */}\r\n            {process.env.NODE_ENV === 'development' && (\r\n                <div style={{\r\n                    position: \"absolute\",\r\n                    top: 4,\r\n                    right: 4,\r\n                    background: \"rgba(0,0,0,0.7)\",\r\n                    color: mainStream ? \"#0f0\" : \"#ff0\",\r\n                    padding: \"2px 6px\",\r\n                    fontSize: 10,\r\n                    fontFamily: \"monospace\"\r\n                }}>\r\n                    {currentStream.toUpperCase()} {mainStream && !isFullscreen ? \"(STANDBY)\" : \"\"}\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}