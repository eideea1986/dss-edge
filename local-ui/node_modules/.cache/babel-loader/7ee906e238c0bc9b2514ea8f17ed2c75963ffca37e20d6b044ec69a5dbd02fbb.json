{"ast":null,"code":"export default class PlaybackCoreV2{constructor(videoElement,camId){let baseUrl=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'/api';this.video=videoElement;this.camId=camId;this.baseUrl=baseUrl;this.mediaSource=null;this.sourceBuffer=null;this.SEGMENT_SEC=6;// CORE STATE\nthis.nextFetchTs=null;// Next TS the Producer looks for\nthis.segments=[];// Map\nthis.timeMap=[];// Clock Sync\n// BUFFERS\nthis.chunkQueue=[];// RAM Buffer (Producer -> Consumer)\nthis.MAX_QUEUE_SIZE=5;// Lookahead 5 * 6s = 30s in RAM\n// FLAGS\nthis.isPlaying=false;this.isDestroyed=false;this.abortController=null;this.stallInterval=null;}setSegments(segments){this.segments=(segments||[]).map(s=>({start_ts:Number(s.start_ts),end_ts:s.end_ts===0?Date.now():Number(s.end_ts)})).sort((a,b)=>a.start_ts-b.start_ts);console.log(\"[MSE] Map Updated: \".concat(this.segments.length,\" segments.\"));}start(startEpochMs){console.log(\"[PlaybackStart] Req: \".concat(new Date(startEpochMs).toLocaleTimeString()));this.destroy();// Clean old\nthis.isDestroyed=false;// 1. Calculate Start\nconst validStart=this.getNextPlayableTs(startEpochMs-1000);// Snap to valid\nthis.nextFetchTs=validStart||startEpochMs;// 2. Setup MSE\nthis.mediaSource=new MediaSource();this.video.src=URL.createObjectURL(this.mediaSource);this.video.playbackRate=1.0;this.mediaSource.addEventListener('sourceopen',this.onSourceOpen.bind(this));// 3. Start Loops\nthis.stallInterval=setInterval(this.monitorStall.bind(this),500);// 4. Start Pipeline\nthis.producerLoop();this.consumerLoop();}destroy(){this.isDestroyed=true;this.isPlaying=false;if(this.stallInterval)clearInterval(this.stallInterval);if(this.abortController)this.abortController.abort();if(this.video){this.video.pause();this.video.removeAttribute('src');this.video.load();}this.mediaSource=null;this.sourceBuffer=null;this.chunkQueue=[];this.timeMap=[];}onSourceOpen(){if(this.sourceBuffer||this.mediaSource.readyState!=='open')return;const codecs=['video/mp4; codecs=\"avc1.4d401e\"','video/mp4; codecs=\"avc1.64001f\"'];for(const codec of codecs){if(MediaSource.isTypeSupported(codec)){try{this.sourceBuffer=this.mediaSource.addSourceBuffer(codec);this.sourceBuffer.mode='segments';return;}catch(e){}}}}// --- PRODUCER (NETWORK) ---\nasync producerLoop(){while(!this.isDestroyed){// Flow Control: Don't overfill RAM\nif(this.chunkQueue.length>=this.MAX_QUEUE_SIZE){await this.sleep(200);continue;}if(!this.nextFetchTs){await this.sleep(200);continue;}// Fetch Next\nconst ts=this.nextFetchTs;const chunk=await this.downloadSegment(ts);if(this.isDestroyed)return;if(chunk){// Determine next TS based on Map (Jump Gaps)\nthis.nextFetchTs=this.getNextPlayableTs(ts);// Push to Queue (Consumer will eat this)\nthis.chunkQueue.push({data:chunk,ts:ts});}else{// Failed download (404/Error)\nthis.nextFetchTs=this.getNextPlayableTs(ts);}}}async downloadSegment(ts){const url=\"\".concat(this.baseUrl,\"/playback/segment/\").concat(this.camId,\"?ts=\").concat(ts,\"&dur=\").concat(this.SEGMENT_SEC);try{this.abortController=new AbortController();const tm=setTimeout(()=>this.abortController.abort(),10000);// 10s wait allowed\nconst res=await fetch(url,{signal:this.abortController.signal});clearTimeout(tm);if(!res.ok){if(res.status===404){console.warn(\"[Producer] 404 at \".concat(ts,\". Cleaning Map.\"));this.removeFromMap(ts);}return null;}return await res.arrayBuffer();}catch(e){// console.error(`[Producer] Err:`, e);\nreturn null;}finally{this.abortController=null;}}// --- CONSUMER (MSE) ---\nasync consumerLoop(){while(!this.isDestroyed){if(!this.sourceBuffer||this.sourceBuffer.updating||this.chunkQueue.length===0){await this.sleep(50);continue;}const item=this.chunkQueue.shift();// Get oldest\ntry{// Record Time Map used for clock\nconst startBuf=this.getBufferedEnd();this.timeMap.push({v:startBuf,t:item.ts});this.timeMap=this.timeMap.slice(-50);await this.appendBuffer(item.data);// Auto Play Trigger\nif(!this.isPlaying&&this.video.paused){const buffLen=this.getBufferedEnd()-this.video.currentTime;if(buffLen>0.5){// Needs minimal buffer\ntry{if(this.video.buffered.length>0){const start=this.video.buffered.start(0);if(this.video.currentTime<start)this.video.currentTime=start+0.05;}await this.video.play();this.isPlaying=true;}catch(e){}}}}catch(e){console.warn(\"[Consumer] Append Warn (Quota?)\",e);// IF quota ex, flush old\nif(this.video.currentTime>30){try{this.sourceBuffer.remove(0,this.video.currentTime-10);}catch(err){}}}}}appendBuffer(buffer){return new Promise(resolve=>{if(!this.sourceBuffer)return resolve();const onEnd=()=>{this.sourceBuffer.removeEventListener('updateend',onEnd);resolve();};this.sourceBuffer.addEventListener('updateend',onEnd);try{this.sourceBuffer.appendBuffer(buffer);}catch(e){this.sourceBuffer.removeEventListener('updateend',onEnd);resolve();}});}// --- UTILS ---\nmonitorStall(){if(!this.video||this.video.paused)return;const ct=this.video.currentTime;const buffered=this.video.buffered;let jumpTo=null;for(let i=0;i<buffered.length;i++){const end=buffered.end(i);// If near end of range\nif(ct>end-0.5&&ct<end+0.5){if(i+1<buffered.length){jumpTo=buffered.start(i+1)+0.1;}}}if(jumpTo){console.warn(\"[Stall] Jumping \".concat(ct.toFixed(1),\" -> \").concat(jumpTo.toFixed(1)));this.video.currentTime=jumpTo;}}getNextPlayableTs(currentTs){// Find next 6s block\nconst target=currentTs+this.SEGMENT_SEC*1000;// Check Map\nif(this.segments.length>0){const valid=this.segments.find(s=>target>=s.start_ts&&target<s.end_ts);if(valid)return target;// Seek next segment\nconst next=this.segments.find(s=>s.start_ts>currentTs);return next?next.start_ts:null;}else{return target;// Fallback blind\n}}removeFromMap(ts){if(this.segments.length===0)return;const idx=this.segments.findIndex(s=>ts>=s.start_ts&&ts<s.end_ts);if(idx!==-1){this.segments.splice(idx,1);// Also notify UI? No need, local fix.\n}}getBufferedEnd(){if(!this.video||!this.video.buffered||this.video.buffered.length===0)return 0;return this.video.buffered.end(this.video.buffered.length-1);}getCurrentEpochMs(){if(!this.nextFetchTs&&this.chunkQueue.length===0)return 0;const ct=this.video.currentTime;for(let i=this.timeMap.length-1;i>=0;i--){const m=this.timeMap[i];if(ct>=m.v)return m.t+(ct-m.v)*1000;}return this.nextFetchTs||0;}sleep(ms){return new Promise(r=>setTimeout(r,ms));}async seekTo(ts){console.log('[Seek] ',new Date(ts).toLocaleTimeString());this.chunkQueue=[];// Clear RAM\nthis.isDestroyed=true;// Pause loops momentarily\nawait this.sleep(50);// let them stop\nthis.isDestroyed=false;// Resume\nthis.nextFetchTs=this.getNextPlayableTs(ts-1000)||ts;if(this.abortController)this.abortController.abort();// Flush MSE\nif(this.sourceBuffer&&!this.sourceBuffer.updating&&this.mediaSource.readyState==='open'){try{const ranges=this.video.buffered;if(ranges.length){this.sourceBuffer.remove(ranges.start(0),ranges.end(ranges.length-1));await new Promise(r=>this.sourceBuffer.addEventListener('updateend',r,{once:true}));}}catch(e){}}this.video.currentTime=0;this.isPlaying=false;this.timeMap=[];// Restart Loops\nthis.producerLoop();this.consumerLoop();}}","map":{"version":3,"names":["PlaybackCoreV2","constructor","videoElement","camId","baseUrl","arguments","length","undefined","video","mediaSource","sourceBuffer","SEGMENT_SEC","nextFetchTs","segments","timeMap","chunkQueue","MAX_QUEUE_SIZE","isPlaying","isDestroyed","abortController","stallInterval","setSegments","map","s","start_ts","Number","end_ts","Date","now","sort","a","b","console","log","concat","start","startEpochMs","toLocaleTimeString","destroy","validStart","getNextPlayableTs","MediaSource","src","URL","createObjectURL","playbackRate","addEventListener","onSourceOpen","bind","setInterval","monitorStall","producerLoop","consumerLoop","clearInterval","abort","pause","removeAttribute","load","readyState","codecs","codec","isTypeSupported","addSourceBuffer","mode","e","sleep","ts","chunk","downloadSegment","push","data","url","AbortController","tm","setTimeout","res","fetch","signal","clearTimeout","ok","status","warn","removeFromMap","arrayBuffer","updating","item","shift","startBuf","getBufferedEnd","v","t","slice","appendBuffer","paused","buffLen","currentTime","buffered","play","remove","err","buffer","Promise","resolve","onEnd","removeEventListener","ct","jumpTo","i","end","toFixed","currentTs","target","valid","find","next","idx","findIndex","splice","getCurrentEpochMs","m","ms","r","seekTo","ranges","once"],"sources":["I:/dispecerat/github_release/dss-edge/local-ui/src/services/PlaybackCoreV2.js"],"sourcesContent":["export default class PlaybackCoreV2 {\r\n    constructor(videoElement, camId, baseUrl = '/api') {\r\n        this.video = videoElement;\r\n        this.camId = camId;\r\n        this.baseUrl = baseUrl;\r\n\r\n        this.mediaSource = null;\r\n        this.sourceBuffer = null;\r\n\r\n        this.SEGMENT_SEC = 6;\r\n\r\n        // CORE STATE\r\n        this.nextFetchTs = null; // Next TS the Producer looks for\r\n        this.segments = []; // Map\r\n        this.timeMap = []; // Clock Sync\r\n\r\n        // BUFFERS\r\n        this.chunkQueue = []; // RAM Buffer (Producer -> Consumer)\r\n        this.MAX_QUEUE_SIZE = 5; // Lookahead 5 * 6s = 30s in RAM\r\n\r\n        // FLAGS\r\n        this.isPlaying = false;\r\n        this.isDestroyed = false;\r\n\r\n        this.abortController = null;\r\n        this.stallInterval = null;\r\n    }\r\n\r\n    setSegments(segments) {\r\n        this.segments = (segments || []).map(s => ({\r\n            start_ts: Number(s.start_ts),\r\n            end_ts: s.end_ts === 0 ? Date.now() : Number(s.end_ts)\r\n        })).sort((a, b) => a.start_ts - b.start_ts);\r\n        console.log(`[MSE] Map Updated: ${this.segments.length} segments.`);\r\n    }\r\n\r\n    start(startEpochMs) {\r\n        console.log(`[PlaybackStart] Req: ${new Date(startEpochMs).toLocaleTimeString()}`);\r\n        this.destroy(); // Clean old\r\n        this.isDestroyed = false;\r\n\r\n        // 1. Calculate Start\r\n        const validStart = this.getNextPlayableTs(startEpochMs - 1000); // Snap to valid\r\n        this.nextFetchTs = validStart || startEpochMs;\r\n\r\n        // 2. Setup MSE\r\n        this.mediaSource = new MediaSource();\r\n        this.video.src = URL.createObjectURL(this.mediaSource);\r\n        this.video.playbackRate = 1.0;\r\n        this.mediaSource.addEventListener('sourceopen', this.onSourceOpen.bind(this));\r\n\r\n        // 3. Start Loops\r\n        this.stallInterval = setInterval(this.monitorStall.bind(this), 500);\r\n\r\n        // 4. Start Pipeline\r\n        this.producerLoop();\r\n        this.consumerLoop();\r\n    }\r\n\r\n    destroy() {\r\n        this.isDestroyed = true;\r\n        this.isPlaying = false;\r\n        if (this.stallInterval) clearInterval(this.stallInterval);\r\n        if (this.abortController) this.abortController.abort();\r\n        if (this.video) {\r\n            this.video.pause();\r\n            this.video.removeAttribute('src');\r\n            this.video.load();\r\n        }\r\n        this.mediaSource = null;\r\n        this.sourceBuffer = null;\r\n        this.chunkQueue = [];\r\n        this.timeMap = [];\r\n    }\r\n\r\n    onSourceOpen() {\r\n        if (this.sourceBuffer || this.mediaSource.readyState !== 'open') return;\r\n        const codecs = ['video/mp4; codecs=\"avc1.4d401e\"', 'video/mp4; codecs=\"avc1.64001f\"'];\r\n        for (const codec of codecs) {\r\n            if (MediaSource.isTypeSupported(codec)) {\r\n                try {\r\n                    this.sourceBuffer = this.mediaSource.addSourceBuffer(codec);\r\n                    this.sourceBuffer.mode = 'segments';\r\n                    return;\r\n                } catch (e) { }\r\n            }\r\n        }\r\n    }\r\n\r\n    // --- PRODUCER (NETWORK) ---\r\n    async producerLoop() {\r\n        while (!this.isDestroyed) {\r\n            // Flow Control: Don't overfill RAM\r\n            if (this.chunkQueue.length >= this.MAX_QUEUE_SIZE) {\r\n                await this.sleep(200);\r\n                continue;\r\n            }\r\n\r\n            if (!this.nextFetchTs) {\r\n                await this.sleep(200);\r\n                continue;\r\n            }\r\n\r\n            // Fetch Next\r\n            const ts = this.nextFetchTs;\r\n            const chunk = await this.downloadSegment(ts);\r\n\r\n            if (this.isDestroyed) return;\r\n\r\n            if (chunk) {\r\n                // Determine next TS based on Map (Jump Gaps)\r\n                this.nextFetchTs = this.getNextPlayableTs(ts);\r\n\r\n                // Push to Queue (Consumer will eat this)\r\n                this.chunkQueue.push({\r\n                    data: chunk,\r\n                    ts: ts\r\n                });\r\n            } else {\r\n                // Failed download (404/Error)\r\n                this.nextFetchTs = this.getNextPlayableTs(ts);\r\n            }\r\n        }\r\n    }\r\n\r\n    async downloadSegment(ts) {\r\n        const url = `${this.baseUrl}/playback/segment/${this.camId}?ts=${ts}&dur=${this.SEGMENT_SEC}`;\r\n        try {\r\n            this.abortController = new AbortController();\r\n            const tm = setTimeout(() => this.abortController.abort(), 10000); // 10s wait allowed\r\n            const res = await fetch(url, { signal: this.abortController.signal });\r\n            clearTimeout(tm);\r\n\r\n            if (!res.ok) {\r\n                if (res.status === 404) {\r\n                    console.warn(`[Producer] 404 at ${ts}. Cleaning Map.`);\r\n                    this.removeFromMap(ts);\r\n                }\r\n                return null;\r\n            }\r\n            return await res.arrayBuffer();\r\n        } catch (e) {\r\n            // console.error(`[Producer] Err:`, e);\r\n            return null;\r\n        } finally {\r\n            this.abortController = null;\r\n        }\r\n    }\r\n\r\n    // --- CONSUMER (MSE) ---\r\n    async consumerLoop() {\r\n        while (!this.isDestroyed) {\r\n            if (!this.sourceBuffer || this.sourceBuffer.updating || this.chunkQueue.length === 0) {\r\n                await this.sleep(50);\r\n                continue;\r\n            }\r\n\r\n            const item = this.chunkQueue.shift(); // Get oldest\r\n\r\n            try {\r\n                // Record Time Map used for clock\r\n                const startBuf = this.getBufferedEnd();\r\n                this.timeMap.push({ v: startBuf, t: item.ts });\r\n                this.timeMap = this.timeMap.slice(-50);\r\n\r\n                await this.appendBuffer(item.data);\r\n\r\n                // Auto Play Trigger\r\n                if (!this.isPlaying && this.video.paused) {\r\n                    const buffLen = this.getBufferedEnd() - this.video.currentTime;\r\n                    if (buffLen > 0.5) { // Needs minimal buffer\r\n                        try {\r\n                            if (this.video.buffered.length > 0) {\r\n                                const start = this.video.buffered.start(0);\r\n                                if (this.video.currentTime < start) this.video.currentTime = start + 0.05;\r\n                            }\r\n                            await this.video.play();\r\n                            this.isPlaying = true;\r\n                        } catch (e) { }\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                console.warn(\"[Consumer] Append Warn (Quota?)\", e);\r\n                // IF quota ex, flush old\r\n                if (this.video.currentTime > 30) {\r\n                    try { this.sourceBuffer.remove(0, this.video.currentTime - 10); } catch (err) { }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    appendBuffer(buffer) {\r\n        return new Promise(resolve => {\r\n            if (!this.sourceBuffer) return resolve();\r\n            const onEnd = () => {\r\n                this.sourceBuffer.removeEventListener('updateend', onEnd);\r\n                resolve();\r\n            };\r\n            this.sourceBuffer.addEventListener('updateend', onEnd);\r\n            try { this.sourceBuffer.appendBuffer(buffer); } catch (e) {\r\n                this.sourceBuffer.removeEventListener('updateend', onEnd);\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    // --- UTILS ---\r\n    monitorStall() {\r\n        if (!this.video || this.video.paused) return;\r\n        const ct = this.video.currentTime;\r\n        const buffered = this.video.buffered;\r\n\r\n        let jumpTo = null;\r\n        for (let i = 0; i < buffered.length; i++) {\r\n            const end = buffered.end(i);\r\n            // If near end of range\r\n            if (ct > end - 0.5 && ct < end + 0.5) {\r\n                if (i + 1 < buffered.length) {\r\n                    jumpTo = buffered.start(i + 1) + 0.1;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (jumpTo) {\r\n            console.warn(`[Stall] Jumping ${ct.toFixed(1)} -> ${jumpTo.toFixed(1)}`);\r\n            this.video.currentTime = jumpTo;\r\n        }\r\n    }\r\n\r\n    getNextPlayableTs(currentTs) {\r\n        // Find next 6s block\r\n        const target = currentTs + (this.SEGMENT_SEC * 1000);\r\n        // Check Map\r\n        if (this.segments.length > 0) {\r\n            const valid = this.segments.find(s => target >= s.start_ts && target < s.end_ts);\r\n            if (valid) return target;\r\n\r\n            // Seek next segment\r\n            const next = this.segments.find(s => s.start_ts > currentTs);\r\n            return next ? next.start_ts : null;\r\n        } else {\r\n            return target; // Fallback blind\r\n        }\r\n    }\r\n\r\n    removeFromMap(ts) {\r\n        if (this.segments.length === 0) return;\r\n        const idx = this.segments.findIndex(s => ts >= s.start_ts && ts < s.end_ts);\r\n        if (idx !== -1) {\r\n            this.segments.splice(idx, 1);\r\n            // Also notify UI? No need, local fix.\r\n        }\r\n    }\r\n\r\n    getBufferedEnd() {\r\n        if (!this.video || !this.video.buffered || this.video.buffered.length === 0) return 0;\r\n        return this.video.buffered.end(this.video.buffered.length - 1);\r\n    }\r\n\r\n    getCurrentEpochMs() {\r\n        if (!this.nextFetchTs && this.chunkQueue.length === 0) return 0;\r\n        const ct = this.video.currentTime;\r\n        for (let i = this.timeMap.length - 1; i >= 0; i--) {\r\n            const m = this.timeMap[i];\r\n            if (ct >= m.v) return m.t + ((ct - m.v) * 1000);\r\n        }\r\n        return this.nextFetchTs || 0;\r\n    }\r\n\r\n    sleep(ms) { return new Promise(r => setTimeout(r, ms)); }\r\n\r\n    async seekTo(ts) {\r\n        console.log('[Seek] ', new Date(ts).toLocaleTimeString());\r\n        this.chunkQueue = []; // Clear RAM\r\n\r\n        this.isDestroyed = true; // Pause loops momentarily\r\n        await this.sleep(50); // let them stop\r\n        this.isDestroyed = false; // Resume\r\n\r\n        this.nextFetchTs = this.getNextPlayableTs(ts - 1000) || ts;\r\n\r\n        if (this.abortController) this.abortController.abort();\r\n\r\n        // Flush MSE\r\n        if (this.sourceBuffer && !this.sourceBuffer.updating && this.mediaSource.readyState === 'open') {\r\n            try {\r\n                const ranges = this.video.buffered;\r\n                if (ranges.length) {\r\n                    this.sourceBuffer.remove(ranges.start(0), ranges.end(ranges.length - 1));\r\n                    await new Promise(r => this.sourceBuffer.addEventListener('updateend', r, { once: true }));\r\n                }\r\n            } catch (e) { }\r\n        }\r\n\r\n        this.video.currentTime = 0;\r\n        this.isPlaying = false;\r\n        this.timeMap = [];\r\n\r\n        // Restart Loops\r\n        this.producerLoop();\r\n        this.consumerLoop();\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}