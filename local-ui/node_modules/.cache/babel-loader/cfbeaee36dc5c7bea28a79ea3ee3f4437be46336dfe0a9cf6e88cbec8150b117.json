{"ast":null,"code":"var _jsxFileName = \"I:\\\\dispecerat\\\\github_release\\\\dss-edge\\\\local-ui\\\\src\\\\components\\\\DualStreamPlayer.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from \"react\";\n\n/**\r\n * SMART DUAL STREAM MANAGER - Trassir-like with Smart Warm Standby\r\n * \r\n * ARCHITECTURE:\r\n * - Grid: substream only (low CPU)\r\n * - Hover: pre-connect main stream (warm standby)\r\n * - Fullscreen: instant switch (main already connected)\r\n * \r\n * CPU OPTIMIZATION:\r\n * - Only 1 main stream in warm standby at a time\r\n * - Grid idle: minimal overhead (25 substreams only)\r\n * - Switch: <200ms (connection already established)\r\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst GO2RTC_API = `${window.location.origin}/rtc`;\nconst streamPool = new Map();\n\n/**\r\n * Acquire WebRTC stream (reuses existing connections)\r\n */\nasync function acquireStream(camId, type = \"sub\") {\n  const key = `${camId}_${type}`;\n  if (streamPool.has(key)) {\n    const entry = streamPool.get(key);\n    entry.refs++;\n    console.log(`[SmartDual] Reusing ${key}, refs: ${entry.refs}`);\n    return entry;\n  }\n  console.log(`[SmartDual] Creating WebRTC for ${key}`);\n  const pc = new RTCPeerConnection({\n    iceServers: []\n  });\n  const media = new MediaStream();\n  pc.ontrack = e => {\n    console.log(`[SmartDual] Track received for ${key}`);\n    media.addTrack(e.track);\n  };\n  pc.addTransceiver(\"video\", {\n    direction: \"recvonly\"\n  });\n  try {\n    const offer = await pc.createOffer();\n    await pc.setLocalDescription(offer);\n    const res = await fetch(`${GO2RTC_API}/api/webrtc?src=${key}`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/sdp\"\n      },\n      body: offer.sdp\n    });\n    if (!res.ok) {\n      throw new Error(`WebRTC failed: ${res.status}`);\n    }\n    const answer = await res.text();\n    await pc.setRemoteDescription({\n      type: \"answer\",\n      sdp: answer\n    });\n    const entry = {\n      pc,\n      media,\n      refs: 1\n    };\n    streamPool.set(key, entry);\n    return entry;\n  } catch (err) {\n    pc.close();\n    throw err;\n  }\n}\n\n/**\r\n * Release stream (with grace period)\r\n */\nfunction releaseStream(camId, type = \"sub\") {\n  const key = `${camId}_${type}`;\n  const entry = streamPool.get(key);\n  if (!entry) return;\n  entry.refs--;\n  console.log(`[SmartDual] Released ${key}, refs: ${entry.refs}`);\n  if (entry.refs <= 0) {\n    setTimeout(() => {\n      const currentEntry = streamPool.get(key);\n      if (currentEntry && currentEntry.refs <= 0) {\n        console.log(`[SmartDual] Closing idle ${key}`);\n        currentEntry.pc.close();\n        streamPool.delete(key);\n      }\n    }, 5000); // 5s grace period (shorter for faster cleanup)\n  }\n}\n\n/**\r\n * SMART DUAL STREAM PLAYER\r\n */\nexport default function SmartDualStreamPlayer({\n  camId,\n  isFullscreen,\n  isHidden,\n  isHovered,\n  style\n}) {\n  _s();\n  const videoRef = useRef(null);\n  const [subStream, setSubStream] = useState(null);\n  const [mainStream, setMainStream] = useState(null);\n  const [currentStream, setCurrentStream] = useState(\"sub\");\n\n  // Always acquire substream\n  useEffect(() => {\n    if (isHidden || !camId) return;\n    let active = true;\n    let subEntry;\n    acquireStream(camId, \"sub\").then(sub => {\n      if (!active) {\n        releaseStream(camId, \"sub\");\n        return;\n      }\n      subEntry = sub;\n      setSubStream(sub);\n\n      // Attach substream to video if not fullscreen\n      if (videoRef.current && !isFullscreen) {\n        videoRef.current.srcObject = sub.media;\n        videoRef.current.play().catch(() => {});\n      }\n    }).catch(err => {\n      console.error(`[SmartDual] Error for sub ${camId}:`, err);\n    });\n    return () => {\n      active = false;\n      if (subEntry) releaseStream(camId, \"sub\");\n    };\n  }, [camId, isHidden, isFullscreen]);\n\n  // SMART WARM STANDBY: Pre-connect main stream on HOVER or FULLSCREEN\n  useEffect(() => {\n    const shouldPreconnect = (isHovered || isFullscreen) && !isHidden && camId;\n    if (!shouldPreconnect) {\n      // Release main stream when not needed\n      if (mainStream) {\n        releaseStream(camId, \"hd\");\n        setMainStream(null);\n      }\n      return;\n    }\n    let active = true;\n    let mainEntry;\n    acquireStream(camId, \"hd\").then(main => {\n      if (!active) {\n        releaseStream(camId, \"hd\");\n        return;\n      }\n      mainEntry = main;\n      setMainStream(main);\n\n      // If fullscreen, attach immediately\n      if (isFullscreen && videoRef.current) {\n        videoRef.current.srcObject = main.media;\n        videoRef.current.play().catch(() => {});\n        setCurrentStream(\"main\");\n      }\n      // If just hovering, DON'T attach (warm standby)\n    }).catch(err => {\n      console.error(`[SmartDual] Error for main ${camId}:`, err);\n    });\n    return () => {\n      active = false;\n      if (mainEntry) releaseStream(camId, \"hd\");\n    };\n  }, [isHovered, isFullscreen, camId, isHidden, mainStream]);\n\n  // INSTANT SWITCH when fullscreen changes\n  useEffect(() => {\n    if (!videoRef.current) return;\n    if (isFullscreen && mainStream) {\n      // Switch to main\n      console.log(`[SmartDual] Switching to MAIN for ${camId}`);\n      videoRef.current.srcObject = mainStream.media;\n      videoRef.current.play().catch(() => {});\n      setCurrentStream(\"main\");\n    } else if (!isFullscreen && subStream) {\n      // Switch back to sub\n      console.log(`[SmartDual] Switching to SUB for ${camId}`);\n      videoRef.current.srcObject = subStream.media;\n      videoRef.current.play().catch(() => {});\n      setCurrentStream(\"sub\");\n    }\n  }, [isFullscreen, subStream, mainStream, camId]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      ...style,\n      position: \"relative\",\n      background: \"#000\",\n      width: \"100%\",\n      height: \"100%\"\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      autoPlay: true,\n      muted: true,\n      playsInline: true,\n      style: {\n        width: \"100%\",\n        height: \"100%\",\n        objectFit: \"fill\"\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 198,\n      columnNumber: 13\n    }, this), process.env.NODE_ENV === 'development' && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"absolute\",\n        top: 4,\n        right: 4,\n        background: \"rgba(0,0,0,0.7)\",\n        color: mainStream ? \"#0f0\" : \"#ff0\",\n        padding: \"2px 6px\",\n        fontSize: 10,\n        fontFamily: \"monospace\"\n      },\n      children: [currentStream.toUpperCase(), \" \", mainStream && !isFullscreen ? \"(STANDBY)\" : \"\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 211,\n      columnNumber: 17\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 197,\n    columnNumber: 9\n  }, this);\n}\n_s(SmartDualStreamPlayer, \"4PqRIFlfp0wBxmtpZmJKKf5uXQI=\");\n_c = SmartDualStreamPlayer;\nvar _c;\n$RefreshReg$(_c, \"SmartDualStreamPlayer\");","map":{"version":3,"names":["React","useEffect","useRef","useState","jsxDEV","_jsxDEV","GO2RTC_API","window","location","origin","streamPool","Map","acquireStream","camId","type","key","has","entry","get","refs","console","log","pc","RTCPeerConnection","iceServers","media","MediaStream","ontrack","e","addTrack","track","addTransceiver","direction","offer","createOffer","setLocalDescription","res","fetch","method","headers","body","sdp","ok","Error","status","answer","text","setRemoteDescription","set","err","close","releaseStream","setTimeout","currentEntry","delete","SmartDualStreamPlayer","isFullscreen","isHidden","isHovered","style","_s","videoRef","subStream","setSubStream","mainStream","setMainStream","currentStream","setCurrentStream","active","subEntry","then","sub","current","srcObject","play","catch","error","shouldPreconnect","mainEntry","main","position","background","width","height","children","ref","autoPlay","muted","playsInline","objectFit","fileName","_jsxFileName","lineNumber","columnNumber","process","env","NODE_ENV","top","right","color","padding","fontSize","fontFamily","toUpperCase","_c","$RefreshReg$"],"sources":["I:/dispecerat/github_release/dss-edge/local-ui/src/components/DualStreamPlayer.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\r\n\r\n/**\r\n * SMART DUAL STREAM MANAGER - Trassir-like with Smart Warm Standby\r\n * \r\n * ARCHITECTURE:\r\n * - Grid: substream only (low CPU)\r\n * - Hover: pre-connect main stream (warm standby)\r\n * - Fullscreen: instant switch (main already connected)\r\n * \r\n * CPU OPTIMIZATION:\r\n * - Only 1 main stream in warm standby at a time\r\n * - Grid idle: minimal overhead (25 substreams only)\r\n * - Switch: <200ms (connection already established)\r\n */\r\n\r\nconst GO2RTC_API = `${window.location.origin}/rtc`;\r\nconst streamPool = new Map();\r\n\r\n/**\r\n * Acquire WebRTC stream (reuses existing connections)\r\n */\r\nasync function acquireStream(camId, type = \"sub\") {\r\n    const key = `${camId}_${type}`;\r\n\r\n    if (streamPool.has(key)) {\r\n        const entry = streamPool.get(key);\r\n        entry.refs++;\r\n        console.log(`[SmartDual] Reusing ${key}, refs: ${entry.refs}`);\r\n        return entry;\r\n    }\r\n\r\n    console.log(`[SmartDual] Creating WebRTC for ${key}`);\r\n    const pc = new RTCPeerConnection({ iceServers: [] });\r\n    const media = new MediaStream();\r\n\r\n    pc.ontrack = (e) => {\r\n        console.log(`[SmartDual] Track received for ${key}`);\r\n        media.addTrack(e.track);\r\n    };\r\n\r\n    pc.addTransceiver(\"video\", { direction: \"recvonly\" });\r\n\r\n    try {\r\n        const offer = await pc.createOffer();\r\n        await pc.setLocalDescription(offer);\r\n\r\n        const res = await fetch(`${GO2RTC_API}/api/webrtc?src=${key}`, {\r\n            method: \"POST\",\r\n            headers: { \"Content-Type\": \"application/sdp\" },\r\n            body: offer.sdp\r\n        });\r\n\r\n        if (!res.ok) {\r\n            throw new Error(`WebRTC failed: ${res.status}`);\r\n        }\r\n\r\n        const answer = await res.text();\r\n        await pc.setRemoteDescription({ type: \"answer\", sdp: answer });\r\n\r\n        const entry = { pc, media, refs: 1 };\r\n        streamPool.set(key, entry);\r\n        return entry;\r\n    } catch (err) {\r\n        pc.close();\r\n        throw err;\r\n    }\r\n}\r\n\r\n/**\r\n * Release stream (with grace period)\r\n */\r\nfunction releaseStream(camId, type = \"sub\") {\r\n    const key = `${camId}_${type}`;\r\n    const entry = streamPool.get(key);\r\n    if (!entry) return;\r\n\r\n    entry.refs--;\r\n    console.log(`[SmartDual] Released ${key}, refs: ${entry.refs}`);\r\n\r\n    if (entry.refs <= 0) {\r\n        setTimeout(() => {\r\n            const currentEntry = streamPool.get(key);\r\n            if (currentEntry && currentEntry.refs <= 0) {\r\n                console.log(`[SmartDual] Closing idle ${key}`);\r\n                currentEntry.pc.close();\r\n                streamPool.delete(key);\r\n            }\r\n        }, 5000); // 5s grace period (shorter for faster cleanup)\r\n    }\r\n}\r\n\r\n/**\r\n * SMART DUAL STREAM PLAYER\r\n */\r\nexport default function SmartDualStreamPlayer({ camId, isFullscreen, isHidden, isHovered, style }) {\r\n    const videoRef = useRef(null);\r\n    const [subStream, setSubStream] = useState(null);\r\n    const [mainStream, setMainStream] = useState(null);\r\n    const [currentStream, setCurrentStream] = useState(\"sub\");\r\n\r\n    // Always acquire substream\r\n    useEffect(() => {\r\n        if (isHidden || !camId) return;\r\n\r\n        let active = true;\r\n        let subEntry;\r\n\r\n        acquireStream(camId, \"sub\")\r\n            .then((sub) => {\r\n                if (!active) {\r\n                    releaseStream(camId, \"sub\");\r\n                    return;\r\n                }\r\n                subEntry = sub;\r\n                setSubStream(sub);\r\n\r\n                // Attach substream to video if not fullscreen\r\n                if (videoRef.current && !isFullscreen) {\r\n                    videoRef.current.srcObject = sub.media;\r\n                    videoRef.current.play().catch(() => { });\r\n                }\r\n            })\r\n            .catch((err) => {\r\n                console.error(`[SmartDual] Error for sub ${camId}:`, err);\r\n            });\r\n\r\n        return () => {\r\n            active = false;\r\n            if (subEntry) releaseStream(camId, \"sub\");\r\n        };\r\n    }, [camId, isHidden, isFullscreen]);\r\n\r\n    // SMART WARM STANDBY: Pre-connect main stream on HOVER or FULLSCREEN\r\n    useEffect(() => {\r\n        const shouldPreconnect = (isHovered || isFullscreen) && !isHidden && camId;\r\n\r\n        if (!shouldPreconnect) {\r\n            // Release main stream when not needed\r\n            if (mainStream) {\r\n                releaseStream(camId, \"hd\");\r\n                setMainStream(null);\r\n            }\r\n            return;\r\n        }\r\n\r\n        let active = true;\r\n        let mainEntry;\r\n\r\n        acquireStream(camId, \"hd\")\r\n            .then((main) => {\r\n                if (!active) {\r\n                    releaseStream(camId, \"hd\");\r\n                    return;\r\n                }\r\n                mainEntry = main;\r\n                setMainStream(main);\r\n\r\n                // If fullscreen, attach immediately\r\n                if (isFullscreen && videoRef.current) {\r\n                    videoRef.current.srcObject = main.media;\r\n                    videoRef.current.play().catch(() => { });\r\n                    setCurrentStream(\"main\");\r\n                }\r\n                // If just hovering, DON'T attach (warm standby)\r\n            })\r\n            .catch((err) => {\r\n                console.error(`[SmartDual] Error for main ${camId}:`, err);\r\n            });\r\n\r\n        return () => {\r\n            active = false;\r\n            if (mainEntry) releaseStream(camId, \"hd\");\r\n        };\r\n    }, [isHovered, isFullscreen, camId, isHidden, mainStream]);\r\n\r\n    // INSTANT SWITCH when fullscreen changes\r\n    useEffect(() => {\r\n        if (!videoRef.current) return;\r\n\r\n        if (isFullscreen && mainStream) {\r\n            // Switch to main\r\n            console.log(`[SmartDual] Switching to MAIN for ${camId}`);\r\n            videoRef.current.srcObject = mainStream.media;\r\n            videoRef.current.play().catch(() => { });\r\n            setCurrentStream(\"main\");\r\n        } else if (!isFullscreen && subStream) {\r\n            // Switch back to sub\r\n            console.log(`[SmartDual] Switching to SUB for ${camId}`);\r\n            videoRef.current.srcObject = subStream.media;\r\n            videoRef.current.play().catch(() => { });\r\n            setCurrentStream(\"sub\");\r\n        }\r\n    }, [isFullscreen, subStream, mainStream, camId]);\r\n\r\n    return (\r\n        <div style={{ ...style, position: \"relative\", background: \"#000\", width: \"100%\", height: \"100%\" }}>\r\n            <video\r\n                ref={videoRef}\r\n                autoPlay\r\n                muted\r\n                playsInline\r\n                style={{\r\n                    width: \"100%\",\r\n                    height: \"100%\",\r\n                    objectFit: \"fill\"\r\n                }}\r\n            />\r\n            {/* Debug indicator */}\r\n            {process.env.NODE_ENV === 'development' && (\r\n                <div style={{\r\n                    position: \"absolute\",\r\n                    top: 4,\r\n                    right: 4,\r\n                    background: \"rgba(0,0,0,0.7)\",\r\n                    color: mainStream ? \"#0f0\" : \"#ff0\",\r\n                    padding: \"2px 6px\",\r\n                    fontSize: 10,\r\n                    fontFamily: \"monospace\"\r\n                }}>\r\n                    {currentStream.toUpperCase()} {mainStream && !isFullscreen ? \"(STANDBY)\" : \"\"}\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}