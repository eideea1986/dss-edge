{"ast":null,"code":"import Hls from 'hls.js';\nexport default class PlaybackCoreV2 {\n  constructor(videoElement, camId, baseUrl = '/api') {\n    this.video = videoElement;\n    this.camId = camId;\n    this.baseUrl = baseUrl;\n    this.hls = null;\n    this.currentFragPDT = 0;\n    this.currentFragStartPTS = 0;\n  }\n  setSegments(segments) {\n    // Sort segments chronologically\n    this.segments = [...segments].sort((a, b) => a.startTs - b.startTs);\n\n    // Build Virtual Timeline Map to handle gaps\n    this.timeline = [];\n    let virtualTime = 0;\n    for (const s of this.segments) {\n      const duration = s.endTs - s.startTs;\n      this.timeline.push({\n        realStart: s.startTs,\n        realEnd: s.endTs,\n        virtualStart: virtualTime,\n        virtualEnd: virtualTime + duration,\n        duration: duration\n      });\n      virtualTime += duration;\n    }\n    this.totalDurationMs = virtualTime;\n    console.log(`[PlaybackCore] Timeline built: ${this.segments.length} segments, Total virtual duration: ${Math.round(virtualTime / 1000)}s`);\n  }\n  start(startEpochMs) {\n    var _this$segments;\n    if (this.hls) {\n      this.hls.destroy();\n      this.hls = null;\n    }\n\n    // AUTO-SKIP GAPS: If start time is in a gap, jump to next available segment\n    const segment = (_this$segments = this.segments) === null || _this$segments === void 0 ? void 0 : _this$segments.find(s => startEpochMs >= s.startTs && startEpochMs <= s.endTs);\n    let actualStart = startEpochMs;\n    if (!segment && this.segments) {\n      const next = this.segments.find(s => s.startTs > startEpochMs);\n      if (next) {\n        console.log(`[PlaybackCore] Seeking into gap. Jumping forward to ${new Date(next.startTs).toLocaleTimeString()}`);\n        actualStart = next.startTs;\n      }\n    }\n    const playlistUrl = `${this.baseUrl}/playback/playlist/${this.camId}.m3u8?start=${actualStart}&end=${actualStart + 60 * 60 * 1000}`;\n    if (Hls.isSupported()) {\n      this.hls = new Hls({\n        enableWorker: true,\n        maxBufferLength: 30,\n        maxMaxBufferLength: 60,\n        backBufferLength: 10\n      });\n      this.hls.loadSource(playlistUrl);\n      this.hls.attachMedia(this.video);\n      this.hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {\n        this.video.currentTime = data.levels[0].details.fragments[0].start;\n        this.video.play().catch(e => console.warn(\"Autoplay blocked\", e));\n      });\n      this.hls.on(Hls.Events.FRAG_CHANGED, (event, data) => {\n        if (data.frag && data.frag.programDateTime) {\n          this.currentFragPDT = data.frag.programDateTime;\n          this.currentFragStartPTS = data.frag.start;\n        }\n      });\n\n      // GAP MONITORING\n      this.video.ontimeupdate = () => {\n        var _this$segments2;\n        const currentEpoch = this.getCurrentEpochMs();\n        if (!currentEpoch) return;\n\n        // If we hit a gap (no segment covers current playback time), find next\n        const inSegment = (_this$segments2 = this.segments) === null || _this$segments2 === void 0 ? void 0 : _this$segments2.some(s => currentEpoch >= s.startTs && currentEpoch <= s.endTs);\n        if (!inSegment && this.segments) {\n          const next = this.segments.find(s => s.startTs > currentEpoch);\n          if (next) {\n            console.log(\"[PlaybackCore] Gap detected during playback. Skipping...\");\n            this.seekTo(next.startTs);\n          }\n        }\n      };\n    } else if (this.video.canPlayType('application/vnd.apple.mpegurl')) {\n      this.video.src = playlistUrl;\n    }\n  }\n  epochToVideoTime(epochMs) {\n    if (!this.timeline) return 0;\n    for (const t of this.timeline) {\n      if (epochMs >= t.realStart && epochMs <= t.realEnd) {\n        return (t.virtualStart + (epochMs - t.realStart)) / 1000;\n      }\n    }\n    return null; // Gap\n  }\n  seekTo(ts) {\n    this.start(ts);\n  }\n  getCurrentEpochMs() {\n    if (this.currentFragPDT && this.hls) {\n      const timeInFrag = this.video.currentTime - this.currentFragStartPTS;\n      const absoluteTime = this.currentFragPDT + timeInFrag * 1000;\n      return absoluteTime;\n    }\n    return 0;\n  }\n  destroy() {\n    if (this.hls) {\n      this.hls.destroy();\n      this.hls = null;\n    }\n    this.video.ontimeupdate = null;\n  }\n}","map":{"version":3,"names":["Hls","PlaybackCoreV2","constructor","videoElement","camId","baseUrl","video","hls","currentFragPDT","currentFragStartPTS","setSegments","segments","sort","a","b","startTs","timeline","virtualTime","s","duration","endTs","push","realStart","realEnd","virtualStart","virtualEnd","totalDurationMs","console","log","length","Math","round","start","startEpochMs","_this$segments","destroy","segment","find","actualStart","next","Date","toLocaleTimeString","playlistUrl","isSupported","enableWorker","maxBufferLength","maxMaxBufferLength","backBufferLength","loadSource","attachMedia","on","Events","MANIFEST_PARSED","event","data","currentTime","levels","details","fragments","play","catch","e","warn","FRAG_CHANGED","frag","programDateTime","ontimeupdate","_this$segments2","currentEpoch","getCurrentEpochMs","inSegment","some","seekTo","canPlayType","src","epochToVideoTime","epochMs","t","ts","timeInFrag","absoluteTime"],"sources":["I:/dispecerat/github_release/dss-edge/local-ui/src/services/PlaybackCoreV2.js"],"sourcesContent":["import Hls from 'hls.js';\r\n\r\nexport default class PlaybackCoreV2 {\r\n    constructor(videoElement, camId, baseUrl = '/api') {\r\n        this.video = videoElement;\r\n        this.camId = camId;\r\n        this.baseUrl = baseUrl;\r\n        this.hls = null;\r\n        this.currentFragPDT = 0;\r\n        this.currentFragStartPTS = 0;\r\n    }\r\n\r\n    setSegments(segments) {\r\n        // Sort segments chronologically\r\n        this.segments = [...segments].sort((a, b) => a.startTs - b.startTs);\r\n\r\n        // Build Virtual Timeline Map to handle gaps\r\n        this.timeline = [];\r\n        let virtualTime = 0;\r\n\r\n        for (const s of this.segments) {\r\n            const duration = s.endTs - s.startTs;\r\n            this.timeline.push({\r\n                realStart: s.startTs,\r\n                realEnd: s.endTs,\r\n                virtualStart: virtualTime,\r\n                virtualEnd: virtualTime + duration,\r\n                duration: duration\r\n            });\r\n            virtualTime += duration;\r\n        }\r\n\r\n        this.totalDurationMs = virtualTime;\r\n        console.log(`[PlaybackCore] Timeline built: ${this.segments.length} segments, Total virtual duration: ${Math.round(virtualTime / 1000)}s`);\r\n    }\r\n\r\n    start(startEpochMs) {\r\n        if (this.hls) {\r\n            this.hls.destroy();\r\n            this.hls = null;\r\n        }\r\n\r\n        // AUTO-SKIP GAPS: If start time is in a gap, jump to next available segment\r\n        const segment = this.segments?.find(s => startEpochMs >= s.startTs && startEpochMs <= s.endTs);\r\n        let actualStart = startEpochMs;\r\n\r\n        if (!segment && this.segments) {\r\n            const next = this.segments.find(s => s.startTs > startEpochMs);\r\n            if (next) {\r\n                console.log(`[PlaybackCore] Seeking into gap. Jumping forward to ${new Date(next.startTs).toLocaleTimeString()}`);\r\n                actualStart = next.startTs;\r\n            }\r\n        }\r\n\r\n        const playlistUrl = `${this.baseUrl}/playback/playlist/${this.camId}.m3u8?start=${actualStart}&end=${actualStart + 60 * 60 * 1000}`;\r\n\r\n        if (Hls.isSupported()) {\r\n            this.hls = new Hls({\r\n                enableWorker: true,\r\n                maxBufferLength: 30,\r\n                maxMaxBufferLength: 60,\r\n                backBufferLength: 10,\r\n            });\r\n\r\n            this.hls.loadSource(playlistUrl);\r\n            this.hls.attachMedia(this.video);\r\n\r\n            this.hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {\r\n                this.video.currentTime = data.levels[0].details.fragments[0].start;\r\n                this.video.play().catch(e => console.warn(\"Autoplay blocked\", e));\r\n            });\r\n\r\n            this.hls.on(Hls.Events.FRAG_CHANGED, (event, data) => {\r\n                if (data.frag && data.frag.programDateTime) {\r\n                    this.currentFragPDT = data.frag.programDateTime;\r\n                    this.currentFragStartPTS = data.frag.start;\r\n                }\r\n            });\r\n\r\n            // GAP MONITORING\r\n            this.video.ontimeupdate = () => {\r\n                const currentEpoch = this.getCurrentEpochMs();\r\n                if (!currentEpoch) return;\r\n\r\n                // If we hit a gap (no segment covers current playback time), find next\r\n                const inSegment = this.segments?.some(s => currentEpoch >= s.startTs && currentEpoch <= s.endTs);\r\n                if (!inSegment && this.segments) {\r\n                    const next = this.segments.find(s => s.startTs > currentEpoch);\r\n                    if (next) {\r\n                        console.log(\"[PlaybackCore] Gap detected during playback. Skipping...\");\r\n                        this.seekTo(next.startTs);\r\n                    }\r\n                }\r\n            };\r\n        } else if (this.video.canPlayType('application/vnd.apple.mpegurl')) {\r\n            this.video.src = playlistUrl;\r\n        }\r\n    }\r\n\r\n    epochToVideoTime(epochMs) {\r\n        if (!this.timeline) return 0;\r\n        for (const t of this.timeline) {\r\n            if (epochMs >= t.realStart && epochMs <= t.realEnd) {\r\n                return (t.virtualStart + (epochMs - t.realStart)) / 1000;\r\n            }\r\n        }\r\n        return null; // Gap\r\n    }\r\n\r\n    seekTo(ts) {\r\n        this.start(ts);\r\n    }\r\n\r\n    getCurrentEpochMs() {\r\n        if (this.currentFragPDT && this.hls) {\r\n            const timeInFrag = this.video.currentTime - this.currentFragStartPTS;\r\n            const absoluteTime = this.currentFragPDT + (timeInFrag * 1000);\r\n            return absoluteTime;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    destroy() {\r\n        if (this.hls) {\r\n            this.hls.destroy();\r\n            this.hls = null;\r\n        }\r\n        this.video.ontimeupdate = null;\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}