{"ast":null,"code":"var _jsxFileName = \"I:\\\\dispecerat\\\\github_release\\\\dss-edge\\\\local-ui\\\\src\\\\components\\\\DualStreamPlayer.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from \"react\";\n\n/**\r\n * SMART DUAL STREAM MANAGER - Trassir-like with Smart Warm Standby\r\n * \r\n * ARCHITECTURE:\r\n * - Grid: substream only (low CPU)\r\n * - Hover: pre-connect main stream (warm standby)\r\n * - Fullscreen: instant switch (main already connected)\r\n * \r\n * CPU OPTIMIZATION:\r\n * - Only 1 main stream in warm standby at a time\r\n * - Grid idle: minimal overhead (25 substreams only)\r\n * - Switch: <200ms (connection already established)\r\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst GO2RTC_API = `${window.location.origin}/rtc`;\nconst streamPool = new Map();\n\n/**\r\n * Acquire WebRTC stream (reuses existing connections)\r\n */\nasync function acquireStream(camId, type = \"sub\") {\n  const key = `${camId}_${type}`;\n  if (streamPool.has(key)) {\n    const entry = streamPool.get(key);\n    entry.refs++;\n    console.log(`[SmartDual] Reusing ${key}, refs: ${entry.refs}`);\n    return entry;\n  }\n  console.log(`[SmartDual] Creating WebRTC for ${key}`);\n  const pc = new RTCPeerConnection({\n    iceServers: []\n  });\n  const media = new MediaStream();\n  pc.ontrack = e => {\n    console.log(`[SmartDual] Track received for ${key}`);\n    media.addTrack(e.track);\n  };\n  pc.addTransceiver(\"video\", {\n    direction: \"recvonly\"\n  });\n  try {\n    const offer = await pc.createOffer();\n    await pc.setLocalDescription(offer);\n    const res = await fetch(`${GO2RTC_API}/api/webrtc?src=${key}`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/sdp\"\n      },\n      body: offer.sdp\n    });\n    if (!res.ok) {\n      throw new Error(`WebRTC failed: ${res.status}`);\n    }\n    const answer = await res.text();\n    await pc.setRemoteDescription({\n      type: \"answer\",\n      sdp: answer\n    });\n    const entry = {\n      pc,\n      media,\n      refs: 1\n    };\n    streamPool.set(key, entry);\n    return entry;\n  } catch (err) {\n    pc.close();\n    throw err;\n  }\n}\n\n/**\r\n * Release stream (with grace period)\r\n */\nfunction releaseStream(camId, type = \"sub\") {\n  const key = `${camId}_${type}`;\n  const entry = streamPool.get(key);\n  if (!entry) return;\n  entry.refs--;\n  console.log(`[SmartDual] Released ${key}, refs: ${entry.refs}`);\n  if (entry.refs <= 0) {\n    setTimeout(() => {\n      const currentEntry = streamPool.get(key);\n      if (currentEntry && currentEntry.refs <= 0) {\n        console.log(`[SmartDual] Closing idle ${key}`);\n        currentEntry.pc.close();\n        streamPool.delete(key);\n      }\n    }, 5000); // 5s grace period (shorter for faster cleanup)\n  }\n}\n\n/**\r\n * SMART DUAL STREAM PLAYER\r\n */\nexport default function SmartDualStreamPlayer({\n  camId,\n  isFullscreen,\n  isHidden,\n  isHovered,\n  posterUrl,\n  style\n}) {\n  _s();\n  const videoRef = useRef(null);\n  const [subStream, setSubStream] = useState(null);\n  const [mainStream, setMainStream] = useState(null);\n  const [currentStream, setCurrentStream] = useState(\"sub\");\n  const [posterVisible, setPosterVisible] = useState(true);\n\n  // Reset poster visibility when switching modes or cameras\n  useEffect(() => {\n    setPosterVisible(true);\n  }, [camId, isFullscreen]);\n\n  // Handle video play event to hide poster\n  const handleCanPlay = () => {\n    // Delay slighty to ensure frame is rendered\n    // setTimeout(() => setPosterVisible(false), 100);\n    setPosterVisible(false);\n  };\n\n  // Always acquire substream\n  useEffect(() => {\n    if (isHidden || !camId) return;\n    let active = true;\n    let subEntry;\n    acquireStream(camId, \"sub\").then(sub => {\n      if (!active) {\n        releaseStream(camId, \"sub\");\n        return;\n      }\n      subEntry = sub;\n      setSubStream(sub);\n\n      // Attach substream to video if not fullscreen\n      if (videoRef.current && !isFullscreen) {\n        videoRef.current.srcObject = sub.media;\n        videoRef.current.play().catch(() => {});\n      }\n    }).catch(err => {\n      console.error(`[SmartDual] Error for sub ${camId}:`, err);\n    });\n    return () => {\n      active = false;\n      if (subEntry) releaseStream(camId, \"sub\");\n    };\n  }, [camId, isHidden, isFullscreen]);\n\n  // SMART WARM STANDBY with DEBOUNCE: Pre-connect main stream on sustained HOVER or FULLSCREEN\n  useEffect(() => {\n    let debounceTimer;\n    let mainEntry;\n    const cleanup = () => {\n      if (debounceTimer) clearTimeout(debounceTimer);\n      if (mainEntry) releaseStream(camId, \"hd\");\n    };\n\n    // Immediate connection for fullscreen\n    if (isFullscreen && !isHidden && camId) {\n      acquireStream(camId, \"hd\").then(main => {\n        mainEntry = main;\n        setMainStream(main);\n        if (videoRef.current) {\n          videoRef.current.srcObject = main.media;\n          videoRef.current.play().catch(() => {});\n          setCurrentStream(\"main\");\n        }\n      }).catch(err => console.error(`[SmartDual] Error for main ${camId}:`, err));\n    }\n    // Debounced connection for hover (800ms delay)\n    else if (isHovered && !isHidden && camId && !isFullscreen) {\n      debounceTimer = setTimeout(() => {\n        console.log(`[SmartDual] Hover sustained - pre-connecting main for ${camId}`);\n        acquireStream(camId, \"hd\").then(main => {\n          mainEntry = main;\n          setMainStream(main);\n          // Don't attach - warm standby only\n        }).catch(err => console.error(`[SmartDual] Error for main ${camId}:`, err));\n      }, 800);\n    }\n    // Release main stream when not needed\n    else if (mainStream && !isFullscreen && !isHovered) {\n      releaseStream(camId, \"hd\");\n      setMainStream(null);\n    }\n    return cleanup;\n  }, [isHovered, isFullscreen, camId, isHidden]);\n\n  // INSTANT SWITCH when fullscreen changes\n  useEffect(() => {\n    if (!videoRef.current) return;\n\n    // Show poster briefly on switch\n    setPosterVisible(true);\n    if (isFullscreen && mainStream) {\n      // Switch to main\n      console.log(`[SmartDual] Switching to MAIN for ${camId}`);\n      videoRef.current.srcObject = mainStream.media;\n      videoRef.current.play().catch(() => {});\n      setCurrentStream(\"main\");\n    } else if (!isFullscreen && subStream) {\n      // Switch back to sub\n      console.log(`[SmartDual] Switching to SUB for ${camId}`);\n      videoRef.current.srcObject = subStream.media;\n      videoRef.current.play().catch(() => {});\n      setCurrentStream(\"sub\");\n    }\n  }, [isFullscreen, subStream, mainStream, camId]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      ...style,\n      position: \"relative\",\n      background: \"#000\",\n      width: \"100%\",\n      height: \"100%\",\n      overflow: \"hidden\"\n    },\n    children: [posterUrl && /*#__PURE__*/_jsxDEV(\"img\", {\n      src: posterUrl + `?_=${Date.now()}` // Bust cache slightly or ensure latest\n      ,\n      style: {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        width: \"100%\",\n        height: \"100%\",\n        objectFit: \"fill\",\n        zIndex: 10,\n        opacity: posterVisible ? 1 : 0,\n        transition: \"opacity 150ms ease-out\",\n        pointerEvents: \"none\"\n      },\n      onError: e => e.target.style.display = 'none',\n      alt: \"\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 219,\n      columnNumber: 17\n    }, this), /*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      autoPlay: true,\n      muted: true,\n      playsInline: true,\n      onPlaying: handleCanPlay,\n      style: {\n        width: \"100%\",\n        height: \"100%\",\n        objectFit: \"fill\",\n        position: \"absolute\",\n        top: 0,\n        left: 0\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 238,\n      columnNumber: 13\n    }, this), process.env.NODE_ENV === 'development' && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"absolute\",\n        top: 4,\n        right: 4,\n        background: \"rgba(0,0,0,0.7)\",\n        color: mainStream ? \"#0f0\" : \"#ff0\",\n        padding: \"2px 6px\",\n        fontSize: 10,\n        fontFamily: \"monospace\",\n        zIndex: 20\n      },\n      children: [currentStream.toUpperCase(), \" \", mainStream && !isFullscreen ? \"(STANDBY)\" : \"\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 255,\n      columnNumber: 17\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 216,\n    columnNumber: 9\n  }, this);\n}\n_s(SmartDualStreamPlayer, \"xxQG8TjzZOKy995KUUts45D9CJY=\");\n_c = SmartDualStreamPlayer;\nvar _c;\n$RefreshReg$(_c, \"SmartDualStreamPlayer\");","map":{"version":3,"names":["React","useEffect","useRef","useState","jsxDEV","_jsxDEV","GO2RTC_API","window","location","origin","streamPool","Map","acquireStream","camId","type","key","has","entry","get","refs","console","log","pc","RTCPeerConnection","iceServers","media","MediaStream","ontrack","e","addTrack","track","addTransceiver","direction","offer","createOffer","setLocalDescription","res","fetch","method","headers","body","sdp","ok","Error","status","answer","text","setRemoteDescription","set","err","close","releaseStream","setTimeout","currentEntry","delete","SmartDualStreamPlayer","isFullscreen","isHidden","isHovered","posterUrl","style","_s","videoRef","subStream","setSubStream","mainStream","setMainStream","currentStream","setCurrentStream","posterVisible","setPosterVisible","handleCanPlay","active","subEntry","then","sub","current","srcObject","play","catch","error","debounceTimer","mainEntry","cleanup","clearTimeout","main","position","background","width","height","overflow","children","src","Date","now","top","left","objectFit","zIndex","opacity","transition","pointerEvents","onError","target","display","alt","fileName","_jsxFileName","lineNumber","columnNumber","ref","autoPlay","muted","playsInline","onPlaying","process","env","NODE_ENV","right","color","padding","fontSize","fontFamily","toUpperCase","_c","$RefreshReg$"],"sources":["I:/dispecerat/github_release/dss-edge/local-ui/src/components/DualStreamPlayer.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\r\n\r\n/**\r\n * SMART DUAL STREAM MANAGER - Trassir-like with Smart Warm Standby\r\n * \r\n * ARCHITECTURE:\r\n * - Grid: substream only (low CPU)\r\n * - Hover: pre-connect main stream (warm standby)\r\n * - Fullscreen: instant switch (main already connected)\r\n * \r\n * CPU OPTIMIZATION:\r\n * - Only 1 main stream in warm standby at a time\r\n * - Grid idle: minimal overhead (25 substreams only)\r\n * - Switch: <200ms (connection already established)\r\n */\r\n\r\nconst GO2RTC_API = `${window.location.origin}/rtc`;\r\nconst streamPool = new Map();\r\n\r\n/**\r\n * Acquire WebRTC stream (reuses existing connections)\r\n */\r\nasync function acquireStream(camId, type = \"sub\") {\r\n    const key = `${camId}_${type}`;\r\n\r\n    if (streamPool.has(key)) {\r\n        const entry = streamPool.get(key);\r\n        entry.refs++;\r\n        console.log(`[SmartDual] Reusing ${key}, refs: ${entry.refs}`);\r\n        return entry;\r\n    }\r\n\r\n    console.log(`[SmartDual] Creating WebRTC for ${key}`);\r\n    const pc = new RTCPeerConnection({ iceServers: [] });\r\n    const media = new MediaStream();\r\n\r\n    pc.ontrack = (e) => {\r\n        console.log(`[SmartDual] Track received for ${key}`);\r\n        media.addTrack(e.track);\r\n    };\r\n\r\n    pc.addTransceiver(\"video\", { direction: \"recvonly\" });\r\n\r\n    try {\r\n        const offer = await pc.createOffer();\r\n        await pc.setLocalDescription(offer);\r\n\r\n        const res = await fetch(`${GO2RTC_API}/api/webrtc?src=${key}`, {\r\n            method: \"POST\",\r\n            headers: { \"Content-Type\": \"application/sdp\" },\r\n            body: offer.sdp\r\n        });\r\n\r\n        if (!res.ok) {\r\n            throw new Error(`WebRTC failed: ${res.status}`);\r\n        }\r\n\r\n        const answer = await res.text();\r\n        await pc.setRemoteDescription({ type: \"answer\", sdp: answer });\r\n\r\n        const entry = { pc, media, refs: 1 };\r\n        streamPool.set(key, entry);\r\n        return entry;\r\n    } catch (err) {\r\n        pc.close();\r\n        throw err;\r\n    }\r\n}\r\n\r\n/**\r\n * Release stream (with grace period)\r\n */\r\nfunction releaseStream(camId, type = \"sub\") {\r\n    const key = `${camId}_${type}`;\r\n    const entry = streamPool.get(key);\r\n    if (!entry) return;\r\n\r\n    entry.refs--;\r\n    console.log(`[SmartDual] Released ${key}, refs: ${entry.refs}`);\r\n\r\n    if (entry.refs <= 0) {\r\n        setTimeout(() => {\r\n            const currentEntry = streamPool.get(key);\r\n            if (currentEntry && currentEntry.refs <= 0) {\r\n                console.log(`[SmartDual] Closing idle ${key}`);\r\n                currentEntry.pc.close();\r\n                streamPool.delete(key);\r\n            }\r\n        }, 5000); // 5s grace period (shorter for faster cleanup)\r\n    }\r\n}\r\n\r\n/**\r\n * SMART DUAL STREAM PLAYER\r\n */\r\nexport default function SmartDualStreamPlayer({ camId, isFullscreen, isHidden, isHovered, posterUrl, style }) {\r\n    const videoRef = useRef(null);\r\n    const [subStream, setSubStream] = useState(null);\r\n    const [mainStream, setMainStream] = useState(null);\r\n    const [currentStream, setCurrentStream] = useState(\"sub\");\r\n    const [posterVisible, setPosterVisible] = useState(true);\r\n\r\n    // Reset poster visibility when switching modes or cameras\r\n    useEffect(() => {\r\n        setPosterVisible(true);\r\n    }, [camId, isFullscreen]);\r\n\r\n    // Handle video play event to hide poster\r\n    const handleCanPlay = () => {\r\n        // Delay slighty to ensure frame is rendered\r\n        // setTimeout(() => setPosterVisible(false), 100);\r\n        setPosterVisible(false);\r\n    };\r\n\r\n    // Always acquire substream\r\n    useEffect(() => {\r\n        if (isHidden || !camId) return;\r\n\r\n        let active = true;\r\n        let subEntry;\r\n\r\n        acquireStream(camId, \"sub\")\r\n            .then((sub) => {\r\n                if (!active) {\r\n                    releaseStream(camId, \"sub\");\r\n                    return;\r\n                }\r\n                subEntry = sub;\r\n                setSubStream(sub);\r\n\r\n                // Attach substream to video if not fullscreen\r\n                if (videoRef.current && !isFullscreen) {\r\n                    videoRef.current.srcObject = sub.media;\r\n                    videoRef.current.play().catch(() => { });\r\n                }\r\n            })\r\n            .catch((err) => {\r\n                console.error(`[SmartDual] Error for sub ${camId}:`, err);\r\n            });\r\n\r\n        return () => {\r\n            active = false;\r\n            if (subEntry) releaseStream(camId, \"sub\");\r\n        };\r\n    }, [camId, isHidden, isFullscreen]);\r\n\r\n    // SMART WARM STANDBY with DEBOUNCE: Pre-connect main stream on sustained HOVER or FULLSCREEN\r\n    useEffect(() => {\r\n        let debounceTimer;\r\n        let mainEntry;\r\n\r\n        const cleanup = () => {\r\n            if (debounceTimer) clearTimeout(debounceTimer);\r\n            if (mainEntry) releaseStream(camId, \"hd\");\r\n        };\r\n\r\n        // Immediate connection for fullscreen\r\n        if (isFullscreen && !isHidden && camId) {\r\n            acquireStream(camId, \"hd\")\r\n                .then((main) => {\r\n                    mainEntry = main;\r\n                    setMainStream(main);\r\n                    if (videoRef.current) {\r\n                        videoRef.current.srcObject = main.media;\r\n                        videoRef.current.play().catch(() => { });\r\n                        setCurrentStream(\"main\");\r\n                    }\r\n                })\r\n                .catch((err) => console.error(`[SmartDual] Error for main ${camId}:`, err));\r\n        }\r\n        // Debounced connection for hover (800ms delay)\r\n        else if (isHovered && !isHidden && camId && !isFullscreen) {\r\n            debounceTimer = setTimeout(() => {\r\n                console.log(`[SmartDual] Hover sustained - pre-connecting main for ${camId}`);\r\n                acquireStream(camId, \"hd\")\r\n                    .then((main) => {\r\n                        mainEntry = main;\r\n                        setMainStream(main);\r\n                        // Don't attach - warm standby only\r\n                    })\r\n                    .catch((err) => console.error(`[SmartDual] Error for main ${camId}:`, err));\r\n            }, 800);\r\n        }\r\n        // Release main stream when not needed\r\n        else if (mainStream && !isFullscreen && !isHovered) {\r\n            releaseStream(camId, \"hd\");\r\n            setMainStream(null);\r\n        }\r\n\r\n        return cleanup;\r\n    }, [isHovered, isFullscreen, camId, isHidden]);\r\n\r\n    // INSTANT SWITCH when fullscreen changes\r\n    useEffect(() => {\r\n        if (!videoRef.current) return;\r\n\r\n        // Show poster briefly on switch\r\n        setPosterVisible(true);\r\n\r\n        if (isFullscreen && mainStream) {\r\n            // Switch to main\r\n            console.log(`[SmartDual] Switching to MAIN for ${camId}`);\r\n            videoRef.current.srcObject = mainStream.media;\r\n            videoRef.current.play().catch(() => { });\r\n            setCurrentStream(\"main\");\r\n        } else if (!isFullscreen && subStream) {\r\n            // Switch back to sub\r\n            console.log(`[SmartDual] Switching to SUB for ${camId}`);\r\n            videoRef.current.srcObject = subStream.media;\r\n            videoRef.current.play().catch(() => { });\r\n            setCurrentStream(\"sub\");\r\n        }\r\n    }, [isFullscreen, subStream, mainStream, camId]);\r\n\r\n    return (\r\n        <div style={{ ...style, position: \"relative\", background: \"#000\", width: \"100%\", height: \"100%\", overflow: \"hidden\" }}>\r\n            {/* STATIC POSTER (Zero Latency UX) */}\r\n            {posterUrl && (\r\n                <img\r\n                    src={posterUrl + `?_=${Date.now()}`} // Bust cache slightly or ensure latest\r\n                    style={{\r\n                        position: \"absolute\",\r\n                        top: 0,\r\n                        left: 0,\r\n                        width: \"100%\",\r\n                        height: \"100%\",\r\n                        objectFit: \"fill\",\r\n                        zIndex: 10,\r\n                        opacity: posterVisible ? 1 : 0,\r\n                        transition: \"opacity 150ms ease-out\",\r\n                        pointerEvents: \"none\"\r\n                    }}\r\n                    onError={(e) => e.target.style.display = 'none'}\r\n                    alt=\"\"\r\n                />\r\n            )}\r\n\r\n            <video\r\n                ref={videoRef}\r\n                autoPlay\r\n                muted\r\n                playsInline\r\n                onPlaying={handleCanPlay}\r\n                style={{\r\n                    width: \"100%\",\r\n                    height: \"100%\",\r\n                    objectFit: \"fill\",\r\n                    position: \"absolute\",\r\n                    top: 0,\r\n                    left: 0\r\n                }}\r\n            />\r\n            {/* Debug indicator */}\r\n            {process.env.NODE_ENV === 'development' && (\r\n                <div style={{\r\n                    position: \"absolute\",\r\n                    top: 4,\r\n                    right: 4,\r\n                    background: \"rgba(0,0,0,0.7)\",\r\n                    color: mainStream ? \"#0f0\" : \"#ff0\",\r\n                    padding: \"2px 6px\",\r\n                    fontSize: 10,\r\n                    fontFamily: \"monospace\",\r\n                    zIndex: 20\r\n                }}>\r\n                    {currentStream.toUpperCase()} {mainStream && !isFullscreen ? \"(STANDBY)\" : \"\"}\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}