{"ast":null,"code":"import Hls from'hls.js';import{PlayerStateMachine,PlayerEvents,PlayerStates}from'./PlayerStateMachine';export{PlayerStates};export default class PlaybackController{constructor(videoElement,camId,onStateChange){let baseUrl=arguments.length>3&&arguments[3]!==undefined?arguments[3]:'/api';this.video=videoElement;this.camId=camId;this.baseUrl=baseUrl;this.segments=[];this.hls=null;// --- 1. Initialize FSM ---\nthis.fsm=new PlayerStateMachine({onStateChange:(state,payload)=>{if(onStateChange)onStateChange(state,payload);},onAction:(action,payload)=>this._handleAction(action,payload)});// --- 2. Bind Video Events ---\nthis._bindVideoEvents();}_bindVideoEvents(){this.video.addEventListener('waiting',()=>{this.fsm.dispatch(PlayerEvents.BUFFER_EMPTY);});this.video.addEventListener('playing',()=>{this.fsm.dispatch(PlayerEvents.BUFFER_FULL);});// We handle Pause manually to avoid conflicts with Seek/Buffer logic\nthis.video.addEventListener('error',e=>{this.fsm.dispatch(PlayerEvents.ERROR,{error:e});});// Gap Detection Monitor\nthis.video.addEventListener('timeupdate',()=>this._checkGap());}destroy(){if(this.hls){this.hls.destroy();this.hls=null;}// Remove listeners if needed\n}// --- EXTERNAL PUBLIC API (Called by React UI) ---\nloadSegments(segments){// Validate & Sort\nthis.segments=(segments||[]).map(s=>({start:Number(s.start||s.start_ts||s.startTs),end:Number(s.end||s.end_ts||s.endTs),file:s.file})).sort((a,b)=>a.start-b.start);if(this.segments.length>0){// Signal FSM that metadata is ready\n// We initiate \"Load Playback\"\nthis.fsm.dispatch(PlayerEvents.LOAD_PLAYBACK,{camId:this.camId,segments:this.segments});// In our case, metadata is segments. Video track is ready when we select a segment.\n// For now, let's say Metadata is ready.\nthis.fsm.dispatch(PlayerEvents.METADATA_READY);// Auto-load first segment or wait?\n// User usually clicks timeline. Let's wait for user to Seek or Play.\n// But if we want to be \"READY\", we probably need a valid source.\n// However, we don't know WHERE to start yet.\n// Let's force READY state if we have segments, assuming user will Seek.\n// To do this cleanly, we can pretend video track is ready or just wait for seek.\n// Actually, we can dispatch VIDEO_TRACK_READY once the user actively seeks.\n// For now, let's leave it in LOADING or transition to READY manually?\n// The FSM says LOADING -> READY on VIDEO_TRACK_READY.\n// Let's assume we are conceptually READY since we have the timeline.\nthis.fsm.dispatch(PlayerEvents.VIDEO_TRACK_READY);}}seekTo(ts){this.fsm.dispatch(PlayerEvents.SEEK,{time:ts});}play(){this.fsm.dispatch(PlayerEvents.PLAY);}pause(){this.fsm.dispatch(PlayerEvents.PAUSE);}// --- INTERNAL ACTION HANDLERS (Driven by FSM) ---\n_handleAction(action,payload){console.log(\"[Controller] Executing Action: \".concat(action),payload);switch(action){case'initStream':// Handled in loadSegments largely\nbreak;case'play':this.video.play().catch(e=>console.warn(\"Play interrupted\",e));break;case'pause':this.video.pause();break;case'seek':this._performSeek(payload.time);break;case'skipGap':this._performSeek(payload.nextSegment.start);this.fsm.dispatch(PlayerEvents.GAP_RESOLVED);break;}}// --- LOGIC IMPLEMENTATION ---\n_performSeek(targetEpoch){console.log(\"[Controller] Seeking to \".concat(new Date(targetEpoch).toLocaleTimeString()));// 1. Find Segment\nconst segment=this.segments.find(s=>targetEpoch>=s.start&&targetEpoch<s.end);if(!segment){// Check for future segment (Gap)\nconst nextSeg=this.segments.find(s=>s.start>targetEpoch);if(nextSeg){console.log(\"[Controller] Gap Detected during Seek.\");// FSM handles the logic. We detect it, FSM dispatches GAP, then Action skipGap\n// But wait, we are INSIDE the action handler.\n// We should notify FSM about the Gap.\nthis.fsm.dispatch(PlayerEvents.GAP_DETECTED,{nextSegment:nextSeg});}else{console.log(\"[Controller] End of timeline.\");this.fsm.dispatch(PlayerEvents.END);}return;}// 2. Load HLS for specific slice\n// If we are already playing this segment/playlist, maybe just video.currentTime?\n// For Enterprise robustness, we reload the playlist at the specific timestamp \n// to ensure alignment, unless it's a small jump.\nconst playlistUrl=\"\".concat(this.baseUrl,\"/playback/playlist/\").concat(this.camId,\"/\").concat(segment.start,\".m3u8\");// Note: Backend must support /playlist/:cam/:startEpoch\n// Wait, standard route is different? \n// User provided logic implies we just need to load stream.\n// Let's use the one we had: /playback/playlist/:camId.m3u8?start=...\nconst realUrl=\"\".concat(this.baseUrl,\"/playback/playlist/\").concat(this.camId,\".m3u8?start=\").concat(targetEpoch,\"&end=\").concat(segment.end);if(this.hls){this.hls.destroy();}if(Hls.isSupported()){this.hls=new Hls();this.hls.loadSource(realUrl);this.hls.attachMedia(this.video);this.hls.on(Hls.Events.MANIFEST_PARSED,()=>{// If the backend generated a playlist starting exactly at targetEpoch,\n// then startPosition is 0.\nthis.video.currentTime=0;if(this.fsm.state===PlayerStates.PLAYING||this.fsm.state===PlayerStates.BUFFERING){this.video.play();}});this.hls.on(Hls.Events.FRAG_CHANGED,(e,data)=>{this._currentFragTime=data.frag.programDateTime;});}}_checkGap(){// Continuous check during playback\nif(!this.segments.length)return;// Estimate current epoch\n// Ideally HLS provides ProgramDateTime\nif(!this._currentFragTime)return;// Wait for HLS metadata\n// Calculate exact current epoch\n// simple approx for now assuming _currentFragTime is start of frag\n// this needs robustness, but let's rely on event based GAP from seek first\n// Monitor if we fell off a segment\n}getCurrentTime(){// Return best guess of epoch time for UI sync\nif(this.hls&&this._currentFragTime){// Refine this\nreturn this._currentFragTime+this.video.currentTime*1000%4000;// vague\n}return Date.now();// Fallback\n}}","map":{"version":3,"names":["Hls","PlayerStateMachine","PlayerEvents","PlayerStates","PlaybackController","constructor","videoElement","camId","onStateChange","baseUrl","arguments","length","undefined","video","segments","hls","fsm","state","payload","onAction","action","_handleAction","_bindVideoEvents","addEventListener","dispatch","BUFFER_EMPTY","BUFFER_FULL","e","ERROR","error","_checkGap","destroy","loadSegments","map","s","start","Number","start_ts","startTs","end","end_ts","endTs","file","sort","a","b","LOAD_PLAYBACK","METADATA_READY","VIDEO_TRACK_READY","seekTo","ts","SEEK","time","play","PLAY","pause","PAUSE","console","log","concat","catch","warn","_performSeek","nextSegment","GAP_RESOLVED","targetEpoch","Date","toLocaleTimeString","segment","find","nextSeg","GAP_DETECTED","END","playlistUrl","realUrl","isSupported","loadSource","attachMedia","on","Events","MANIFEST_PARSED","currentTime","PLAYING","BUFFERING","FRAG_CHANGED","data","_currentFragTime","frag","programDateTime","getCurrentTime","now"],"sources":["I:/dispecerat/github_release/dss-edge/local-ui/src/services/PlaybackController.js"],"sourcesContent":["import Hls from 'hls.js';\r\nimport { PlayerStateMachine, PlayerEvents, PlayerStates } from './PlayerStateMachine';\r\n\r\nexport { PlayerStates };\r\n\r\nexport default class PlaybackController {\r\n    constructor(videoElement, camId, onStateChange, baseUrl = '/api') {\r\n        this.video = videoElement;\r\n        this.camId = camId;\r\n        this.baseUrl = baseUrl;\r\n        this.segments = [];\r\n        this.hls = null;\r\n\r\n        // --- 1. Initialize FSM ---\r\n        this.fsm = new PlayerStateMachine({\r\n            onStateChange: (state, payload) => {\r\n                if (onStateChange) onStateChange(state, payload);\r\n            },\r\n            onAction: (action, payload) => this._handleAction(action, payload)\r\n        });\r\n\r\n        // --- 2. Bind Video Events ---\r\n        this._bindVideoEvents();\r\n    }\r\n\r\n    _bindVideoEvents() {\r\n        this.video.addEventListener('waiting', () => {\r\n            this.fsm.dispatch(PlayerEvents.BUFFER_EMPTY);\r\n        });\r\n        this.video.addEventListener('playing', () => {\r\n            this.fsm.dispatch(PlayerEvents.BUFFER_FULL);\r\n        });\r\n        // We handle Pause manually to avoid conflicts with Seek/Buffer logic\r\n        this.video.addEventListener('error', (e) => {\r\n            this.fsm.dispatch(PlayerEvents.ERROR, { error: e });\r\n        });\r\n\r\n        // Gap Detection Monitor\r\n        this.video.addEventListener('timeupdate', () => this._checkGap());\r\n    }\r\n\r\n    destroy() {\r\n        if (this.hls) {\r\n            this.hls.destroy();\r\n            this.hls = null;\r\n        }\r\n        // Remove listeners if needed\r\n    }\r\n\r\n    // --- EXTERNAL PUBLIC API (Called by React UI) ---\r\n\r\n    loadSegments(segments) {\r\n        // Validate & Sort\r\n        this.segments = (segments || []).map(s => ({\r\n            start: Number(s.start || s.start_ts || s.startTs),\r\n            end: Number(s.end || s.end_ts || s.endTs),\r\n            file: s.file\r\n        })).sort((a, b) => a.start - b.start);\r\n\r\n        if (this.segments.length > 0) {\r\n            // Signal FSM that metadata is ready\r\n            // We initiate \"Load Playback\"\r\n            this.fsm.dispatch(PlayerEvents.LOAD_PLAYBACK, { camId: this.camId, segments: this.segments });\r\n\r\n            // In our case, metadata is segments. Video track is ready when we select a segment.\r\n            // For now, let's say Metadata is ready.\r\n            this.fsm.dispatch(PlayerEvents.METADATA_READY);\r\n\r\n            // Auto-load first segment or wait?\r\n            // User usually clicks timeline. Let's wait for user to Seek or Play.\r\n            // But if we want to be \"READY\", we probably need a valid source.\r\n            // However, we don't know WHERE to start yet.\r\n            // Let's force READY state if we have segments, assuming user will Seek.\r\n            // To do this cleanly, we can pretend video track is ready or just wait for seek.\r\n            // Actually, we can dispatch VIDEO_TRACK_READY once the user actively seeks.\r\n            // For now, let's leave it in LOADING or transition to READY manually?\r\n            // The FSM says LOADING -> READY on VIDEO_TRACK_READY.\r\n            // Let's assume we are conceptually READY since we have the timeline.\r\n            this.fsm.dispatch(PlayerEvents.VIDEO_TRACK_READY);\r\n        }\r\n    }\r\n\r\n    seekTo(ts) {\r\n        this.fsm.dispatch(PlayerEvents.SEEK, { time: ts });\r\n    }\r\n\r\n    play() {\r\n        this.fsm.dispatch(PlayerEvents.PLAY);\r\n    }\r\n\r\n    pause() {\r\n        this.fsm.dispatch(PlayerEvents.PAUSE);\r\n    }\r\n\r\n    // --- INTERNAL ACTION HANDLERS (Driven by FSM) ---\r\n\r\n    _handleAction(action, payload) {\r\n        console.log(`[Controller] Executing Action: ${action}`, payload);\r\n\r\n        switch (action) {\r\n            case 'initStream':\r\n                // Handled in loadSegments largely\r\n                break;\r\n            case 'play':\r\n                this.video.play().catch(e => console.warn(\"Play interrupted\", e));\r\n                break;\r\n            case 'pause':\r\n                this.video.pause();\r\n                break;\r\n            case 'seek':\r\n                this._performSeek(payload.time);\r\n                break;\r\n            case 'skipGap':\r\n                this._performSeek(payload.nextSegment.start);\r\n                this.fsm.dispatch(PlayerEvents.GAP_RESOLVED);\r\n                break;\r\n        }\r\n    }\r\n\r\n    // --- LOGIC IMPLEMENTATION ---\r\n\r\n    _performSeek(targetEpoch) {\r\n        console.log(`[Controller] Seeking to ${new Date(targetEpoch).toLocaleTimeString()}`);\r\n\r\n        // 1. Find Segment\r\n        const segment = this.segments.find(s => targetEpoch >= s.start && targetEpoch < s.end);\r\n\r\n        if (!segment) {\r\n            // Check for future segment (Gap)\r\n            const nextSeg = this.segments.find(s => s.start > targetEpoch);\r\n            if (nextSeg) {\r\n                console.log(\"[Controller] Gap Detected during Seek.\");\r\n                // FSM handles the logic. We detect it, FSM dispatches GAP, then Action skipGap\r\n                // But wait, we are INSIDE the action handler.\r\n                // We should notify FSM about the Gap.\r\n                this.fsm.dispatch(PlayerEvents.GAP_DETECTED, { nextSegment: nextSeg });\r\n            } else {\r\n                console.log(\"[Controller] End of timeline.\");\r\n                this.fsm.dispatch(PlayerEvents.END);\r\n            }\r\n            return;\r\n        }\r\n\r\n        // 2. Load HLS for specific slice\r\n        // If we are already playing this segment/playlist, maybe just video.currentTime?\r\n        // For Enterprise robustness, we reload the playlist at the specific timestamp \r\n        // to ensure alignment, unless it's a small jump.\r\n\r\n        const playlistUrl = `${this.baseUrl}/playback/playlist/${this.camId}/${segment.start}.m3u8`;\r\n        // Note: Backend must support /playlist/:cam/:startEpoch\r\n\r\n        // Wait, standard route is different? \r\n        // User provided logic implies we just need to load stream.\r\n        // Let's use the one we had: /playback/playlist/:camId.m3u8?start=...\r\n\r\n        const realUrl = `${this.baseUrl}/playback/playlist/${this.camId}.m3u8?start=${targetEpoch}&end=${segment.end}`;\r\n\r\n        if (this.hls) {\r\n            this.hls.destroy();\r\n        }\r\n\r\n        if (Hls.isSupported()) {\r\n            this.hls = new Hls();\r\n            this.hls.loadSource(realUrl);\r\n            this.hls.attachMedia(this.video);\r\n\r\n            this.hls.on(Hls.Events.MANIFEST_PARSED, () => {\r\n                // If the backend generated a playlist starting exactly at targetEpoch,\r\n                // then startPosition is 0.\r\n                this.video.currentTime = 0;\r\n                if (this.fsm.state === PlayerStates.PLAYING || this.fsm.state === PlayerStates.BUFFERING) {\r\n                    this.video.play();\r\n                }\r\n            });\r\n\r\n            this.hls.on(Hls.Events.FRAG_CHANGED, (e, data) => {\r\n                this._currentFragTime = data.frag.programDateTime;\r\n            });\r\n        }\r\n    }\r\n\r\n    _checkGap() {\r\n        // Continuous check during playback\r\n        if (!this.segments.length) return;\r\n\r\n        // Estimate current epoch\r\n        // Ideally HLS provides ProgramDateTime\r\n        if (!this._currentFragTime) return; // Wait for HLS metadata\r\n\r\n        // Calculate exact current epoch\r\n        // simple approx for now assuming _currentFragTime is start of frag\r\n        // this needs robustness, but let's rely on event based GAP from seek first\r\n\r\n        // Monitor if we fell off a segment\r\n    }\r\n\r\n    getCurrentTime() {\r\n        // Return best guess of epoch time for UI sync\r\n        if (this.hls && this._currentFragTime) {\r\n            // Refine this\r\n            return this._currentFragTime + (this.video.currentTime * 1000) % 4000; // vague\r\n        }\r\n        return Date.now(); // Fallback\r\n    }\r\n\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}