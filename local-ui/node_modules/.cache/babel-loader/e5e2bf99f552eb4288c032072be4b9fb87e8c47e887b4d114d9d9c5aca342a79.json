{"ast":null,"code":"import Hls from'hls.js';export default class PlaybackCoreV2{constructor(videoElement,camId){let baseUrl=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'/api';this.video=videoElement;this.camId=camId;this.baseUrl=baseUrl;this.hls=null;this.currentFragPDT=0;this.currentFragStartPTS=0;}setSegments(segments){// Sort segments chronologically\nthis.segments=[...segments].sort((a,b)=>a.startTs-b.startTs);// Build Virtual Timeline Map to handle gaps\nthis.timeline=[];let virtualTime=0;for(const s of this.segments){const duration=s.endTs-s.startTs;this.timeline.push({realStart:s.startTs,realEnd:s.endTs,virtualStart:virtualTime,virtualEnd:virtualTime+duration,duration:duration});virtualTime+=duration;}this.totalDurationMs=virtualTime;console.log(\"[PlaybackCore] Timeline built: \".concat(this.segments.length,\" segments, Total virtual duration: \").concat(Math.round(virtualTime/1000),\"s\"));}start(startEpochMs){var _this$segments;if(this.hls){this.hls.destroy();this.hls=null;}// AUTO-SKIP GAPS: If start time is in a gap, jump to next available segment\nconst segment=(_this$segments=this.segments)===null||_this$segments===void 0?void 0:_this$segments.find(s=>startEpochMs>=s.startTs&&startEpochMs<=s.endTs);let actualStart=startEpochMs;if(!segment&&this.segments){const next=this.segments.find(s=>s.startTs>startEpochMs);if(next){console.log(\"[PlaybackCore] Seeking into gap. Jumping forward to \".concat(new Date(next.startTs).toLocaleTimeString()));actualStart=next.startTs;}}const playlistUrl=\"\".concat(this.baseUrl,\"/playback/playlist/\").concat(this.camId,\".m3u8?start=\").concat(actualStart,\"&end=\").concat(actualStart+60*60*1000);if(Hls.isSupported()){this.hls=new Hls({enableWorker:true,maxBufferLength:30,maxMaxBufferLength:60,backBufferLength:10});this.hls.loadSource(playlistUrl);this.hls.attachMedia(this.video);this.hls.on(Hls.Events.MANIFEST_PARSED,(event,data)=>{this.video.currentTime=data.levels[0].details.fragments[0].start;this.video.play().catch(e=>console.warn(\"Autoplay blocked\",e));});this.hls.on(Hls.Events.FRAG_CHANGED,(event,data)=>{if(data.frag&&data.frag.programDateTime){this.currentFragPDT=data.frag.programDateTime;this.currentFragStartPTS=data.frag.start;}});// GAP MONITORING\nthis.video.ontimeupdate=()=>{var _this$segments2;const currentEpoch=this.getCurrentEpochMs();if(!currentEpoch)return;// If we hit a gap (no segment covers current playback time), find next\nconst inSegment=(_this$segments2=this.segments)===null||_this$segments2===void 0?void 0:_this$segments2.some(s=>currentEpoch>=s.startTs&&currentEpoch<=s.endTs);if(!inSegment&&this.segments){const next=this.segments.find(s=>s.startTs>currentEpoch);if(next){console.log(\"[PlaybackCore] Gap detected during playback. Skipping...\");this.seekTo(next.startTs);}}};}else if(this.video.canPlayType('application/vnd.apple.mpegurl')){this.video.src=playlistUrl;}}epochToVideoTime(epochMs){if(!this.timeline)return 0;for(const t of this.timeline){if(epochMs>=t.realStart&&epochMs<=t.realEnd){return(t.virtualStart+(epochMs-t.realStart))/1000;}}return null;// Gap\n}seekTo(ts){this.start(ts);}getCurrentEpochMs(){if(this.currentFragPDT&&this.hls){const timeInFrag=this.video.currentTime-this.currentFragStartPTS;const absoluteTime=this.currentFragPDT+timeInFrag*1000;return absoluteTime;}return 0;}destroy(){if(this.hls){this.hls.destroy();this.hls=null;}this.video.ontimeupdate=null;}}","map":{"version":3,"names":["Hls","PlaybackCoreV2","constructor","videoElement","camId","baseUrl","arguments","length","undefined","video","hls","currentFragPDT","currentFragStartPTS","setSegments","segments","sort","a","b","startTs","timeline","virtualTime","s","duration","endTs","push","realStart","realEnd","virtualStart","virtualEnd","totalDurationMs","console","log","concat","Math","round","start","startEpochMs","_this$segments","destroy","segment","find","actualStart","next","Date","toLocaleTimeString","playlistUrl","isSupported","enableWorker","maxBufferLength","maxMaxBufferLength","backBufferLength","loadSource","attachMedia","on","Events","MANIFEST_PARSED","event","data","currentTime","levels","details","fragments","play","catch","e","warn","FRAG_CHANGED","frag","programDateTime","ontimeupdate","_this$segments2","currentEpoch","getCurrentEpochMs","inSegment","some","seekTo","canPlayType","src","epochToVideoTime","epochMs","t","ts","timeInFrag","absoluteTime"],"sources":["I:/dispecerat/github_release/dss-edge/local-ui/src/services/PlaybackCoreV2.js"],"sourcesContent":["import Hls from 'hls.js';\r\n\r\nexport default class PlaybackCoreV2 {\r\n    constructor(videoElement, camId, baseUrl = '/api') {\r\n        this.video = videoElement;\r\n        this.camId = camId;\r\n        this.baseUrl = baseUrl;\r\n        this.hls = null;\r\n        this.currentFragPDT = 0;\r\n        this.currentFragStartPTS = 0;\r\n    }\r\n\r\n    setSegments(segments) {\r\n        // Sort segments chronologically\r\n        this.segments = [...segments].sort((a, b) => a.startTs - b.startTs);\r\n\r\n        // Build Virtual Timeline Map to handle gaps\r\n        this.timeline = [];\r\n        let virtualTime = 0;\r\n\r\n        for (const s of this.segments) {\r\n            const duration = s.endTs - s.startTs;\r\n            this.timeline.push({\r\n                realStart: s.startTs,\r\n                realEnd: s.endTs,\r\n                virtualStart: virtualTime,\r\n                virtualEnd: virtualTime + duration,\r\n                duration: duration\r\n            });\r\n            virtualTime += duration;\r\n        }\r\n\r\n        this.totalDurationMs = virtualTime;\r\n        console.log(`[PlaybackCore] Timeline built: ${this.segments.length} segments, Total virtual duration: ${Math.round(virtualTime / 1000)}s`);\r\n    }\r\n\r\n    start(startEpochMs) {\r\n        if (this.hls) {\r\n            this.hls.destroy();\r\n            this.hls = null;\r\n        }\r\n\r\n        // AUTO-SKIP GAPS: If start time is in a gap, jump to next available segment\r\n        const segment = this.segments?.find(s => startEpochMs >= s.startTs && startEpochMs <= s.endTs);\r\n        let actualStart = startEpochMs;\r\n\r\n        if (!segment && this.segments) {\r\n            const next = this.segments.find(s => s.startTs > startEpochMs);\r\n            if (next) {\r\n                console.log(`[PlaybackCore] Seeking into gap. Jumping forward to ${new Date(next.startTs).toLocaleTimeString()}`);\r\n                actualStart = next.startTs;\r\n            }\r\n        }\r\n\r\n        const playlistUrl = `${this.baseUrl}/playback/playlist/${this.camId}.m3u8?start=${actualStart}&end=${actualStart + 60 * 60 * 1000}`;\r\n\r\n        if (Hls.isSupported()) {\r\n            this.hls = new Hls({\r\n                enableWorker: true,\r\n                maxBufferLength: 30,\r\n                maxMaxBufferLength: 60,\r\n                backBufferLength: 10,\r\n            });\r\n\r\n            this.hls.loadSource(playlistUrl);\r\n            this.hls.attachMedia(this.video);\r\n\r\n            this.hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {\r\n                this.video.currentTime = data.levels[0].details.fragments[0].start;\r\n                this.video.play().catch(e => console.warn(\"Autoplay blocked\", e));\r\n            });\r\n\r\n            this.hls.on(Hls.Events.FRAG_CHANGED, (event, data) => {\r\n                if (data.frag && data.frag.programDateTime) {\r\n                    this.currentFragPDT = data.frag.programDateTime;\r\n                    this.currentFragStartPTS = data.frag.start;\r\n                }\r\n            });\r\n\r\n            // GAP MONITORING\r\n            this.video.ontimeupdate = () => {\r\n                const currentEpoch = this.getCurrentEpochMs();\r\n                if (!currentEpoch) return;\r\n\r\n                // If we hit a gap (no segment covers current playback time), find next\r\n                const inSegment = this.segments?.some(s => currentEpoch >= s.startTs && currentEpoch <= s.endTs);\r\n                if (!inSegment && this.segments) {\r\n                    const next = this.segments.find(s => s.startTs > currentEpoch);\r\n                    if (next) {\r\n                        console.log(\"[PlaybackCore] Gap detected during playback. Skipping...\");\r\n                        this.seekTo(next.startTs);\r\n                    }\r\n                }\r\n            };\r\n        } else if (this.video.canPlayType('application/vnd.apple.mpegurl')) {\r\n            this.video.src = playlistUrl;\r\n        }\r\n    }\r\n\r\n    epochToVideoTime(epochMs) {\r\n        if (!this.timeline) return 0;\r\n        for (const t of this.timeline) {\r\n            if (epochMs >= t.realStart && epochMs <= t.realEnd) {\r\n                return (t.virtualStart + (epochMs - t.realStart)) / 1000;\r\n            }\r\n        }\r\n        return null; // Gap\r\n    }\r\n\r\n    seekTo(ts) {\r\n        this.start(ts);\r\n    }\r\n\r\n    getCurrentEpochMs() {\r\n        if (this.currentFragPDT && this.hls) {\r\n            const timeInFrag = this.video.currentTime - this.currentFragStartPTS;\r\n            const absoluteTime = this.currentFragPDT + (timeInFrag * 1000);\r\n            return absoluteTime;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    destroy() {\r\n        if (this.hls) {\r\n            this.hls.destroy();\r\n            this.hls = null;\r\n        }\r\n        this.video.ontimeupdate = null;\r\n    }\r\n}\r\n"],"mappings":"AAAA,MAAO,CAAAA,GAAG,KAAM,QAAQ,CAExB,cAAe,MAAM,CAAAC,cAAe,CAChCC,WAAWA,CAACC,YAAY,CAAEC,KAAK,CAAoB,IAAlB,CAAAC,OAAO,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,MAAM,CAC7C,IAAI,CAACG,KAAK,CAAGN,YAAY,CACzB,IAAI,CAACC,KAAK,CAAGA,KAAK,CAClB,IAAI,CAACC,OAAO,CAAGA,OAAO,CACtB,IAAI,CAACK,GAAG,CAAG,IAAI,CACf,IAAI,CAACC,cAAc,CAAG,CAAC,CACvB,IAAI,CAACC,mBAAmB,CAAG,CAAC,CAChC,CAEAC,WAAWA,CAACC,QAAQ,CAAE,CAClB;AACA,IAAI,CAACA,QAAQ,CAAG,CAAC,GAAGA,QAAQ,CAAC,CAACC,IAAI,CAAC,CAACC,CAAC,CAAEC,CAAC,GAAKD,CAAC,CAACE,OAAO,CAAGD,CAAC,CAACC,OAAO,CAAC,CAEnE;AACA,IAAI,CAACC,QAAQ,CAAG,EAAE,CAClB,GAAI,CAAAC,WAAW,CAAG,CAAC,CAEnB,IAAK,KAAM,CAAAC,CAAC,GAAI,KAAI,CAACP,QAAQ,CAAE,CAC3B,KAAM,CAAAQ,QAAQ,CAAGD,CAAC,CAACE,KAAK,CAAGF,CAAC,CAACH,OAAO,CACpC,IAAI,CAACC,QAAQ,CAACK,IAAI,CAAC,CACfC,SAAS,CAAEJ,CAAC,CAACH,OAAO,CACpBQ,OAAO,CAAEL,CAAC,CAACE,KAAK,CAChBI,YAAY,CAAEP,WAAW,CACzBQ,UAAU,CAAER,WAAW,CAAGE,QAAQ,CAClCA,QAAQ,CAAEA,QACd,CAAC,CAAC,CACFF,WAAW,EAAIE,QAAQ,CAC3B,CAEA,IAAI,CAACO,eAAe,CAAGT,WAAW,CAClCU,OAAO,CAACC,GAAG,mCAAAC,MAAA,CAAmC,IAAI,CAAClB,QAAQ,CAACP,MAAM,wCAAAyB,MAAA,CAAsCC,IAAI,CAACC,KAAK,CAACd,WAAW,CAAG,IAAI,CAAC,KAAG,CAAC,CAC9I,CAEAe,KAAKA,CAACC,YAAY,CAAE,KAAAC,cAAA,CAChB,GAAI,IAAI,CAAC3B,GAAG,CAAE,CACV,IAAI,CAACA,GAAG,CAAC4B,OAAO,CAAC,CAAC,CAClB,IAAI,CAAC5B,GAAG,CAAG,IAAI,CACnB,CAEA;AACA,KAAM,CAAA6B,OAAO,EAAAF,cAAA,CAAG,IAAI,CAACvB,QAAQ,UAAAuB,cAAA,iBAAbA,cAAA,CAAeG,IAAI,CAACnB,CAAC,EAAIe,YAAY,EAAIf,CAAC,CAACH,OAAO,EAAIkB,YAAY,EAAIf,CAAC,CAACE,KAAK,CAAC,CAC9F,GAAI,CAAAkB,WAAW,CAAGL,YAAY,CAE9B,GAAI,CAACG,OAAO,EAAI,IAAI,CAACzB,QAAQ,CAAE,CAC3B,KAAM,CAAA4B,IAAI,CAAG,IAAI,CAAC5B,QAAQ,CAAC0B,IAAI,CAACnB,CAAC,EAAIA,CAAC,CAACH,OAAO,CAAGkB,YAAY,CAAC,CAC9D,GAAIM,IAAI,CAAE,CACNZ,OAAO,CAACC,GAAG,wDAAAC,MAAA,CAAwD,GAAI,CAAAW,IAAI,CAACD,IAAI,CAACxB,OAAO,CAAC,CAAC0B,kBAAkB,CAAC,CAAC,CAAE,CAAC,CACjHH,WAAW,CAAGC,IAAI,CAACxB,OAAO,CAC9B,CACJ,CAEA,KAAM,CAAA2B,WAAW,IAAAb,MAAA,CAAM,IAAI,CAAC3B,OAAO,wBAAA2B,MAAA,CAAsB,IAAI,CAAC5B,KAAK,iBAAA4B,MAAA,CAAeS,WAAW,UAAAT,MAAA,CAAQS,WAAW,CAAG,EAAE,CAAG,EAAE,CAAG,IAAI,CAAE,CAEnI,GAAIzC,GAAG,CAAC8C,WAAW,CAAC,CAAC,CAAE,CACnB,IAAI,CAACpC,GAAG,CAAG,GAAI,CAAAV,GAAG,CAAC,CACf+C,YAAY,CAAE,IAAI,CAClBC,eAAe,CAAE,EAAE,CACnBC,kBAAkB,CAAE,EAAE,CACtBC,gBAAgB,CAAE,EACtB,CAAC,CAAC,CAEF,IAAI,CAACxC,GAAG,CAACyC,UAAU,CAACN,WAAW,CAAC,CAChC,IAAI,CAACnC,GAAG,CAAC0C,WAAW,CAAC,IAAI,CAAC3C,KAAK,CAAC,CAEhC,IAAI,CAACC,GAAG,CAAC2C,EAAE,CAACrD,GAAG,CAACsD,MAAM,CAACC,eAAe,CAAE,CAACC,KAAK,CAAEC,IAAI,GAAK,CACrD,IAAI,CAAChD,KAAK,CAACiD,WAAW,CAAGD,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC,CAACC,OAAO,CAACC,SAAS,CAAC,CAAC,CAAC,CAAC1B,KAAK,CAClE,IAAI,CAAC1B,KAAK,CAACqD,IAAI,CAAC,CAAC,CAACC,KAAK,CAACC,CAAC,EAAIlC,OAAO,CAACmC,IAAI,CAAC,kBAAkB,CAAED,CAAC,CAAC,CAAC,CACrE,CAAC,CAAC,CAEF,IAAI,CAACtD,GAAG,CAAC2C,EAAE,CAACrD,GAAG,CAACsD,MAAM,CAACY,YAAY,CAAE,CAACV,KAAK,CAAEC,IAAI,GAAK,CAClD,GAAIA,IAAI,CAACU,IAAI,EAAIV,IAAI,CAACU,IAAI,CAACC,eAAe,CAAE,CACxC,IAAI,CAACzD,cAAc,CAAG8C,IAAI,CAACU,IAAI,CAACC,eAAe,CAC/C,IAAI,CAACxD,mBAAmB,CAAG6C,IAAI,CAACU,IAAI,CAAChC,KAAK,CAC9C,CACJ,CAAC,CAAC,CAEF;AACA,IAAI,CAAC1B,KAAK,CAAC4D,YAAY,CAAG,IAAM,KAAAC,eAAA,CAC5B,KAAM,CAAAC,YAAY,CAAG,IAAI,CAACC,iBAAiB,CAAC,CAAC,CAC7C,GAAI,CAACD,YAAY,CAAE,OAEnB;AACA,KAAM,CAAAE,SAAS,EAAAH,eAAA,CAAG,IAAI,CAACxD,QAAQ,UAAAwD,eAAA,iBAAbA,eAAA,CAAeI,IAAI,CAACrD,CAAC,EAAIkD,YAAY,EAAIlD,CAAC,CAACH,OAAO,EAAIqD,YAAY,EAAIlD,CAAC,CAACE,KAAK,CAAC,CAChG,GAAI,CAACkD,SAAS,EAAI,IAAI,CAAC3D,QAAQ,CAAE,CAC7B,KAAM,CAAA4B,IAAI,CAAG,IAAI,CAAC5B,QAAQ,CAAC0B,IAAI,CAACnB,CAAC,EAAIA,CAAC,CAACH,OAAO,CAAGqD,YAAY,CAAC,CAC9D,GAAI7B,IAAI,CAAE,CACNZ,OAAO,CAACC,GAAG,CAAC,0DAA0D,CAAC,CACvE,IAAI,CAAC4C,MAAM,CAACjC,IAAI,CAACxB,OAAO,CAAC,CAC7B,CACJ,CACJ,CAAC,CACL,CAAC,IAAM,IAAI,IAAI,CAACT,KAAK,CAACmE,WAAW,CAAC,+BAA+B,CAAC,CAAE,CAChE,IAAI,CAACnE,KAAK,CAACoE,GAAG,CAAGhC,WAAW,CAChC,CACJ,CAEAiC,gBAAgBA,CAACC,OAAO,CAAE,CACtB,GAAI,CAAC,IAAI,CAAC5D,QAAQ,CAAE,MAAO,EAAC,CAC5B,IAAK,KAAM,CAAA6D,CAAC,GAAI,KAAI,CAAC7D,QAAQ,CAAE,CAC3B,GAAI4D,OAAO,EAAIC,CAAC,CAACvD,SAAS,EAAIsD,OAAO,EAAIC,CAAC,CAACtD,OAAO,CAAE,CAChD,MAAO,CAACsD,CAAC,CAACrD,YAAY,EAAIoD,OAAO,CAAGC,CAAC,CAACvD,SAAS,CAAC,EAAI,IAAI,CAC5D,CACJ,CACA,MAAO,KAAI,CAAE;AACjB,CAEAkD,MAAMA,CAACM,EAAE,CAAE,CACP,IAAI,CAAC9C,KAAK,CAAC8C,EAAE,CAAC,CAClB,CAEAT,iBAAiBA,CAAA,CAAG,CAChB,GAAI,IAAI,CAAC7D,cAAc,EAAI,IAAI,CAACD,GAAG,CAAE,CACjC,KAAM,CAAAwE,UAAU,CAAG,IAAI,CAACzE,KAAK,CAACiD,WAAW,CAAG,IAAI,CAAC9C,mBAAmB,CACpE,KAAM,CAAAuE,YAAY,CAAG,IAAI,CAACxE,cAAc,CAAIuE,UAAU,CAAG,IAAK,CAC9D,MAAO,CAAAC,YAAY,CACvB,CACA,MAAO,EAAC,CACZ,CAEA7C,OAAOA,CAAA,CAAG,CACN,GAAI,IAAI,CAAC5B,GAAG,CAAE,CACV,IAAI,CAACA,GAAG,CAAC4B,OAAO,CAAC,CAAC,CAClB,IAAI,CAAC5B,GAAG,CAAG,IAAI,CACnB,CACA,IAAI,CAACD,KAAK,CAAC4D,YAAY,CAAG,IAAI,CAClC,CACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}