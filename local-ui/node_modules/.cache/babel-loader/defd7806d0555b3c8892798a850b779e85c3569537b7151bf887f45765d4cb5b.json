{"ast":null,"code":"export default class PlaybackCoreV2{constructor(videoElement,camId){let baseUrl=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'/api';this.video=videoElement;this.camId=camId;this.baseUrl=baseUrl;this.mediaSource=null;this.sourceBuffer=null;this.SEGMENT_SEC=6;// CORE STATE\nthis.nextFetchTs=null;this.segments=[];this.timeMap=[];// BUFFERS\nthis.chunkQueue=[];// Ordered Queue\nthis.fetchedSet=new Set();// Avoid Dupa\nthis.MAX_QUEUE_SIZE=10;// 60s Buffer in RAM\nthis.CONCURRENCY=2;// Fetch 2 at once\n// FLAGS\nthis.isPlaying=false;this.isDestroyed=false;this.abortController=null;this.stallInterval=null;}setSegments(segments){this.segments=(segments||[]).map(s=>({start_ts:Number(s.start_ts),end_ts:s.end_ts===0?Date.now():Number(s.end_ts)})).sort((a,b)=>a.start_ts-b.start_ts);console.log(\"[MSE] Map Updated: \".concat(this.segments.length,\" segments.\"));}start(startEpochMs){console.log(\"[PlaybackStart] Req: \".concat(new Date(startEpochMs).toLocaleTimeString()));this.destroy();// Clean old\nthis.isDestroyed=false;const validStart=this.getNextPlayableTs(startEpochMs-1000);this.nextFetchTs=validStart||startEpochMs;this.mediaSource=new MediaSource();this.video.src=URL.createObjectURL(this.mediaSource);this.video.playbackRate=1.0;this.mediaSource.addEventListener('sourceopen',this.onSourceOpen.bind(this));this.stallInterval=setInterval(this.monitorStall.bind(this),500);// Start Parallel Producers\nfor(let i=0;i<this.CONCURRENCY;i++){this.producerLoop(i);}this.consumerLoop();}destroy(){this.isDestroyed=true;this.isPlaying=false;if(this.stallInterval)clearInterval(this.stallInterval);if(this.abortController)this.abortController.abort();if(this.video){this.video.pause();this.video.removeAttribute('src');this.video.load();}this.mediaSource=null;this.sourceBuffer=null;this.chunkQueue=[];this.timeMap=[];this.fetchedSet=new Set();this.nextFetchTs=null;}onSourceOpen(){if(this.sourceBuffer||this.mediaSource.readyState!=='open')return;const codecs=['video/mp4; codecs=\"avc1.4d401e\"','video/mp4; codecs=\"avc1.64001f\"'];for(const codec of codecs){if(MediaSource.isTypeSupported(codec)){try{this.sourceBuffer=this.mediaSource.addSourceBuffer(codec);this.sourceBuffer.mode='segments';return;}catch(e){}}}}// --- PRODUCER WORKER ---\nasync producerLoop(id){while(!this.isDestroyed){if(this.chunkQueue.length>=this.MAX_QUEUE_SIZE){await this.sleep(200);continue;}if(!this.nextFetchTs){await this.sleep(200);continue;}// ATOMIC CLAIM: Get TS and increment immediately\nconst ts=this.nextFetchTs;this.nextFetchTs=this.getNextPlayableTs(ts);// Pre-advance global pointer\nif(this.fetchedSet.has(ts))continue;this.fetchedSet.add(ts);// console.log(`[Prod ${id}] Downloading ${ts}...`);\nconst chunk=await this.downloadSegment(ts);if(this.isDestroyed)return;if(chunk){this.chunkQueue.push({data:chunk,ts:ts});// Re-sort Queue by TS (Parallel fetch may finish unordered)\nthis.chunkQueue.sort((a,b)=>a.ts-b.ts);}else{// Failed/Gap. Already advanced nextFetchTs so loop continues.\n}}}async downloadSegment(ts){const url=\"\".concat(this.baseUrl,\"/playback/segment/\").concat(this.camId,\"?ts=\").concat(ts,\"&dur=\").concat(this.SEGMENT_SEC);try{// No global abort controller for parallel requests unless destroy\nconst res=await fetch(url);if(!res.ok){if(res.status===404)this.removeFromMap(ts);return null;}return await res.arrayBuffer();}catch(e){return null;}}// --- CONSUMER ---\nasync consumerLoop(){while(!this.isDestroyed){if(!this.sourceBuffer||this.sourceBuffer.updating||this.chunkQueue.length===0){await this.sleep(50);continue;}// Peek oldest. Is it contigous with buffer?\n// Actually, we trust the Queue is Sorted.\nconst item=this.chunkQueue.shift();this.fetchedSet.delete(item.ts);// Allow re-fetch if we seek back later\ntry{const startBuf=this.getBufferedEnd();this.timeMap.push({v:startBuf,t:item.ts});this.timeMap=this.timeMap.slice(-50);await this.appendBuffer(item.data);if(!this.isPlaying&&this.video.paused){const buffLen=this.getBufferedEnd()-this.video.currentTime;if(buffLen>0.5){try{if(this.video.buffered.length>0){const start=this.video.buffered.start(0);if(this.video.currentTime<start)this.video.currentTime=start+0.05;}await this.video.play();this.isPlaying=true;}catch(e){}}}}catch(e){console.warn(\"[Consumer] Append Warn (Quota?)\",e);if(this.video.currentTime>30){try{this.sourceBuffer.remove(0,this.video.currentTime-10);}catch(err){}}}}}appendBuffer(buffer){return new Promise(resolve=>{if(!this.sourceBuffer)return resolve();const onEnd=()=>{this.sourceBuffer.removeEventListener('updateend',onEnd);resolve();};this.sourceBuffer.addEventListener('updateend',onEnd);try{this.sourceBuffer.appendBuffer(buffer);}catch(e){this.sourceBuffer.removeEventListener('updateend',onEnd);resolve();}});}monitorStall(){if(!this.video||this.video.paused)return;const ct=this.video.currentTime;const buffered=this.video.buffered;let jumpTo=null;for(let i=0;i<buffered.length;i++){const end=buffered.end(i);if(ct>end-0.5&&ct<end+0.5){if(i+1<buffered.length){jumpTo=buffered.start(i+1)+0.1;}}}if(jumpTo){console.warn(\"[Stall] Jumping \".concat(ct.toFixed(1),\" -> \").concat(jumpTo.toFixed(1)));this.video.currentTime=jumpTo;}}getNextPlayableTs(currentTs){const target=currentTs+this.SEGMENT_SEC*1000;if(this.segments.length>0){const valid=this.segments.find(s=>target>=s.start_ts&&target<s.end_ts);if(valid)return target;const next=this.segments.find(s=>s.start_ts>currentTs);return next?next.start_ts:null;}else{return target;}}removeFromMap(ts){if(this.segments.length===0)return;const idx=this.segments.findIndex(s=>ts>=s.start_ts&&ts<s.end_ts);if(idx!==-1){this.segments.splice(idx,1);}}getBufferedEnd(){if(!this.video||!this.video.buffered||this.video.buffered.length===0)return 0;return this.video.buffered.end(this.video.buffered.length-1);}getCurrentEpochMs(){if(this.chunkQueue.length===0&&!this.isPlaying)return 0;const ct=this.video.currentTime;for(let i=this.timeMap.length-1;i>=0;i--){const m=this.timeMap[i];if(ct>=m.v)return m.t+(ct-m.v)*1000;}return 0;}sleep(ms){return new Promise(r=>setTimeout(r,ms));}async seekTo(ts){console.log('[Seek] ',new Date(ts).toLocaleTimeString());this.nextFetchTs=null;// Stop producers\nthis.isDestroyed=true;await this.sleep(100);this.isDestroyed=false;this.chunkQueue=[];this.fetchedSet.clear();this.timeMap=[];this.nextFetchTs=this.getNextPlayableTs(ts-1000)||ts;if(this.sourceBuffer&&!this.sourceBuffer.updating&&this.mediaSource.readyState==='open'){try{const ranges=this.video.buffered;if(ranges.length){this.sourceBuffer.remove(ranges.start(0),ranges.end(ranges.length-1));await new Promise(r=>this.sourceBuffer.addEventListener('updateend',r,{once:true}));}}catch(e){}}this.video.currentTime=0;this.isPlaying=false;// Restart Loops\nfor(let i=0;i<this.CONCURRENCY;i++)this.producerLoop(i);this.consumerLoop();}}","map":{"version":3,"names":["PlaybackCoreV2","constructor","videoElement","camId","baseUrl","arguments","length","undefined","video","mediaSource","sourceBuffer","SEGMENT_SEC","nextFetchTs","segments","timeMap","chunkQueue","fetchedSet","Set","MAX_QUEUE_SIZE","CONCURRENCY","isPlaying","isDestroyed","abortController","stallInterval","setSegments","map","s","start_ts","Number","end_ts","Date","now","sort","a","b","console","log","concat","start","startEpochMs","toLocaleTimeString","destroy","validStart","getNextPlayableTs","MediaSource","src","URL","createObjectURL","playbackRate","addEventListener","onSourceOpen","bind","setInterval","monitorStall","i","producerLoop","consumerLoop","clearInterval","abort","pause","removeAttribute","load","readyState","codecs","codec","isTypeSupported","addSourceBuffer","mode","e","id","sleep","ts","has","add","chunk","downloadSegment","push","data","url","res","fetch","ok","status","removeFromMap","arrayBuffer","updating","item","shift","delete","startBuf","getBufferedEnd","v","t","slice","appendBuffer","paused","buffLen","currentTime","buffered","play","warn","remove","err","buffer","Promise","resolve","onEnd","removeEventListener","ct","jumpTo","end","toFixed","currentTs","target","valid","find","next","idx","findIndex","splice","getCurrentEpochMs","m","ms","r","setTimeout","seekTo","clear","ranges","once"],"sources":["I:/dispecerat/github_release/dss-edge/local-ui/src/services/PlaybackCoreV2.js"],"sourcesContent":["export default class PlaybackCoreV2 {\r\n    constructor(videoElement, camId, baseUrl = '/api') {\r\n        this.video = videoElement;\r\n        this.camId = camId;\r\n        this.baseUrl = baseUrl;\r\n\r\n        this.mediaSource = null;\r\n        this.sourceBuffer = null;\r\n\r\n        this.SEGMENT_SEC = 6;\r\n\r\n        // CORE STATE\r\n        this.nextFetchTs = null;\r\n        this.segments = [];\r\n        this.timeMap = [];\r\n\r\n        // BUFFERS\r\n        this.chunkQueue = []; // Ordered Queue\r\n        this.fetchedSet = new Set(); // Avoid Dupa\r\n\r\n        this.MAX_QUEUE_SIZE = 10; // 60s Buffer in RAM\r\n        this.CONCURRENCY = 2; // Fetch 2 at once\r\n\r\n        // FLAGS\r\n        this.isPlaying = false;\r\n        this.isDestroyed = false;\r\n\r\n        this.abortController = null;\r\n        this.stallInterval = null;\r\n    }\r\n\r\n    setSegments(segments) {\r\n        this.segments = (segments || []).map(s => ({\r\n            start_ts: Number(s.start_ts),\r\n            end_ts: s.end_ts === 0 ? Date.now() : Number(s.end_ts)\r\n        })).sort((a, b) => a.start_ts - b.start_ts);\r\n        console.log(`[MSE] Map Updated: ${this.segments.length} segments.`);\r\n    }\r\n\r\n    start(startEpochMs) {\r\n        console.log(`[PlaybackStart] Req: ${new Date(startEpochMs).toLocaleTimeString()}`);\r\n        this.destroy(); // Clean old\r\n        this.isDestroyed = false;\r\n\r\n        const validStart = this.getNextPlayableTs(startEpochMs - 1000);\r\n        this.nextFetchTs = validStart || startEpochMs;\r\n\r\n        this.mediaSource = new MediaSource();\r\n        this.video.src = URL.createObjectURL(this.mediaSource);\r\n        this.video.playbackRate = 1.0;\r\n        this.mediaSource.addEventListener('sourceopen', this.onSourceOpen.bind(this));\r\n\r\n        this.stallInterval = setInterval(this.monitorStall.bind(this), 500);\r\n\r\n        // Start Parallel Producers\r\n        for (let i = 0; i < this.CONCURRENCY; i++) {\r\n            this.producerLoop(i);\r\n        }\r\n        this.consumerLoop();\r\n    }\r\n\r\n    destroy() {\r\n        this.isDestroyed = true;\r\n        this.isPlaying = false;\r\n        if (this.stallInterval) clearInterval(this.stallInterval);\r\n        if (this.abortController) this.abortController.abort();\r\n        if (this.video) {\r\n            this.video.pause();\r\n            this.video.removeAttribute('src');\r\n            this.video.load();\r\n        }\r\n        this.mediaSource = null;\r\n        this.sourceBuffer = null;\r\n        this.chunkQueue = [];\r\n        this.timeMap = [];\r\n        this.fetchedSet = new Set();\r\n        this.nextFetchTs = null;\r\n    }\r\n\r\n    onSourceOpen() {\r\n        if (this.sourceBuffer || this.mediaSource.readyState !== 'open') return;\r\n        const codecs = ['video/mp4; codecs=\"avc1.4d401e\"', 'video/mp4; codecs=\"avc1.64001f\"'];\r\n        for (const codec of codecs) {\r\n            if (MediaSource.isTypeSupported(codec)) {\r\n                try {\r\n                    this.sourceBuffer = this.mediaSource.addSourceBuffer(codec);\r\n                    this.sourceBuffer.mode = 'segments';\r\n                    return;\r\n                } catch (e) { }\r\n            }\r\n        }\r\n    }\r\n\r\n    // --- PRODUCER WORKER ---\r\n    async producerLoop(id) {\r\n        while (!this.isDestroyed) {\r\n            if (this.chunkQueue.length >= this.MAX_QUEUE_SIZE) {\r\n                await this.sleep(200);\r\n                continue;\r\n            }\r\n\r\n            if (!this.nextFetchTs) {\r\n                await this.sleep(200);\r\n                continue;\r\n            }\r\n\r\n            // ATOMIC CLAIM: Get TS and increment immediately\r\n            const ts = this.nextFetchTs;\r\n            this.nextFetchTs = this.getNextPlayableTs(ts); // Pre-advance global pointer\r\n\r\n            if (this.fetchedSet.has(ts)) continue;\r\n            this.fetchedSet.add(ts);\r\n\r\n            // console.log(`[Prod ${id}] Downloading ${ts}...`);\r\n            const chunk = await this.downloadSegment(ts);\r\n\r\n            if (this.isDestroyed) return;\r\n\r\n            if (chunk) {\r\n                this.chunkQueue.push({ data: chunk, ts: ts });\r\n                // Re-sort Queue by TS (Parallel fetch may finish unordered)\r\n                this.chunkQueue.sort((a, b) => a.ts - b.ts);\r\n            } else {\r\n                // Failed/Gap. Already advanced nextFetchTs so loop continues.\r\n            }\r\n        }\r\n    }\r\n\r\n    async downloadSegment(ts) {\r\n        const url = `${this.baseUrl}/playback/segment/${this.camId}?ts=${ts}&dur=${this.SEGMENT_SEC}`;\r\n        try {\r\n            // No global abort controller for parallel requests unless destroy\r\n            const res = await fetch(url);\r\n            if (!res.ok) {\r\n                if (res.status === 404) this.removeFromMap(ts);\r\n                return null;\r\n            }\r\n            return await res.arrayBuffer();\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // --- CONSUMER ---\r\n    async consumerLoop() {\r\n        while (!this.isDestroyed) {\r\n            if (!this.sourceBuffer || this.sourceBuffer.updating || this.chunkQueue.length === 0) {\r\n                await this.sleep(50);\r\n                continue;\r\n            }\r\n\r\n            // Peek oldest. Is it contigous with buffer?\r\n            // Actually, we trust the Queue is Sorted.\r\n            const item = this.chunkQueue.shift();\r\n            this.fetchedSet.delete(item.ts); // Allow re-fetch if we seek back later\r\n\r\n            try {\r\n                const startBuf = this.getBufferedEnd();\r\n                this.timeMap.push({ v: startBuf, t: item.ts });\r\n                this.timeMap = this.timeMap.slice(-50);\r\n\r\n                await this.appendBuffer(item.data);\r\n\r\n                if (!this.isPlaying && this.video.paused) {\r\n                    const buffLen = this.getBufferedEnd() - this.video.currentTime;\r\n                    if (buffLen > 0.5) {\r\n                        try {\r\n                            if (this.video.buffered.length > 0) {\r\n                                const start = this.video.buffered.start(0);\r\n                                if (this.video.currentTime < start) this.video.currentTime = start + 0.05;\r\n                            }\r\n                            await this.video.play();\r\n                            this.isPlaying = true;\r\n                        } catch (e) { }\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                console.warn(\"[Consumer] Append Warn (Quota?)\", e);\r\n                if (this.video.currentTime > 30) {\r\n                    try { this.sourceBuffer.remove(0, this.video.currentTime - 10); } catch (err) { }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    appendBuffer(buffer) {\r\n        return new Promise(resolve => {\r\n            if (!this.sourceBuffer) return resolve();\r\n            const onEnd = () => {\r\n                this.sourceBuffer.removeEventListener('updateend', onEnd);\r\n                resolve();\r\n            };\r\n            this.sourceBuffer.addEventListener('updateend', onEnd);\r\n            try { this.sourceBuffer.appendBuffer(buffer); } catch (e) {\r\n                this.sourceBuffer.removeEventListener('updateend', onEnd);\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    monitorStall() {\r\n        if (!this.video || this.video.paused) return;\r\n        const ct = this.video.currentTime;\r\n        const buffered = this.video.buffered;\r\n\r\n        let jumpTo = null;\r\n        for (let i = 0; i < buffered.length; i++) {\r\n            const end = buffered.end(i);\r\n            if (ct > end - 0.5 && ct < end + 0.5) {\r\n                if (i + 1 < buffered.length) {\r\n                    jumpTo = buffered.start(i + 1) + 0.1;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (jumpTo) {\r\n            console.warn(`[Stall] Jumping ${ct.toFixed(1)} -> ${jumpTo.toFixed(1)}`);\r\n            this.video.currentTime = jumpTo;\r\n        }\r\n    }\r\n\r\n    getNextPlayableTs(currentTs) {\r\n        const target = currentTs + (this.SEGMENT_SEC * 1000);\r\n        if (this.segments.length > 0) {\r\n            const valid = this.segments.find(s => target >= s.start_ts && target < s.end_ts);\r\n            if (valid) return target;\r\n            const next = this.segments.find(s => s.start_ts > currentTs);\r\n            return next ? next.start_ts : null;\r\n        } else {\r\n            return target;\r\n        }\r\n    }\r\n\r\n    removeFromMap(ts) {\r\n        if (this.segments.length === 0) return;\r\n        const idx = this.segments.findIndex(s => ts >= s.start_ts && ts < s.end_ts);\r\n        if (idx !== -1) {\r\n            this.segments.splice(idx, 1);\r\n        }\r\n    }\r\n\r\n    getBufferedEnd() {\r\n        if (!this.video || !this.video.buffered || this.video.buffered.length === 0) return 0;\r\n        return this.video.buffered.end(this.video.buffered.length - 1);\r\n    }\r\n\r\n    getCurrentEpochMs() {\r\n        if (this.chunkQueue.length === 0 && !this.isPlaying) return 0;\r\n        const ct = this.video.currentTime;\r\n        for (let i = this.timeMap.length - 1; i >= 0; i--) {\r\n            const m = this.timeMap[i];\r\n            if (ct >= m.v) return m.t + ((ct - m.v) * 1000);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    sleep(ms) { return new Promise(r => setTimeout(r, ms)); }\r\n\r\n    async seekTo(ts) {\r\n        console.log('[Seek] ', new Date(ts).toLocaleTimeString());\r\n\r\n        this.nextFetchTs = null; // Stop producers\r\n\r\n        this.isDestroyed = true;\r\n        await this.sleep(100);\r\n        this.isDestroyed = false;\r\n\r\n        this.chunkQueue = [];\r\n        this.fetchedSet.clear();\r\n        this.timeMap = [];\r\n\r\n        this.nextFetchTs = this.getNextPlayableTs(ts - 1000) || ts;\r\n\r\n        if (this.sourceBuffer && !this.sourceBuffer.updating && this.mediaSource.readyState === 'open') {\r\n            try {\r\n                const ranges = this.video.buffered;\r\n                if (ranges.length) {\r\n                    this.sourceBuffer.remove(ranges.start(0), ranges.end(ranges.length - 1));\r\n                    await new Promise(r => this.sourceBuffer.addEventListener('updateend', r, { once: true }));\r\n                }\r\n            } catch (e) { }\r\n        }\r\n\r\n        this.video.currentTime = 0;\r\n        this.isPlaying = false;\r\n\r\n        // Restart Loops\r\n        for (let i = 0; i < this.CONCURRENCY; i++) this.producerLoop(i);\r\n        this.consumerLoop();\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}