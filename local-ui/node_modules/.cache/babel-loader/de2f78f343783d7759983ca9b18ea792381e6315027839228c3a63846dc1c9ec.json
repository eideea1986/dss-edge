{"ast":null,"code":"import Hls from 'hls.js';\n\n/**\r\n * Enterprise Player State Machine\r\n * \r\n * Defines distinct states for a deterministic playback experience.\r\n */\nexport const PlayerState = {\n  IDLE: 'IDLE',\n  READY: 'READY',\n  BUFFERING: 'BUFFERING',\n  PLAYING: 'PLAYING',\n  PAUSED: 'PAUSED',\n  SEEKING: 'SEEKING',\n  WAITING_FOR_SEGMENT: 'WAITING_FOR_SEGMENT',\n  ERROR: 'ERROR'\n};\nexport default class PlayerStateMachine {\n  constructor(videoElement, camId, onStateChange, baseUrl = '/api') {\n    this.video = videoElement;\n    this.camId = camId;\n    this.baseUrl = baseUrl;\n    this.onStateChange = onStateChange || (() => {});\n    this.state = PlayerState.IDLE;\n    this.segments = [];\n    this.hls = null;\n\n    // Internal tracking\n    this.currentSegment = null;\n    this.initialSeekDone = false;\n\n    // Bind video events\n    this._bindEvents();\n  }\n  _bindEvents() {\n    if (!this.video) return;\n    this.video.addEventListener('waiting', () => {\n      if (this.state !== PlayerState.SEEKING) this._transition(PlayerState.BUFFERING);\n    });\n    this.video.addEventListener('playing', () => this._transition(PlayerState.PLAYING));\n    this.video.addEventListener('pause', () => {\n      if (this.state !== PlayerState.SEEKING) this._transition(PlayerState.PAUSED);\n    });\n    this.video.addEventListener('error', e => this._handleError(e));\n  }\n  _transition(newState) {\n    if (this.state === newState) return;\n    console.log(`[PlayerSM] ${this.state} -> ${newState}`);\n    this.state = newState;\n    this.onStateChange(this.state);\n  }\n  _handleError(e) {\n    console.error(\"[PlayerSM] Video Error:\", e);\n    this._transition(PlayerState.ERROR);\n  }\n  destroy() {\n    if (this.hls) {\n      this.hls.destroy();\n      this.hls = null;\n    }\n    // Remove event listeners if needed (usually handled by React unmount)\n  }\n\n  /**\r\n   * LOAD DATA: Accepts raw segments, ensures sorting and validity.\r\n   */\n  loadSegments(segments) {\n    if (!Array.isArray(segments)) {\n      console.warn(\"[PlayerSM] Invalid segments data\");\n      return;\n    }\n\n    // Normalize & Sort\n    this.segments = segments.map(s => ({\n      start: Number(s.start || s.start_ts || s.startTs),\n      end: Number(s.end || s.end_ts || s.endTs),\n      file: s.file\n    })).sort((a, b) => a.start - b.start);\n    console.log(`[PlayerSM] Loaded ${this.segments.length} segments.`);\n    this._transition(this.segments.length > 0 ? PlayerState.READY : PlayerState.IDLE);\n  }\n\n  /**\r\n   * SEEK LOGIC: The core of the \"Enterprise\" experience.\r\n   * Handles Gaps, Snapping, and HLS Manifest requests.\r\n   */\n  async seekTo(targetEpochMs, autoPlay = true) {\n    this._transition(PlayerState.SEEKING);\n\n    // 1. Find relevant segment\n    // Strategy: If inside a segment, use it. If in gap, jump to NEXT segment start.\n    let targetSegment = this.segments.find(s => targetEpochMs >= s.start && targetEpochMs < s.end);\n    let playStartEpoch = targetEpochMs;\n    if (!targetSegment) {\n      // Gap handling\n      const nextSegment = this.segments.find(s => s.start > targetEpochMs);\n      if (nextSegment) {\n        console.log(`[PlayerSM] Seek in GAP (${new Date(targetEpochMs).toLocaleTimeString()}). Jumping to ${new Date(nextSegment.start).toLocaleTimeString()}`);\n        targetSegment = nextSegment;\n        playStartEpoch = nextSegment.start;\n      } else {\n        console.warn(\"[PlayerSM] Seek beyond last segment.\");\n        this._transition(PlayerState.IDLE);\n        return;\n      }\n    }\n    this.currentSegment = targetSegment;\n\n    // 2. Load Stream (HLS)\n    // We request a playlist starting from the EXACT calculated epoch\n    // The backend handles slicing the file or generating the m3u8.\n    const playlistUrl = `${this.baseUrl}/playback/playlist/${this.camId}/${playStartEpoch}`;\n    this._loadHls(playlistUrl, playStartEpoch);\n    if (autoPlay) {\n      try {\n        await this.video.play();\n      } catch (e) {\n        console.warn(\"Autoplay blocked/failed\", e);\n        this._transition(PlayerState.PAUSED);\n      }\n    }\n  }\n  _loadHls(url, startEpoch) {\n    if (this.hls) {\n      this.hls.destroy();\n    }\n    if (Hls.isSupported()) {\n      this.hls = new Hls({\n        enableWorker: true,\n        maxBufferLength: 30,\n        // 30s buffer for stability\n        startPosition: 0 // We trust the generic playlist to start at 0 relative to request\n      });\n      this.hls.loadSource(url);\n      this.hls.attachMedia(this.video);\n      this.hls.on(Hls.Events.MANIFEST_PARSED, () => {\n        console.log(\"[PlayerSM] Manifest parsed, starting playback...\");\n        // Note: We don't force video.currentTime here because the new manifest \n        // should start at t=0 relative to the slice.\n      });\n      this.hls.on(Hls.Events.ERROR, (e, data) => {\n        if (data.fatal) {\n          console.error(\"[PlayerSM] HLS Fatal:\", data);\n          this.hls.destroy();\n          this._transition(PlayerState.ERROR);\n        }\n      });\n\n      // Track playback time\n      this.hls.on(Hls.Events.FRAG_CHANGED, (e, data) => {\n        // Update internal reference for getTime()\n        if (data.frag) {\n          this._currentFragTime = data.frag.programDateTime || startEpoch + this.video.currentTime * 1000;\n        }\n      });\n    } else if (this.video.canPlayType('application/vnd.apple.mpegurl')) {\n      // Safari\n      this.video.src = url;\n    }\n  }\n  getCurrentTime() {\n    // Estimate current epoch based on video time\n    // Requires precise start epoch of the currently loaded playlist\n    if (!this.currentSegment) return Date.now();\n\n    // Basic approximation if program-date-time is missing\n    // Ideally we track the 'playlistStart' we requested in seekTo\n    // Let's improve this later if needed.\n    return Date.now();\n    // NOTE: This needs fixing for UI sync, but for core playback logic it's secondary.\n  }\n  play() {\n    this.video.play();\n  }\n  pause() {\n    this.video.pause();\n  }\n}","map":{"version":3,"names":["Hls","PlayerState","IDLE","READY","BUFFERING","PLAYING","PAUSED","SEEKING","WAITING_FOR_SEGMENT","ERROR","PlayerStateMachine","constructor","videoElement","camId","onStateChange","baseUrl","video","state","segments","hls","currentSegment","initialSeekDone","_bindEvents","addEventListener","_transition","e","_handleError","newState","console","log","error","destroy","loadSegments","Array","isArray","warn","map","s","start","Number","start_ts","startTs","end","end_ts","endTs","file","sort","a","b","length","seekTo","targetEpochMs","autoPlay","targetSegment","find","playStartEpoch","nextSegment","Date","toLocaleTimeString","playlistUrl","_loadHls","play","url","startEpoch","isSupported","enableWorker","maxBufferLength","startPosition","loadSource","attachMedia","on","Events","MANIFEST_PARSED","data","fatal","FRAG_CHANGED","frag","_currentFragTime","programDateTime","currentTime","canPlayType","src","getCurrentTime","now","pause"],"sources":["I:/dispecerat/github_release/dss-edge/local-ui/src/services/PlayerStateMachine.js"],"sourcesContent":["import Hls from 'hls.js';\r\n\r\n/**\r\n * Enterprise Player State Machine\r\n * \r\n * Defines distinct states for a deterministic playback experience.\r\n */\r\nexport const PlayerState = {\r\n    IDLE: 'IDLE',\r\n    READY: 'READY',\r\n    BUFFERING: 'BUFFERING',\r\n    PLAYING: 'PLAYING',\r\n    PAUSED: 'PAUSED',\r\n    SEEKING: 'SEEKING',\r\n    WAITING_FOR_SEGMENT: 'WAITING_FOR_SEGMENT',\r\n    ERROR: 'ERROR'\r\n};\r\n\r\nexport default class PlayerStateMachine {\r\n    constructor(videoElement, camId, onStateChange, baseUrl = '/api') {\r\n        this.video = videoElement;\r\n        this.camId = camId;\r\n        this.baseUrl = baseUrl;\r\n        this.onStateChange = onStateChange || (() => { });\r\n\r\n        this.state = PlayerState.IDLE;\r\n        this.segments = [];\r\n        this.hls = null;\r\n\r\n        // Internal tracking\r\n        this.currentSegment = null;\r\n        this.initialSeekDone = false;\r\n\r\n        // Bind video events\r\n        this._bindEvents();\r\n    }\r\n\r\n    _bindEvents() {\r\n        if (!this.video) return;\r\n        this.video.addEventListener('waiting', () => {\r\n            if (this.state !== PlayerState.SEEKING) this._transition(PlayerState.BUFFERING);\r\n        });\r\n        this.video.addEventListener('playing', () => this._transition(PlayerState.PLAYING));\r\n        this.video.addEventListener('pause', () => {\r\n            if (this.state !== PlayerState.SEEKING) this._transition(PlayerState.PAUSED);\r\n        });\r\n        this.video.addEventListener('error', (e) => this._handleError(e));\r\n    }\r\n\r\n    _transition(newState) {\r\n        if (this.state === newState) return;\r\n        console.log(`[PlayerSM] ${this.state} -> ${newState}`);\r\n        this.state = newState;\r\n        this.onStateChange(this.state);\r\n    }\r\n\r\n    _handleError(e) {\r\n        console.error(\"[PlayerSM] Video Error:\", e);\r\n        this._transition(PlayerState.ERROR);\r\n    }\r\n\r\n    destroy() {\r\n        if (this.hls) {\r\n            this.hls.destroy();\r\n            this.hls = null;\r\n        }\r\n        // Remove event listeners if needed (usually handled by React unmount)\r\n    }\r\n\r\n    /**\r\n     * LOAD DATA: Accepts raw segments, ensures sorting and validity.\r\n     */\r\n    loadSegments(segments) {\r\n        if (!Array.isArray(segments)) {\r\n            console.warn(\"[PlayerSM] Invalid segments data\");\r\n            return;\r\n        }\r\n\r\n        // Normalize & Sort\r\n        this.segments = segments.map(s => ({\r\n            start: Number(s.start || s.start_ts || s.startTs),\r\n            end: Number(s.end || s.end_ts || s.endTs),\r\n            file: s.file\r\n        })).sort((a, b) => a.start - b.start);\r\n\r\n        console.log(`[PlayerSM] Loaded ${this.segments.length} segments.`);\r\n        this._transition(this.segments.length > 0 ? PlayerState.READY : PlayerState.IDLE);\r\n    }\r\n\r\n    /**\r\n     * SEEK LOGIC: The core of the \"Enterprise\" experience.\r\n     * Handles Gaps, Snapping, and HLS Manifest requests.\r\n     */\r\n    async seekTo(targetEpochMs, autoPlay = true) {\r\n        this._transition(PlayerState.SEEKING);\r\n\r\n        // 1. Find relevant segment\r\n        // Strategy: If inside a segment, use it. If in gap, jump to NEXT segment start.\r\n        let targetSegment = this.segments.find(s => targetEpochMs >= s.start && targetEpochMs < s.end);\r\n        let playStartEpoch = targetEpochMs;\r\n\r\n        if (!targetSegment) {\r\n            // Gap handling\r\n            const nextSegment = this.segments.find(s => s.start > targetEpochMs);\r\n            if (nextSegment) {\r\n                console.log(`[PlayerSM] Seek in GAP (${new Date(targetEpochMs).toLocaleTimeString()}). Jumping to ${new Date(nextSegment.start).toLocaleTimeString()}`);\r\n                targetSegment = nextSegment;\r\n                playStartEpoch = nextSegment.start;\r\n            } else {\r\n                console.warn(\"[PlayerSM] Seek beyond last segment.\");\r\n                this._transition(PlayerState.IDLE);\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.currentSegment = targetSegment;\r\n\r\n        // 2. Load Stream (HLS)\r\n        // We request a playlist starting from the EXACT calculated epoch\r\n        // The backend handles slicing the file or generating the m3u8.\r\n        const playlistUrl = `${this.baseUrl}/playback/playlist/${this.camId}/${playStartEpoch}`;\r\n\r\n        this._loadHls(playlistUrl, playStartEpoch);\r\n\r\n        if (autoPlay) {\r\n            try {\r\n                await this.video.play();\r\n            } catch (e) {\r\n                console.warn(\"Autoplay blocked/failed\", e);\r\n                this._transition(PlayerState.PAUSED);\r\n            }\r\n        }\r\n    }\r\n\r\n    _loadHls(url, startEpoch) {\r\n        if (this.hls) {\r\n            this.hls.destroy();\r\n        }\r\n\r\n        if (Hls.isSupported()) {\r\n            this.hls = new Hls({\r\n                enableWorker: true,\r\n                maxBufferLength: 30, // 30s buffer for stability\r\n                startPosition: 0 // We trust the generic playlist to start at 0 relative to request\r\n            });\r\n\r\n            this.hls.loadSource(url);\r\n            this.hls.attachMedia(this.video);\r\n\r\n            this.hls.on(Hls.Events.MANIFEST_PARSED, () => {\r\n                console.log(\"[PlayerSM] Manifest parsed, starting playback...\");\r\n                // Note: We don't force video.currentTime here because the new manifest \r\n                // should start at t=0 relative to the slice.\r\n            });\r\n\r\n            this.hls.on(Hls.Events.ERROR, (e, data) => {\r\n                if (data.fatal) {\r\n                    console.error(\"[PlayerSM] HLS Fatal:\", data);\r\n                    this.hls.destroy();\r\n                    this._transition(PlayerState.ERROR);\r\n                }\r\n            });\r\n\r\n            // Track playback time\r\n            this.hls.on(Hls.Events.FRAG_CHANGED, (e, data) => {\r\n                // Update internal reference for getTime()\r\n                if (data.frag) {\r\n                    this._currentFragTime = data.frag.programDateTime || (startEpoch + (this.video.currentTime * 1000));\r\n                }\r\n            });\r\n\r\n        } else if (this.video.canPlayType('application/vnd.apple.mpegurl')) {\r\n            // Safari\r\n            this.video.src = url;\r\n        }\r\n    }\r\n\r\n    getCurrentTime() {\r\n        // Estimate current epoch based on video time\r\n        // Requires precise start epoch of the currently loaded playlist\r\n        if (!this.currentSegment) return Date.now();\r\n\r\n        // Basic approximation if program-date-time is missing\r\n        // Ideally we track the 'playlistStart' we requested in seekTo\r\n        // Let's improve this later if needed.\r\n        return Date.now();\r\n        // NOTE: This needs fixing for UI sync, but for core playback logic it's secondary.\r\n    }\r\n\r\n    play() { this.video.play(); }\r\n    pause() { this.video.pause(); }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}