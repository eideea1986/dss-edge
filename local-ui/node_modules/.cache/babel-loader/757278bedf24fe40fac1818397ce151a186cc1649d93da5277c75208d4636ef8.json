{"ast":null,"code":"export default class PlaybackCoreV2{constructor(videoElement,camId){let baseUrl=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'/api';this.video=videoElement;this.camId=camId;this.baseUrl=baseUrl;this.mediaSource=null;this.sourceBuffer=null;this.SEGMENT_SEC=6;this.TARGET_BUFFER=20;this.nextTs=null;this.segments=[];// NEW: Timeline Knowledge\nthis.isFetching=false;this.started=false;this.isSeeking=false;this.ensureInterval=null;this.stallInterval=null;this.abortController=null;}// NEW: Receive Segments from UI\nsetSegments(segments){// Ensure sorted and numerical\nthis.segments=(segments||[]).map(s=>({start_ts:Number(s.start_ts),end_ts:s.end_ts===0?Date.now():Number(s.end_ts)})).sort((a,b)=>a.start_ts-b.start_ts);console.log(\"[MSE] Core received \".concat(this.segments.length,\" segments map for smart seeking.\"));}start(startEpochMs){console.log(\"[PlaybackCore] Starting at \".concat(new Date(startEpochMs).toLocaleTimeString()));// Smart Snap: If startEpochMs is in a gap, jump to next valid\nconst validStart=this.getNextPlayableTs(startEpochMs-1000);this.nextTs=validStart||startEpochMs;this.isSeeking=false;this.started=false;if(this.mediaSource)this.destroy();this.mediaSource=new MediaSource();this.video.src=URL.createObjectURL(this.mediaSource);this.video.playbackRate=1.0;this.mediaSource.addEventListener('sourceopen',this.onSourceOpen.bind(this));if(this.ensureInterval)clearInterval(this.ensureInterval);this.ensureInterval=setInterval(this.ensureBuffer.bind(this),500);if(this.stallInterval)clearInterval(this.stallInterval);this.stallInterval=setInterval(this.monitorStall.bind(this),1000);}destroy(){if(this.ensureInterval)clearInterval(this.ensureInterval);if(this.stallInterval)clearInterval(this.stallInterval);if(this.abortController)this.abortController.abort();if(this.video){this.video.pause();this.video.removeAttribute('src');this.video.load();}this.mediaSource=null;this.sourceBuffer=null;}onSourceOpen(){if(this.sourceBuffer||this.mediaSource.readyState!=='open')return;const codecs=['video/mp4; codecs=\"avc1.4d401e\"','video/mp4; codecs=\"avc1.64001f\"'];for(const codec of codecs){if(MediaSource.isTypeSupported(codec)){try{this.sourceBuffer=this.mediaSource.addSourceBuffer(codec);this.sourceBuffer.mode='segments';return;}catch(e){}}}}async ensureBuffer(){if(this.isSeeking)return;if(!this.sourceBuffer||this.sourceBuffer.updating)return;if(this.isFetching||this.nextTs===null)return;if(this.mediaSource.readyState!=='open')return;const current=this.video.currentTime||0;const bufferedEnd=this.getBufferedEnd();if(!this.started||bufferedEnd-current<this.TARGET_BUFFER){this.isFetching=true;await this.fetchAndAppend(this.nextTs);this.isFetching=false;}}// INTELLIGENT NEXT TS CALCULATION\ngetNextPlayableTs(currentTs){if(!this.segments||this.segments.length===0)return currentTs+this.SEGMENT_SEC*1000;// 1. Is target inside a valid segment?\nconst target=currentTs+this.SEGMENT_SEC*1000;const inSegment=this.segments.find(s=>target>=s.start_ts&&target<s.end_ts);if(inSegment)return target;// 2. If not, find the very next segment start\nconst nextSeg=this.segments.find(s=>s.start_ts>currentTs);if(nextSeg){console.log(\"[MSE] Jumping GAP: \".concat(new Date(currentTs).toLocaleTimeString(),\" -> \").concat(new Date(nextSeg.start_ts).toLocaleTimeString()));return nextSeg.start_ts;}return null;// End of timeline\n}async fetchAndAppend(ts){if(this.isSeeking)return;const url=\"\".concat(this.baseUrl,\"/playback/segment/\").concat(this.camId,\"?ts=\").concat(ts,\"&dur=\").concat(this.SEGMENT_SEC);try{this.abortController=new AbortController();const tm=setTimeout(()=>this.abortController.abort(),8000);const res=await fetch(url,{signal:this.abortController.signal});clearTimeout(tm);if(!res.ok){// If 404 (file missing despite timeline saying yes), skip to next logic\nif(res.status===404){// Force re-calculation from current point to jump over this bad spot\nthis.nextTs=this.getNextPlayableTs(ts);}return;}const buf=await res.arrayBuffer();if(this.isSeeking)return;if(buf.byteLength>0){await this.appendBuffer(buf);if(!this.started&&!this.isSeeking){const end=this.getBufferedEnd();if(end>0.5)try{await this.video.play();this.started=true;}catch(e){}}}// SMART ADVANCE: Always ask \"Where do I go next?\"\nthis.nextTs=this.getNextPlayableTs(ts);}catch(e){if(e.name!=='AbortError')console.error(\"[MSE] Fetch Error:\",e);}finally{this.abortController=null;}}appendBuffer(buffer){return new Promise(resolve=>{if(!this.sourceBuffer||this.mediaSource.readyState!=='open')return resolve();const onUpdateEnd=()=>{this.sourceBuffer.removeEventListener('updateend',onUpdateEnd);resolve();};this.sourceBuffer.addEventListener('updateend',onUpdateEnd);try{this.sourceBuffer.appendBuffer(buffer);}catch(e){this.sourceBuffer.removeEventListener('updateend',onUpdateEnd);resolve();}});}getBufferedEnd(){if(!this.video||!this.video.buffered||this.video.buffered.length===0)return 0;return this.video.buffered.end(this.video.buffered.length-1);}monitorStall(){if(!this.video||this.video.paused||this.isSeeking)return;const ct=this.video.currentTime;const buffered=this.video.buffered;if(buffered.length===0)return;// Gap Jump Logic\nfor(let i=0;i<buffered.length;i++){const end=buffered.end(i);if(Math.abs(end-ct)<0.5){if(i+1<buffered.length){const nextStart=buffered.start(i+1);if(nextStart-end<3.0){this.video.currentTime=nextStart+0.1;return;}}}}}async seekTo(epochMs){if(!this.mediaSource||!this.sourceBuffer)return;console.log('[MSE] SEEK',new Date(epochMs).toLocaleTimeString());this.isSeeking=true;this.video.pause();if(this.abortController)this.abortController.abort();this.isFetching=false;if(this.sourceBuffer.updating){await new Promise(r=>this.sourceBuffer.addEventListener('updateend',r,{once:true}));}try{const ranges=this.video.buffered;if(ranges.length>0){this.sourceBuffer.remove(ranges.start(0),ranges.end(ranges.length-1));await new Promise(r=>this.sourceBuffer.addEventListener('updateend',r,{once:true}));}}catch(e){}this.video.currentTime=0;// Update 4: Snap seek to valid segment if clicked in black\nconst validStart=this.getNextPlayableTs(epochMs-1000);this.nextTs=validStart||epochMs;this.started=false;this.isSeeking=false;}getCurrentEpochMs(){if(!this.started||!this.nextTs)return this.nextTs||0;const bufferedDuration=this.getBufferedEnd();const playheadPos=this.video.currentTime;return this.nextTs-Math.max(0,bufferedDuration-playheadPos)*1000;}}","map":{"version":3,"names":["PlaybackCoreV2","constructor","videoElement","camId","baseUrl","arguments","length","undefined","video","mediaSource","sourceBuffer","SEGMENT_SEC","TARGET_BUFFER","nextTs","segments","isFetching","started","isSeeking","ensureInterval","stallInterval","abortController","setSegments","map","s","start_ts","Number","end_ts","Date","now","sort","a","b","console","log","concat","start","startEpochMs","toLocaleTimeString","validStart","getNextPlayableTs","destroy","MediaSource","src","URL","createObjectURL","playbackRate","addEventListener","onSourceOpen","bind","clearInterval","setInterval","ensureBuffer","monitorStall","abort","pause","removeAttribute","load","readyState","codecs","codec","isTypeSupported","addSourceBuffer","mode","e","updating","current","currentTime","bufferedEnd","getBufferedEnd","fetchAndAppend","currentTs","target","inSegment","find","nextSeg","ts","url","AbortController","tm","setTimeout","res","fetch","signal","clearTimeout","ok","status","buf","arrayBuffer","byteLength","appendBuffer","end","play","name","error","buffer","Promise","resolve","onUpdateEnd","removeEventListener","buffered","paused","ct","i","Math","abs","nextStart","seekTo","epochMs","r","once","ranges","remove","getCurrentEpochMs","bufferedDuration","playheadPos","max"],"sources":["I:/dispecerat/github_release/dss-edge/local-ui/src/services/PlaybackCoreV2.js"],"sourcesContent":["export default class PlaybackCoreV2 {\r\n    constructor(videoElement, camId, baseUrl = '/api') {\r\n        this.video = videoElement;\r\n        this.camId = camId;\r\n        this.baseUrl = baseUrl;\r\n\r\n        this.mediaSource = null;\r\n        this.sourceBuffer = null;\r\n\r\n        this.SEGMENT_SEC = 6;\r\n        this.TARGET_BUFFER = 20;\r\n\r\n        this.nextTs = null;\r\n        this.segments = []; // NEW: Timeline Knowledge\r\n\r\n        this.isFetching = false;\r\n        this.started = false;\r\n        this.isSeeking = false;\r\n\r\n        this.ensureInterval = null;\r\n        this.stallInterval = null;\r\n        this.abortController = null;\r\n    }\r\n\r\n    // NEW: Receive Segments from UI\r\n    setSegments(segments) {\r\n        // Ensure sorted and numerical\r\n        this.segments = (segments || []).map(s => ({\r\n            start_ts: Number(s.start_ts),\r\n            end_ts: s.end_ts === 0 ? Date.now() : Number(s.end_ts)\r\n        })).sort((a, b) => a.start_ts - b.start_ts);\r\n\r\n        console.log(`[MSE] Core received ${this.segments.length} segments map for smart seeking.`);\r\n    }\r\n\r\n    start(startEpochMs) {\r\n        console.log(`[PlaybackCore] Starting at ${new Date(startEpochMs).toLocaleTimeString()}`);\r\n\r\n        // Smart Snap: If startEpochMs is in a gap, jump to next valid\r\n        const validStart = this.getNextPlayableTs(startEpochMs - 1000);\r\n        this.nextTs = validStart || startEpochMs;\r\n\r\n        this.isSeeking = false;\r\n        this.started = false;\r\n\r\n        if (this.mediaSource) this.destroy();\r\n\r\n        this.mediaSource = new MediaSource();\r\n        this.video.src = URL.createObjectURL(this.mediaSource);\r\n        this.video.playbackRate = 1.0;\r\n\r\n        this.mediaSource.addEventListener('sourceopen', this.onSourceOpen.bind(this));\r\n\r\n        if (this.ensureInterval) clearInterval(this.ensureInterval);\r\n        this.ensureInterval = setInterval(this.ensureBuffer.bind(this), 500);\r\n\r\n        if (this.stallInterval) clearInterval(this.stallInterval);\r\n        this.stallInterval = setInterval(this.monitorStall.bind(this), 1000);\r\n    }\r\n\r\n    destroy() {\r\n        if (this.ensureInterval) clearInterval(this.ensureInterval);\r\n        if (this.stallInterval) clearInterval(this.stallInterval);\r\n        if (this.abortController) this.abortController.abort();\r\n        if (this.video) {\r\n            this.video.pause();\r\n            this.video.removeAttribute('src');\r\n            this.video.load();\r\n        }\r\n        this.mediaSource = null;\r\n        this.sourceBuffer = null;\r\n    }\r\n\r\n    onSourceOpen() {\r\n        if (this.sourceBuffer || this.mediaSource.readyState !== 'open') return;\r\n        const codecs = ['video/mp4; codecs=\"avc1.4d401e\"', 'video/mp4; codecs=\"avc1.64001f\"'];\r\n        for (const codec of codecs) {\r\n            if (MediaSource.isTypeSupported(codec)) {\r\n                try {\r\n                    this.sourceBuffer = this.mediaSource.addSourceBuffer(codec);\r\n                    this.sourceBuffer.mode = 'segments';\r\n                    return;\r\n                } catch (e) { }\r\n            }\r\n        }\r\n    }\r\n\r\n    async ensureBuffer() {\r\n        if (this.isSeeking) return;\r\n        if (!this.sourceBuffer || this.sourceBuffer.updating) return;\r\n        if (this.isFetching || this.nextTs === null) return;\r\n        if (this.mediaSource.readyState !== 'open') return;\r\n\r\n        const current = this.video.currentTime || 0;\r\n        const bufferedEnd = this.getBufferedEnd();\r\n\r\n        if (!this.started || (bufferedEnd - current) < this.TARGET_BUFFER) {\r\n            this.isFetching = true;\r\n            await this.fetchAndAppend(this.nextTs);\r\n            this.isFetching = false;\r\n        }\r\n    }\r\n\r\n    // INTELLIGENT NEXT TS CALCULATION\r\n    getNextPlayableTs(currentTs) {\r\n        if (!this.segments || this.segments.length === 0) return currentTs + (this.SEGMENT_SEC * 1000);\r\n\r\n        // 1. Is target inside a valid segment?\r\n        const target = currentTs + (this.SEGMENT_SEC * 1000);\r\n        const inSegment = this.segments.find(s => target >= s.start_ts && target < s.end_ts);\r\n\r\n        if (inSegment) return target;\r\n\r\n        // 2. If not, find the very next segment start\r\n        const nextSeg = this.segments.find(s => s.start_ts > currentTs);\r\n\r\n        if (nextSeg) {\r\n            console.log(`[MSE] Jumping GAP: ${new Date(currentTs).toLocaleTimeString()} -> ${new Date(nextSeg.start_ts).toLocaleTimeString()}`);\r\n            return nextSeg.start_ts;\r\n        }\r\n\r\n        return null; // End of timeline\r\n    }\r\n\r\n    async fetchAndAppend(ts) {\r\n        if (this.isSeeking) return;\r\n\r\n        const url = `${this.baseUrl}/playback/segment/${this.camId}?ts=${ts}&dur=${this.SEGMENT_SEC}`;\r\n\r\n        try {\r\n            this.abortController = new AbortController();\r\n            const tm = setTimeout(() => this.abortController.abort(), 8000);\r\n            const res = await fetch(url, { signal: this.abortController.signal });\r\n            clearTimeout(tm);\r\n\r\n            if (!res.ok) {\r\n                // If 404 (file missing despite timeline saying yes), skip to next logic\r\n                if (res.status === 404) {\r\n                    // Force re-calculation from current point to jump over this bad spot\r\n                    this.nextTs = this.getNextPlayableTs(ts);\r\n                }\r\n                return;\r\n            }\r\n\r\n            const buf = await res.arrayBuffer();\r\n            if (this.isSeeking) return;\r\n\r\n            if (buf.byteLength > 0) {\r\n                await this.appendBuffer(buf);\r\n                if (!this.started && !this.isSeeking) {\r\n                    const end = this.getBufferedEnd();\r\n                    if (end > 0.5) try { await this.video.play(); this.started = true; } catch (e) { }\r\n                }\r\n            }\r\n\r\n            // SMART ADVANCE: Always ask \"Where do I go next?\"\r\n            this.nextTs = this.getNextPlayableTs(ts);\r\n\r\n        } catch (e) {\r\n            if (e.name !== 'AbortError') console.error(\"[MSE] Fetch Error:\", e);\r\n        } finally {\r\n            this.abortController = null;\r\n        }\r\n    }\r\n\r\n    appendBuffer(buffer) {\r\n        return new Promise(resolve => {\r\n            if (!this.sourceBuffer || this.mediaSource.readyState !== 'open') return resolve();\r\n            const onUpdateEnd = () => {\r\n                this.sourceBuffer.removeEventListener('updateend', onUpdateEnd);\r\n                resolve();\r\n            };\r\n            this.sourceBuffer.addEventListener('updateend', onUpdateEnd);\r\n            try { this.sourceBuffer.appendBuffer(buffer); }\r\n            catch (e) { this.sourceBuffer.removeEventListener('updateend', onUpdateEnd); resolve(); }\r\n        });\r\n    }\r\n\r\n    getBufferedEnd() {\r\n        if (!this.video || !this.video.buffered || this.video.buffered.length === 0) return 0;\r\n        return this.video.buffered.end(this.video.buffered.length - 1);\r\n    }\r\n\r\n    monitorStall() {\r\n        if (!this.video || this.video.paused || this.isSeeking) return;\r\n\r\n        const ct = this.video.currentTime;\r\n        const buffered = this.video.buffered;\r\n        if (buffered.length === 0) return;\r\n\r\n        // Gap Jump Logic\r\n        for (let i = 0; i < buffered.length; i++) {\r\n            const end = buffered.end(i);\r\n            if (Math.abs(end - ct) < 0.5) {\r\n                if (i + 1 < buffered.length) {\r\n                    const nextStart = buffered.start(i + 1);\r\n                    if (nextStart - end < 3.0) {\r\n                        this.video.currentTime = nextStart + 0.1;\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    async seekTo(epochMs) {\r\n        if (!this.mediaSource || !this.sourceBuffer) return;\r\n\r\n        console.log('[MSE] SEEK', new Date(epochMs).toLocaleTimeString());\r\n        this.isSeeking = true;\r\n        this.video.pause();\r\n\r\n        if (this.abortController) this.abortController.abort();\r\n        this.isFetching = false;\r\n\r\n        if (this.sourceBuffer.updating) {\r\n            await new Promise(r => this.sourceBuffer.addEventListener('updateend', r, { once: true }));\r\n        }\r\n\r\n        try {\r\n            const ranges = this.video.buffered;\r\n            if (ranges.length > 0) {\r\n                this.sourceBuffer.remove(ranges.start(0), ranges.end(ranges.length - 1));\r\n                await new Promise(r => this.sourceBuffer.addEventListener('updateend', r, { once: true }));\r\n            }\r\n        } catch (e) { }\r\n\r\n        this.video.currentTime = 0;\r\n\r\n        // Update 4: Snap seek to valid segment if clicked in black\r\n        const validStart = this.getNextPlayableTs(epochMs - 1000);\r\n        this.nextTs = validStart || epochMs;\r\n\r\n        this.started = false;\r\n        this.isSeeking = false;\r\n    }\r\n\r\n    getCurrentEpochMs() {\r\n        if (!this.started || !this.nextTs) return this.nextTs || 0;\r\n        const bufferedDuration = this.getBufferedEnd();\r\n        const playheadPos = this.video.currentTime;\r\n        return this.nextTs - (Math.max(0, bufferedDuration - playheadPos) * 1000);\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}