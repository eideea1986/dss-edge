{"ast":null,"code":"export default class PlaybackCoreV2{constructor(videoElement,camId){let baseUrl=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'/api';this.video=videoElement;this.camId=camId;this.baseUrl=baseUrl;this.mediaSource=null;this.sourceBuffer=null;this.SEGMENT_SEC=6;this.TARGET_BUFFER=20;this.nextTs=null;this.segments=[];this.isFetching=false;this.started=false;this.isSeeking=false;this.ensureInterval=null;this.stallInterval=null;this.abortController=null;}setSegments(segments){this.segments=(segments||[]).map(s=>({start_ts:Number(s.start_ts),end_ts:s.end_ts===0?Date.now():Number(s.end_ts)})).sort((a,b)=>a.start_ts-b.start_ts);console.log(\"[MSE] Segments updated: \".concat(this.segments.length));}start(startEpochMs){console.log(\"[PlaybackCore] Starting at \".concat(new Date(startEpochMs).toLocaleTimeString()));// Smart Snap\nconst validStart=this.getNextPlayableTs(startEpochMs-1000);this.nextTs=validStart||startEpochMs;this.isSeeking=false;this.started=false;if(this.mediaSource)this.destroy();this.mediaSource=new MediaSource();this.video.src=URL.createObjectURL(this.mediaSource);this.video.playbackRate=1.0;this.mediaSource.addEventListener('sourceopen',this.onSourceOpen.bind(this));if(this.ensureInterval)clearInterval(this.ensureInterval);this.ensureInterval=setInterval(this.ensureBuffer.bind(this),200);// Faster Loop (200ms)\nif(this.stallInterval)clearInterval(this.stallInterval);this.stallInterval=setInterval(this.monitorStall.bind(this),500);// Faster checks (500ms)\n}destroy(){if(this.ensureInterval)clearInterval(this.ensureInterval);if(this.stallInterval)clearInterval(this.stallInterval);if(this.abortController)this.abortController.abort();if(this.video){this.video.pause();this.video.removeAttribute('src');this.video.load();}this.mediaSource=null;this.sourceBuffer=null;}onSourceOpen(){if(this.sourceBuffer||this.mediaSource.readyState!=='open')return;const codecs=['video/mp4; codecs=\"avc1.4d401e\"','video/mp4; codecs=\"avc1.64001f\"'];for(const codec of codecs){if(MediaSource.isTypeSupported(codec)){try{this.sourceBuffer=this.mediaSource.addSourceBuffer(codec);this.sourceBuffer.mode='segments';return;}catch(e){}}}}async ensureBuffer(){if(this.isSeeking)return;if(!this.sourceBuffer||this.sourceBuffer.updating)return;if(this.isFetching||this.nextTs===null)return;if(this.mediaSource.readyState!=='open')return;const current=this.video.currentTime||0;const bufferedEnd=this.getBufferedEnd();if(!this.started||bufferedEnd-current<this.TARGET_BUFFER){this.isFetching=true;await this.fetchAndAppend(this.nextTs);this.isFetching=false;}}getNextPlayableTs(currentTs){if(!this.segments||this.segments.length===0)return currentTs+this.SEGMENT_SEC*1000;const target=currentTs+this.SEGMENT_SEC*1000;const inSegment=this.segments.find(s=>target>=s.start_ts&&target<s.end_ts);if(inSegment)return target;const nextSeg=this.segments.find(s=>s.start_ts>currentTs);if(nextSeg)return nextSeg.start_ts;return null;}async fetchAndAppend(ts){if(this.isSeeking)return;const url=\"\".concat(this.baseUrl,\"/playback/segment/\").concat(this.camId,\"?ts=\").concat(ts,\"&dur=\").concat(this.SEGMENT_SEC);try{this.abortController=new AbortController();const tm=setTimeout(()=>this.abortController.abort(),6000);// 6s timeout aggressive\nconst res=await fetch(url,{signal:this.abortController.signal});clearTimeout(tm);if(!res.ok){if(res.status===404){this.nextTs=this.getNextPlayableTs(ts);}return;}const buf=await res.arrayBuffer();if(this.isSeeking)return;if(buf.byteLength>0){await this.appendBuffer(buf);// INSTANT START LOGIC\nif(!this.started&&!this.isSeeking){const buffered=this.video.buffered;if(buffered.length>0){try{const start=buffered.start(0);// Snap playhead if drifting\nif(Math.abs(this.video.currentTime-start)>0.5){this.video.currentTime=start+0.05;}await this.video.play();this.started=true;}catch(e){}}}}this.nextTs=this.getNextPlayableTs(ts);}catch(e){if(e.name!=='AbortError')console.error(\"[MSE] Fetch Error:\",e);}finally{this.abortController=null;}}appendBuffer(buffer){return new Promise(resolve=>{if(!this.sourceBuffer||this.mediaSource.readyState!=='open')return resolve();const onUpdateEnd=()=>{this.sourceBuffer.removeEventListener('updateend',onUpdateEnd);resolve();};this.sourceBuffer.addEventListener('updateend',onUpdateEnd);try{this.sourceBuffer.appendBuffer(buffer);}catch(e){this.sourceBuffer.removeEventListener('updateend',onUpdateEnd);resolve();}});}getBufferedEnd(){if(!this.video||!this.video.buffered||this.video.buffered.length===0)return 0;return this.video.buffered.end(this.video.buffered.length-1);}monitorStall(){if(!this.video||this.video.paused||this.isSeeking)return;const ct=this.video.currentTime;const buffered=this.video.buffered;if(buffered.length===0)return;let currentRangeEnd=0;let nextRangeStart=null;for(let i=0;i<buffered.length;i++){const start=buffered.start(i);const end=buffered.end(i);// Current pos is within this range (or just ended it)\nif(ct>=start-1&&ct<=end+1){// Tolerant check\ncurrentRangeEnd=end;if(i+1<buffered.length){nextRangeStart=buffered.start(i+1);}break;}}// AGGRESSIVE JUMP: If at end of current range, and next range exists (ANY DISTANCE)\nif(Math.abs(currentRangeEnd-ct)<1.0){// < 1s to end\nif(nextRangeStart!==null){console.warn(\"[MSE] Jumping GAP: \".concat(currentRangeEnd.toFixed(1),\" -> \").concat(nextRangeStart.toFixed(1)));this.video.currentTime=nextRangeStart+0.1;// Jump slightly inside\n}}}async seekTo(epochMs){if(!this.mediaSource||!this.sourceBuffer)return;console.log('[MSE] SEEK',new Date(epochMs).toLocaleTimeString());this.isSeeking=true;this.video.pause();if(this.abortController)this.abortController.abort();this.isFetching=false;if(this.sourceBuffer.updating){await new Promise(r=>this.sourceBuffer.addEventListener('updateend',r,{once:true}));}try{const ranges=this.video.buffered;if(ranges.length>0){this.sourceBuffer.remove(ranges.start(0),ranges.end(ranges.length-1));await new Promise(r=>this.sourceBuffer.addEventListener('updateend',r,{once:true}));}}catch(e){}// Snap seek to valid segment\nconst validStart=this.getNextPlayableTs(epochMs-1000);this.nextTs=validStart||epochMs;// Optimistic Playhead Update for UI responsiveness\nthis.video.currentTime=0;this.started=false;this.isSeeking=false;// loop will fetch nextTs immediately\n}getCurrentEpochMs(){if(!this.started||!this.nextTs)return this.nextTs||0;const bufferedDuration=this.getBufferedEnd();const playheadPos=this.video.currentTime;return this.nextTs-Math.max(0,bufferedDuration-playheadPos)*1000;}}","map":{"version":3,"names":["PlaybackCoreV2","constructor","videoElement","camId","baseUrl","arguments","length","undefined","video","mediaSource","sourceBuffer","SEGMENT_SEC","TARGET_BUFFER","nextTs","segments","isFetching","started","isSeeking","ensureInterval","stallInterval","abortController","setSegments","map","s","start_ts","Number","end_ts","Date","now","sort","a","b","console","log","concat","start","startEpochMs","toLocaleTimeString","validStart","getNextPlayableTs","destroy","MediaSource","src","URL","createObjectURL","playbackRate","addEventListener","onSourceOpen","bind","clearInterval","setInterval","ensureBuffer","monitorStall","abort","pause","removeAttribute","load","readyState","codecs","codec","isTypeSupported","addSourceBuffer","mode","e","updating","current","currentTime","bufferedEnd","getBufferedEnd","fetchAndAppend","currentTs","target","inSegment","find","nextSeg","ts","url","AbortController","tm","setTimeout","res","fetch","signal","clearTimeout","ok","status","buf","arrayBuffer","byteLength","appendBuffer","buffered","Math","abs","play","name","error","buffer","Promise","resolve","onUpdateEnd","removeEventListener","end","paused","ct","currentRangeEnd","nextRangeStart","i","warn","toFixed","seekTo","epochMs","r","once","ranges","remove","getCurrentEpochMs","bufferedDuration","playheadPos","max"],"sources":["I:/dispecerat/github_release/dss-edge/local-ui/src/services/PlaybackCoreV2.js"],"sourcesContent":["export default class PlaybackCoreV2 {\r\n    constructor(videoElement, camId, baseUrl = '/api') {\r\n        this.video = videoElement;\r\n        this.camId = camId;\r\n        this.baseUrl = baseUrl;\r\n\r\n        this.mediaSource = null;\r\n        this.sourceBuffer = null;\r\n\r\n        this.SEGMENT_SEC = 6;\r\n        this.TARGET_BUFFER = 20;\r\n\r\n        this.nextTs = null;\r\n        this.segments = [];\r\n\r\n        this.isFetching = false;\r\n        this.started = false;\r\n        this.isSeeking = false;\r\n\r\n        this.ensureInterval = null;\r\n        this.stallInterval = null;\r\n        this.abortController = null;\r\n    }\r\n\r\n    setSegments(segments) {\r\n        this.segments = (segments || []).map(s => ({\r\n            start_ts: Number(s.start_ts),\r\n            end_ts: s.end_ts === 0 ? Date.now() : Number(s.end_ts)\r\n        })).sort((a, b) => a.start_ts - b.start_ts);\r\n        console.log(`[MSE] Segments updated: ${this.segments.length}`);\r\n    }\r\n\r\n    start(startEpochMs) {\r\n        console.log(`[PlaybackCore] Starting at ${new Date(startEpochMs).toLocaleTimeString()}`);\r\n\r\n        // Smart Snap\r\n        const validStart = this.getNextPlayableTs(startEpochMs - 1000);\r\n        this.nextTs = validStart || startEpochMs;\r\n\r\n        this.isSeeking = false;\r\n        this.started = false;\r\n\r\n        if (this.mediaSource) this.destroy();\r\n\r\n        this.mediaSource = new MediaSource();\r\n        this.video.src = URL.createObjectURL(this.mediaSource);\r\n        this.video.playbackRate = 1.0;\r\n\r\n        this.mediaSource.addEventListener('sourceopen', this.onSourceOpen.bind(this));\r\n\r\n        if (this.ensureInterval) clearInterval(this.ensureInterval);\r\n        this.ensureInterval = setInterval(this.ensureBuffer.bind(this), 200); // Faster Loop (200ms)\r\n\r\n        if (this.stallInterval) clearInterval(this.stallInterval);\r\n        this.stallInterval = setInterval(this.monitorStall.bind(this), 500); // Faster checks (500ms)\r\n    }\r\n\r\n    destroy() {\r\n        if (this.ensureInterval) clearInterval(this.ensureInterval);\r\n        if (this.stallInterval) clearInterval(this.stallInterval);\r\n        if (this.abortController) this.abortController.abort();\r\n        if (this.video) {\r\n            this.video.pause();\r\n            this.video.removeAttribute('src');\r\n            this.video.load();\r\n        }\r\n        this.mediaSource = null;\r\n        this.sourceBuffer = null;\r\n    }\r\n\r\n    onSourceOpen() {\r\n        if (this.sourceBuffer || this.mediaSource.readyState !== 'open') return;\r\n        const codecs = ['video/mp4; codecs=\"avc1.4d401e\"', 'video/mp4; codecs=\"avc1.64001f\"'];\r\n        for (const codec of codecs) {\r\n            if (MediaSource.isTypeSupported(codec)) {\r\n                try {\r\n                    this.sourceBuffer = this.mediaSource.addSourceBuffer(codec);\r\n                    this.sourceBuffer.mode = 'segments';\r\n                    return;\r\n                } catch (e) { }\r\n            }\r\n        }\r\n    }\r\n\r\n    async ensureBuffer() {\r\n        if (this.isSeeking) return;\r\n        if (!this.sourceBuffer || this.sourceBuffer.updating) return;\r\n        if (this.isFetching || this.nextTs === null) return;\r\n        if (this.mediaSource.readyState !== 'open') return;\r\n\r\n        const current = this.video.currentTime || 0;\r\n        const bufferedEnd = this.getBufferedEnd();\r\n\r\n        if (!this.started || (bufferedEnd - current) < this.TARGET_BUFFER) {\r\n            this.isFetching = true;\r\n            await this.fetchAndAppend(this.nextTs);\r\n            this.isFetching = false;\r\n        }\r\n    }\r\n\r\n    getNextPlayableTs(currentTs) {\r\n        if (!this.segments || this.segments.length === 0) return currentTs + (this.SEGMENT_SEC * 1000);\r\n\r\n        const target = currentTs + (this.SEGMENT_SEC * 1000);\r\n        const inSegment = this.segments.find(s => target >= s.start_ts && target < s.end_ts);\r\n        if (inSegment) return target;\r\n\r\n        const nextSeg = this.segments.find(s => s.start_ts > currentTs);\r\n        if (nextSeg) return nextSeg.start_ts;\r\n\r\n        return null;\r\n    }\r\n\r\n    async fetchAndAppend(ts) {\r\n        if (this.isSeeking) return;\r\n\r\n        const url = `${this.baseUrl}/playback/segment/${this.camId}?ts=${ts}&dur=${this.SEGMENT_SEC}`;\r\n\r\n        try {\r\n            this.abortController = new AbortController();\r\n            const tm = setTimeout(() => this.abortController.abort(), 6000); // 6s timeout aggressive\r\n            const res = await fetch(url, { signal: this.abortController.signal });\r\n            clearTimeout(tm);\r\n\r\n            if (!res.ok) {\r\n                if (res.status === 404) {\r\n                    this.nextTs = this.getNextPlayableTs(ts);\r\n                }\r\n                return;\r\n            }\r\n\r\n            const buf = await res.arrayBuffer();\r\n            if (this.isSeeking) return;\r\n\r\n            if (buf.byteLength > 0) {\r\n                await this.appendBuffer(buf);\r\n\r\n                // INSTANT START LOGIC\r\n                if (!this.started && !this.isSeeking) {\r\n                    const buffered = this.video.buffered;\r\n                    if (buffered.length > 0) {\r\n                        try {\r\n                            const start = buffered.start(0);\r\n                            // Snap playhead if drifting\r\n                            if (Math.abs(this.video.currentTime - start) > 0.5) {\r\n                                this.video.currentTime = start + 0.05;\r\n                            }\r\n                            await this.video.play();\r\n                            this.started = true;\r\n                        } catch (e) { }\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.nextTs = this.getNextPlayableTs(ts);\r\n\r\n        } catch (e) {\r\n            if (e.name !== 'AbortError') console.error(\"[MSE] Fetch Error:\", e);\r\n        } finally {\r\n            this.abortController = null;\r\n        }\r\n    }\r\n\r\n    appendBuffer(buffer) {\r\n        return new Promise(resolve => {\r\n            if (!this.sourceBuffer || this.mediaSource.readyState !== 'open') return resolve();\r\n            const onUpdateEnd = () => {\r\n                this.sourceBuffer.removeEventListener('updateend', onUpdateEnd);\r\n                resolve();\r\n            };\r\n            this.sourceBuffer.addEventListener('updateend', onUpdateEnd);\r\n            try { this.sourceBuffer.appendBuffer(buffer); }\r\n            catch (e) { this.sourceBuffer.removeEventListener('updateend', onUpdateEnd); resolve(); }\r\n        });\r\n    }\r\n\r\n    getBufferedEnd() {\r\n        if (!this.video || !this.video.buffered || this.video.buffered.length === 0) return 0;\r\n        return this.video.buffered.end(this.video.buffered.length - 1);\r\n    }\r\n\r\n    monitorStall() {\r\n        if (!this.video || this.video.paused || this.isSeeking) return;\r\n\r\n        const ct = this.video.currentTime;\r\n        const buffered = this.video.buffered;\r\n        if (buffered.length === 0) return;\r\n\r\n        let currentRangeEnd = 0;\r\n        let nextRangeStart = null;\r\n\r\n        for (let i = 0; i < buffered.length; i++) {\r\n            const start = buffered.start(i);\r\n            const end = buffered.end(i);\r\n            // Current pos is within this range (or just ended it)\r\n            if (ct >= start - 1 && ct <= end + 1) { // Tolerant check\r\n                currentRangeEnd = end;\r\n                if (i + 1 < buffered.length) {\r\n                    nextRangeStart = buffered.start(i + 1);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        // AGGRESSIVE JUMP: If at end of current range, and next range exists (ANY DISTANCE)\r\n        if (Math.abs(currentRangeEnd - ct) < 1.0) { // < 1s to end\r\n            if (nextRangeStart !== null) {\r\n                console.warn(`[MSE] Jumping GAP: ${currentRangeEnd.toFixed(1)} -> ${nextRangeStart.toFixed(1)}`);\r\n                this.video.currentTime = nextRangeStart + 0.1; // Jump slightly inside\r\n            }\r\n        }\r\n    }\r\n\r\n    async seekTo(epochMs) {\r\n        if (!this.mediaSource || !this.sourceBuffer) return;\r\n\r\n        console.log('[MSE] SEEK', new Date(epochMs).toLocaleTimeString());\r\n        this.isSeeking = true;\r\n        this.video.pause();\r\n\r\n        if (this.abortController) this.abortController.abort();\r\n        this.isFetching = false;\r\n\r\n        if (this.sourceBuffer.updating) {\r\n            await new Promise(r => this.sourceBuffer.addEventListener('updateend', r, { once: true }));\r\n        }\r\n\r\n        try {\r\n            const ranges = this.video.buffered;\r\n            if (ranges.length > 0) {\r\n                this.sourceBuffer.remove(ranges.start(0), ranges.end(ranges.length - 1));\r\n                await new Promise(r => this.sourceBuffer.addEventListener('updateend', r, { once: true }));\r\n            }\r\n        } catch (e) { }\r\n\r\n        // Snap seek to valid segment\r\n        const validStart = this.getNextPlayableTs(epochMs - 1000);\r\n        this.nextTs = validStart || epochMs;\r\n\r\n        // Optimistic Playhead Update for UI responsiveness\r\n        this.video.currentTime = 0;\r\n\r\n        this.started = false;\r\n        this.isSeeking = false;\r\n        // loop will fetch nextTs immediately\r\n    }\r\n\r\n    getCurrentEpochMs() {\r\n        if (!this.started || !this.nextTs) return this.nextTs || 0;\r\n        const bufferedDuration = this.getBufferedEnd();\r\n        const playheadPos = this.video.currentTime;\r\n        return this.nextTs - (Math.max(0, bufferedDuration - playheadPos) * 1000);\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}