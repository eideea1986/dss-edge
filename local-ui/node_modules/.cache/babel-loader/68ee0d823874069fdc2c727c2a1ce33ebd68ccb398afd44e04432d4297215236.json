{"ast":null,"code":"export default class PlaybackCoreV2{constructor(videoElement,camId){let baseUrl=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'/api';this.video=videoElement;this.camId=camId;this.baseUrl=baseUrl;this.mediaSource=null;this.sourceBuffer=null;this.SEGMENT_SEC=6;this.TARGET_BUFFER=20;this.nextTs=null;this.segments=[];// NEW: Time Mapping (Video Time -> Real Time)\nthis.timeMap=[];this.isFetching=false;this.started=false;this.isSeeking=false;this.ensureInterval=null;this.stallInterval=null;this.abortController=null;}setSegments(segments){this.segments=(segments||[]).map(s=>({start_ts:Number(s.start_ts),end_ts:s.end_ts===0?Date.now():Number(s.end_ts)})).sort((a,b)=>a.start_ts-b.start_ts);console.log(\"[MSE] Segments updated: \".concat(this.segments.length));}start(startEpochMs){console.log(\"[PlaybackCore] Starting at \".concat(new Date(startEpochMs).toLocaleTimeString()));const validStart=this.getNextPlayableTs(startEpochMs-1000);this.nextTs=validStart||startEpochMs;this.isSeeking=false;this.started=false;this.timeMap=[];// Reset map\nif(this.mediaSource)this.destroy();this.mediaSource=new MediaSource();this.video.src=URL.createObjectURL(this.mediaSource);this.video.playbackRate=1.0;this.mediaSource.addEventListener('sourceopen',this.onSourceOpen.bind(this));if(this.ensureInterval)clearInterval(this.ensureInterval);this.ensureInterval=setInterval(this.ensureBuffer.bind(this),200);if(this.stallInterval)clearInterval(this.stallInterval);this.stallInterval=setInterval(this.monitorStall.bind(this),500);}destroy(){if(this.ensureInterval)clearInterval(this.ensureInterval);if(this.stallInterval)clearInterval(this.stallInterval);if(this.abortController)this.abortController.abort();if(this.video){this.video.pause();this.video.removeAttribute('src');this.video.load();}this.mediaSource=null;this.sourceBuffer=null;this.timeMap=[];}onSourceOpen(){if(this.sourceBuffer||this.mediaSource.readyState!=='open')return;const codecs=['video/mp4; codecs=\"avc1.4d401e\"','video/mp4; codecs=\"avc1.64001f\"'];for(const codec of codecs){if(MediaSource.isTypeSupported(codec)){try{this.sourceBuffer=this.mediaSource.addSourceBuffer(codec);this.sourceBuffer.mode='segments';return;}catch(e){}}}}async ensureBuffer(){if(this.isSeeking)return;if(!this.sourceBuffer||this.sourceBuffer.updating)return;if(this.isFetching||this.nextTs===null)return;if(this.mediaSource.readyState!=='open')return;const current=this.video.currentTime||0;const bufferedEnd=this.getBufferedEnd();if(!this.started||bufferedEnd-current<this.TARGET_BUFFER){this.isFetching=true;await this.fetchAndAppend(this.nextTs);this.isFetching=false;}}getNextPlayableTs(currentTs){if(!this.segments||this.segments.length===0)return currentTs+this.SEGMENT_SEC*1000;const target=currentTs+this.SEGMENT_SEC*1000;const inSegment=this.segments.find(s=>target>=s.start_ts&&target<s.end_ts);if(inSegment)return target;const nextSeg=this.segments.find(s=>s.start_ts>currentTs);if(nextSeg)return nextSeg.start_ts;return null;}async fetchAndAppend(ts){if(this.isSeeking)return;const url=\"\".concat(this.baseUrl,\"/playback/segment/\").concat(this.camId,\"?ts=\").concat(ts,\"&dur=\").concat(this.SEGMENT_SEC);try{this.abortController=new AbortController();const tm=setTimeout(()=>this.abortController.abort(),6000);const res=await fetch(url,{signal:this.abortController.signal});clearTimeout(tm);if(!res.ok){if(res.status===404){// Cleanup map\nconst badIdx=this.segments.findIndex(s=>ts>=s.start_ts&&ts<s.end_ts);if(badIdx!==-1)this.segments.splice(badIdx,1);this.nextTs=this.getNextPlayableTs(ts);}return;}const buf=await res.arrayBuffer();if(this.isSeeking)return;if(buf.byteLength>0){// RECORD MAPPING BEFORE APPEND\nconst videoStart=this.getBufferedEnd();// Add to map -> This chunk starts at `videoStart` and represents `ts`\nthis.timeMap.push({v:videoStart,t:ts});// Sort by v just in case, though it should be sequential\nthis.timeMap=this.timeMap.sort((a,b)=>a.v-b.v).slice(-50);// Keep last 50\nawait this.appendBuffer(buf);if(!this.started&&!this.isSeeking){const buffered=this.video.buffered;if(buffered.length>0){try{const start=buffered.start(0);if(Math.abs(this.video.currentTime-start)>0.5){this.video.currentTime=start+0.05;}await this.video.play();this.started=true;}catch(e){}}}}this.nextTs=this.getNextPlayableTs(ts);}catch(e){if(e.name!=='AbortError')console.error(\"[MSE] Fetch Error:\",e);}finally{this.abortController=null;}}appendBuffer(buffer){return new Promise(resolve=>{if(!this.sourceBuffer||this.mediaSource.readyState!=='open')return resolve();const onUpdateEnd=()=>{this.sourceBuffer.removeEventListener('updateend',onUpdateEnd);resolve();};this.sourceBuffer.addEventListener('updateend',onUpdateEnd);try{this.sourceBuffer.appendBuffer(buffer);}catch(e){this.sourceBuffer.removeEventListener('updateend',onUpdateEnd);resolve();}});}getBufferedEnd(){if(!this.video||!this.video.buffered||this.video.buffered.length===0)return 0;return this.video.buffered.end(this.video.buffered.length-1);}monitorStall(){if(!this.video||this.video.paused||this.isSeeking)return;const ct=this.video.currentTime;const buffered=this.video.buffered;if(buffered.length===0)return;let currentRangeEnd=0;let nextRangeStart=null;for(let i=0;i<buffered.length;i++){const start=buffered.start(i);const end=buffered.end(i);if(ct>=start-1&&ct<=end+1){currentRangeEnd=end;if(i+1<buffered.length){nextRangeStart=buffered.start(i+1);}break;}}if(Math.abs(currentRangeEnd-ct)<1.0){if(nextRangeStart!==null){console.warn(\"[MSE] Jumping GAP: \".concat(currentRangeEnd.toFixed(1),\" -> \").concat(nextRangeStart.toFixed(1)));this.video.currentTime=nextRangeStart+0.1;}}}async seekTo(epochMs){if(!this.mediaSource||!this.sourceBuffer)return;console.log('[MSE] SEEK',new Date(epochMs).toLocaleTimeString());this.isSeeking=true;this.video.pause();if(this.abortController)this.abortController.abort();this.isFetching=false;// Reset Mapping on Seek\nthis.timeMap=[];if(this.sourceBuffer.updating){await new Promise(r=>this.sourceBuffer.addEventListener('updateend',r,{once:true}));}try{const ranges=this.video.buffered;if(ranges.length>0){this.sourceBuffer.remove(ranges.start(0),ranges.end(ranges.length-1));await new Promise(r=>this.sourceBuffer.addEventListener('updateend',r,{once:true}));}}catch(e){}const validStart=this.getNextPlayableTs(epochMs-1000);this.nextTs=validStart||epochMs;this.video.currentTime=0;this.started=false;this.isSeeking=false;}// FIXED: Use Time Mapping for Precision\ngetCurrentEpochMs(){// Fallback if not playing\nif(!this.started)return this.nextTs||0;const ct=this.video.currentTime;// Find best matching segment in map\n// We look for the segment that starts <= currentTime\n// Iterate backwards\nfor(let i=this.timeMap.length-1;i>=0;i--){const m=this.timeMap[i];if(ct>=m.v){// Found it. \n// RealTime = StartReal + (CurrentVideo - StartVideo)\nconst offset=ct-m.v;return m.t+offset*1000;}}// If no map (start), fallback to nextTs estimation\nif(!this.nextTs)return 0;const bufferedDuration=this.getBufferedEnd();return this.nextTs-Math.max(0,bufferedDuration-ct)*1000;}}","map":{"version":3,"names":["PlaybackCoreV2","constructor","videoElement","camId","baseUrl","arguments","length","undefined","video","mediaSource","sourceBuffer","SEGMENT_SEC","TARGET_BUFFER","nextTs","segments","timeMap","isFetching","started","isSeeking","ensureInterval","stallInterval","abortController","setSegments","map","s","start_ts","Number","end_ts","Date","now","sort","a","b","console","log","concat","start","startEpochMs","toLocaleTimeString","validStart","getNextPlayableTs","destroy","MediaSource","src","URL","createObjectURL","playbackRate","addEventListener","onSourceOpen","bind","clearInterval","setInterval","ensureBuffer","monitorStall","abort","pause","removeAttribute","load","readyState","codecs","codec","isTypeSupported","addSourceBuffer","mode","e","updating","current","currentTime","bufferedEnd","getBufferedEnd","fetchAndAppend","currentTs","target","inSegment","find","nextSeg","ts","url","AbortController","tm","setTimeout","res","fetch","signal","clearTimeout","ok","status","badIdx","findIndex","splice","buf","arrayBuffer","byteLength","videoStart","push","v","t","slice","appendBuffer","buffered","Math","abs","play","name","error","buffer","Promise","resolve","onUpdateEnd","removeEventListener","end","paused","ct","currentRangeEnd","nextRangeStart","i","warn","toFixed","seekTo","epochMs","r","once","ranges","remove","getCurrentEpochMs","m","offset","bufferedDuration","max"],"sources":["I:/dispecerat/github_release/dss-edge/local-ui/src/services/PlaybackCoreV2.js"],"sourcesContent":["export default class PlaybackCoreV2 {\r\n    constructor(videoElement, camId, baseUrl = '/api') {\r\n        this.video = videoElement;\r\n        this.camId = camId;\r\n        this.baseUrl = baseUrl;\r\n\r\n        this.mediaSource = null;\r\n        this.sourceBuffer = null;\r\n\r\n        this.SEGMENT_SEC = 6;\r\n        this.TARGET_BUFFER = 20;\r\n\r\n        this.nextTs = null;\r\n        this.segments = [];\r\n\r\n        // NEW: Time Mapping (Video Time -> Real Time)\r\n        this.timeMap = [];\r\n\r\n        this.isFetching = false;\r\n        this.started = false;\r\n        this.isSeeking = false;\r\n\r\n        this.ensureInterval = null;\r\n        this.stallInterval = null;\r\n        this.abortController = null;\r\n    }\r\n\r\n    setSegments(segments) {\r\n        this.segments = (segments || []).map(s => ({\r\n            start_ts: Number(s.start_ts),\r\n            end_ts: s.end_ts === 0 ? Date.now() : Number(s.end_ts)\r\n        })).sort((a, b) => a.start_ts - b.start_ts);\r\n        console.log(`[MSE] Segments updated: ${this.segments.length}`);\r\n    }\r\n\r\n    start(startEpochMs) {\r\n        console.log(`[PlaybackCore] Starting at ${new Date(startEpochMs).toLocaleTimeString()}`);\r\n\r\n        const validStart = this.getNextPlayableTs(startEpochMs - 1000);\r\n        this.nextTs = validStart || startEpochMs;\r\n\r\n        this.isSeeking = false;\r\n        this.started = false;\r\n        this.timeMap = []; // Reset map\r\n\r\n        if (this.mediaSource) this.destroy();\r\n\r\n        this.mediaSource = new MediaSource();\r\n        this.video.src = URL.createObjectURL(this.mediaSource);\r\n        this.video.playbackRate = 1.0;\r\n\r\n        this.mediaSource.addEventListener('sourceopen', this.onSourceOpen.bind(this));\r\n\r\n        if (this.ensureInterval) clearInterval(this.ensureInterval);\r\n        this.ensureInterval = setInterval(this.ensureBuffer.bind(this), 200);\r\n\r\n        if (this.stallInterval) clearInterval(this.stallInterval);\r\n        this.stallInterval = setInterval(this.monitorStall.bind(this), 500);\r\n    }\r\n\r\n    destroy() {\r\n        if (this.ensureInterval) clearInterval(this.ensureInterval);\r\n        if (this.stallInterval) clearInterval(this.stallInterval);\r\n        if (this.abortController) this.abortController.abort();\r\n        if (this.video) {\r\n            this.video.pause();\r\n            this.video.removeAttribute('src');\r\n            this.video.load();\r\n        }\r\n        this.mediaSource = null;\r\n        this.sourceBuffer = null;\r\n        this.timeMap = [];\r\n    }\r\n\r\n    onSourceOpen() {\r\n        if (this.sourceBuffer || this.mediaSource.readyState !== 'open') return;\r\n        const codecs = ['video/mp4; codecs=\"avc1.4d401e\"', 'video/mp4; codecs=\"avc1.64001f\"'];\r\n        for (const codec of codecs) {\r\n            if (MediaSource.isTypeSupported(codec)) {\r\n                try {\r\n                    this.sourceBuffer = this.mediaSource.addSourceBuffer(codec);\r\n                    this.sourceBuffer.mode = 'segments';\r\n                    return;\r\n                } catch (e) { }\r\n            }\r\n        }\r\n    }\r\n\r\n    async ensureBuffer() {\r\n        if (this.isSeeking) return;\r\n        if (!this.sourceBuffer || this.sourceBuffer.updating) return;\r\n        if (this.isFetching || this.nextTs === null) return;\r\n        if (this.mediaSource.readyState !== 'open') return;\r\n\r\n        const current = this.video.currentTime || 0;\r\n        const bufferedEnd = this.getBufferedEnd();\r\n\r\n        if (!this.started || (bufferedEnd - current) < this.TARGET_BUFFER) {\r\n            this.isFetching = true;\r\n            await this.fetchAndAppend(this.nextTs);\r\n            this.isFetching = false;\r\n        }\r\n    }\r\n\r\n    getNextPlayableTs(currentTs) {\r\n        if (!this.segments || this.segments.length === 0) return currentTs + (this.SEGMENT_SEC * 1000);\r\n\r\n        const target = currentTs + (this.SEGMENT_SEC * 1000);\r\n        const inSegment = this.segments.find(s => target >= s.start_ts && target < s.end_ts);\r\n        if (inSegment) return target;\r\n\r\n        const nextSeg = this.segments.find(s => s.start_ts > currentTs);\r\n        if (nextSeg) return nextSeg.start_ts;\r\n\r\n        return null;\r\n    }\r\n\r\n    async fetchAndAppend(ts) {\r\n        if (this.isSeeking) return;\r\n\r\n        const url = `${this.baseUrl}/playback/segment/${this.camId}?ts=${ts}&dur=${this.SEGMENT_SEC}`;\r\n\r\n        try {\r\n            this.abortController = new AbortController();\r\n            const tm = setTimeout(() => this.abortController.abort(), 6000);\r\n            const res = await fetch(url, { signal: this.abortController.signal });\r\n            clearTimeout(tm);\r\n\r\n            if (!res.ok) {\r\n                if (res.status === 404) {\r\n                    // Cleanup map\r\n                    const badIdx = this.segments.findIndex(s => ts >= s.start_ts && ts < s.end_ts);\r\n                    if (badIdx !== -1) this.segments.splice(badIdx, 1);\r\n                    this.nextTs = this.getNextPlayableTs(ts);\r\n                }\r\n                return;\r\n            }\r\n\r\n            const buf = await res.arrayBuffer();\r\n            if (this.isSeeking) return;\r\n\r\n            if (buf.byteLength > 0) {\r\n                // RECORD MAPPING BEFORE APPEND\r\n                const videoStart = this.getBufferedEnd();\r\n\r\n                // Add to map -> This chunk starts at `videoStart` and represents `ts`\r\n                this.timeMap.push({ v: videoStart, t: ts });\r\n\r\n                // Sort by v just in case, though it should be sequential\r\n                this.timeMap = this.timeMap.sort((a, b) => a.v - b.v).slice(-50); // Keep last 50\r\n\r\n                await this.appendBuffer(buf);\r\n\r\n                if (!this.started && !this.isSeeking) {\r\n                    const buffered = this.video.buffered;\r\n                    if (buffered.length > 0) {\r\n                        try {\r\n                            const start = buffered.start(0);\r\n                            if (Math.abs(this.video.currentTime - start) > 0.5) {\r\n                                this.video.currentTime = start + 0.05;\r\n                            }\r\n                            await this.video.play();\r\n                            this.started = true;\r\n                        } catch (e) { }\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.nextTs = this.getNextPlayableTs(ts);\r\n\r\n        } catch (e) {\r\n            if (e.name !== 'AbortError') console.error(\"[MSE] Fetch Error:\", e);\r\n        } finally {\r\n            this.abortController = null;\r\n        }\r\n    }\r\n\r\n    appendBuffer(buffer) {\r\n        return new Promise(resolve => {\r\n            if (!this.sourceBuffer || this.mediaSource.readyState !== 'open') return resolve();\r\n            const onUpdateEnd = () => {\r\n                this.sourceBuffer.removeEventListener('updateend', onUpdateEnd);\r\n                resolve();\r\n            };\r\n            this.sourceBuffer.addEventListener('updateend', onUpdateEnd);\r\n            try { this.sourceBuffer.appendBuffer(buffer); }\r\n            catch (e) { this.sourceBuffer.removeEventListener('updateend', onUpdateEnd); resolve(); }\r\n        });\r\n    }\r\n\r\n    getBufferedEnd() {\r\n        if (!this.video || !this.video.buffered || this.video.buffered.length === 0) return 0;\r\n        return this.video.buffered.end(this.video.buffered.length - 1);\r\n    }\r\n\r\n    monitorStall() {\r\n        if (!this.video || this.video.paused || this.isSeeking) return;\r\n\r\n        const ct = this.video.currentTime;\r\n        const buffered = this.video.buffered;\r\n        if (buffered.length === 0) return;\r\n\r\n        let currentRangeEnd = 0;\r\n        let nextRangeStart = null;\r\n\r\n        for (let i = 0; i < buffered.length; i++) {\r\n            const start = buffered.start(i);\r\n            const end = buffered.end(i);\r\n            if (ct >= start - 1 && ct <= end + 1) {\r\n                currentRangeEnd = end;\r\n                if (i + 1 < buffered.length) {\r\n                    nextRangeStart = buffered.start(i + 1);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(currentRangeEnd - ct) < 1.0) {\r\n            if (nextRangeStart !== null) {\r\n                console.warn(`[MSE] Jumping GAP: ${currentRangeEnd.toFixed(1)} -> ${nextRangeStart.toFixed(1)}`);\r\n                this.video.currentTime = nextRangeStart + 0.1;\r\n            }\r\n        }\r\n    }\r\n\r\n    async seekTo(epochMs) {\r\n        if (!this.mediaSource || !this.sourceBuffer) return;\r\n\r\n        console.log('[MSE] SEEK', new Date(epochMs).toLocaleTimeString());\r\n        this.isSeeking = true;\r\n        this.video.pause();\r\n\r\n        if (this.abortController) this.abortController.abort();\r\n        this.isFetching = false;\r\n\r\n        // Reset Mapping on Seek\r\n        this.timeMap = [];\r\n\r\n        if (this.sourceBuffer.updating) {\r\n            await new Promise(r => this.sourceBuffer.addEventListener('updateend', r, { once: true }));\r\n        }\r\n\r\n        try {\r\n            const ranges = this.video.buffered;\r\n            if (ranges.length > 0) {\r\n                this.sourceBuffer.remove(ranges.start(0), ranges.end(ranges.length - 1));\r\n                await new Promise(r => this.sourceBuffer.addEventListener('updateend', r, { once: true }));\r\n            }\r\n        } catch (e) { }\r\n\r\n        const validStart = this.getNextPlayableTs(epochMs - 1000);\r\n        this.nextTs = validStart || epochMs;\r\n\r\n        this.video.currentTime = 0;\r\n\r\n        this.started = false;\r\n        this.isSeeking = false;\r\n    }\r\n\r\n    // FIXED: Use Time Mapping for Precision\r\n    getCurrentEpochMs() {\r\n        // Fallback if not playing\r\n        if (!this.started) return this.nextTs || 0;\r\n\r\n        const ct = this.video.currentTime;\r\n\r\n        // Find best matching segment in map\r\n        // We look for the segment that starts <= currentTime\r\n        // Iterate backwards\r\n        for (let i = this.timeMap.length - 1; i >= 0; i--) {\r\n            const m = this.timeMap[i];\r\n            if (ct >= m.v) {\r\n                // Found it. \r\n                // RealTime = StartReal + (CurrentVideo - StartVideo)\r\n                const offset = ct - m.v;\r\n                return m.t + (offset * 1000);\r\n            }\r\n        }\r\n\r\n        // If no map (start), fallback to nextTs estimation\r\n        if (!this.nextTs) return 0;\r\n        const bufferedDuration = this.getBufferedEnd();\r\n        return this.nextTs - (Math.max(0, bufferedDuration - ct) * 1000);\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}