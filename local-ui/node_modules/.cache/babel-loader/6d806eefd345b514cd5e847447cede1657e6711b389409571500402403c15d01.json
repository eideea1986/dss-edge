{"ast":null,"code":"import Hls from 'hls.js';\n\n/**\r\n * Enterprise Player State Machine\r\n * \r\n * IDLE: Player initialized, waiting for data.\r\n * READY: Data loaded, timeline built, ready to play.\r\n * BUFFERING: Loading video segments (HLS/MSE).\r\n * PLAYING: Video is actively playing.\r\n * PAUSED: Video is paused by user.\r\n * SEEKING: User or logic requested a time jump.\r\n * WAITING_FOR_SEGMENT: Playhead is in a gap, waiting or skipping.\r\n * ERROR: Critical failure.\r\n */\nexport const PlayerState = {\n  IDLE: 'IDLE',\n  READY: 'READY',\n  BUFFERING: 'BUFFERING',\n  PLAYING: 'PLAYING',\n  PAUSED: 'PAUSED',\n  SEEKING: 'SEEKING',\n  WAITING_FOR_SEGMENT: 'WAITING_FOR_SEGMENT',\n  ERROR: 'ERROR'\n};\nexport default class EnterprisePlayer {\n  constructor(videoElement, camId, onStateChange, baseUrl = '/api') {\n    this.video = videoElement;\n    this.camId = camId;\n    this.baseUrl = baseUrl;\n    this.onStateChange = onStateChange || (() => {});\n    this.state = PlayerState.IDLE;\n    this.segments = [];\n    this.hls = null;\n    this.virtualTimeline = []; // { start, end, file }\n\n    this._updateState(PlayerState.IDLE);\n\n    // Bind video events\n    this.video.addEventListener('waiting', () => this._updateState(PlayerState.BUFFERING));\n    this.video.addEventListener('playing', () => this._updateState(PlayerState.PLAYING));\n    this.video.addEventListener('pause', () => this._updateState(PlayerState.PAUSED));\n    this.video.addEventListener('error', e => this._handleError(e));\n    this.video.addEventListener('timeupdate', () => this._onTimeUpdate());\n  }\n  _updateState(newState) {\n    if (this.state === newState) return;\n    console.log(`[Player] State: ${this.state} -> ${newState}`);\n    this.state = newState;\n    this.onStateChange(this.state);\n  }\n\n  /**\r\n   * 1. Load Data & Validate\r\n   */\n  loadSegments(segments) {\n    if (!Array.isArray(segments) || segments.length === 0) {\n      console.warn(\"[Player] No segments provided.\");\n      this._updateState(PlayerState.IDLE);\n      return;\n    }\n\n    // Validate & Sort\n    this.segments = segments.map(s => ({\n      start: Number(s.start_ts || s.startTs),\n      end: Number(s.end_ts || s.endTs),\n      file: s.file\n    })).sort((a, b) => a.start - b.start).filter(s => s.end > s.start); // Remove invalid\n\n    if (this.segments.length === 0) {\n      console.warn(\"[Player] All segments were invalid.\");\n      return;\n    }\n    console.log(`[Player] Loaded ${this.segments.length} valid segments.`);\n    this._updateState(PlayerState.READY);\n  }\n\n  /**\r\n   * 2. Intelligent Play/Seek\r\n   */\n  async seekTo(targetEpochMs, autoPlay = true) {\n    if (this.state === PlayerState.IDLE) {\n      console.warn(\"[Player] Cannot seek in IDLE state. Load segments first.\");\n      return;\n    }\n    this._updateState(PlayerState.SEEKING);\n\n    // A. SNAP TO SEGMENT (Keyframe Awareness Strategy)\n    // Check if target is inside a segment\n    let activeSegment = this.segments.find(s => targetEpochMs >= s.start && targetEpochMs <= s.end);\n    let actualStart = targetEpochMs;\n\n    // B. GAP HANDLING (Jump to next)\n    if (!activeSegment) {\n      console.log(`[Player] Target ${new Date(targetEpochMs).toLocaleTimeString()} is in a GAP.`);\n      const nextSegment = this.segments.find(s => s.start > targetEpochMs);\n      if (nextSegment) {\n        console.log(`[Player] Jumping to next segment: ${new Date(nextSegment.start).toLocaleTimeString()}`);\n        activeSegment = nextSegment;\n        actualStart = nextSegment.start;\n      } else {\n        console.log(\"[Player] No future segments found. End of timeline.\");\n        this._updateState(PlayerState.PAUSED); // Or finished\n        return;\n      }\n    }\n\n    // C. LOAD SOURCE (HLS Manifest Generation)\n    // We request a playlist starting from this specific timestamp\n    // The backend should return an m3u8 starting at the nearest keyframe for this 'start' param\n    const playlistUrl = `${this.baseUrl}/playback/playlist/${this.camId}.m3u8?start=${actualStart}&end=${actualStart + 3600000}`; // Load 1 hr ahead\n\n    this._loadHlsSource(playlistUrl, actualStart);\n    if (autoPlay) {\n      try {\n        await this.video.play();\n      } catch (e) {\n        console.warn(\"[Player] Autoplay prevented:\", e);\n        this._updateState(PlayerState.PAUSED);\n      }\n    }\n  }\n  _loadHlsSource(url, startEpoch) {\n    if (this.hls) {\n      this.hls.destroy();\n      this.hls = null;\n    }\n    if (Hls.isSupported()) {\n      this.hls = new Hls({\n        enableWorker: true,\n        lowLatencyMode: false,\n        // For playback we want stability, not low latency\n        maxBufferLength: 30\n      });\n      this.hls.loadSource(url);\n      this.hls.attachMedia(this.video);\n      this.hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {\n        console.log(\"[Player] Manifest Loaded.\");\n        // HLS.js usually handles the start offset if the manifest is correct\n        // But we can double check\n        this._updateState(PlayerState.BUFFERING);\n      });\n      this.hls.on(Hls.Events.ERROR, (event, data) => {\n        if (data.fatal) {\n          console.error(\"[Player] Fatal HLS Error:\", data);\n          this._updateState(PlayerState.ERROR);\n          this.hls.destroy();\n        }\n      });\n\n      // Sync current HLS time mapping\n      this.hls.on(Hls.Events.FRAG_CHANGED, (e, data) => {\n        if (data.frag) {\n          this.currentFragProgramDateTime = data.frag.programDateTime;\n          this.currentFragStartPTS = data.frag.start;\n        }\n      });\n    } else if (this.video.canPlayType('application/vnd.apple.mpegurl')) {\n      // Safari / Native HLS\n      this.video.src = url;\n    }\n  }\n  _onTimeUpdate() {\n    // Calculate current \"Real World\" time\n    // This is tricky with HLS. We need Program Date Time from fragments if possible\n    // Or we can rely on the backend manifest being 1-to-1 with requested time if it's VOD\n\n    // Simple Gap Check for now (if playing linearly)\n    // If we fall off the edge of a segment, this logic should fire\n  }\n\n  /**\r\n   * Get Current Epoch Time\r\n   * Uses HLS Program Date Time if available, otherwise estimates.\r\n   */\n  getCurrentTime() {\n    if (this.hls && this.currentFragProgramDateTime) {\n      const offset = this.video.currentTime - this.currentFragStartPTS;\n      return this.currentFragProgramDateTime + offset * 1000;\n    }\n    // Fallback or Native HLS might need different handling\n    return Date.now();\n  }\n  pause() {\n    this.video.pause();\n  }\n  play() {\n    this.video.play();\n  }\n  destroy() {\n    if (this.hls) this.hls.destroy();\n    // Remove listeners (optional if element is destroyed)\n  }\n}","map":{"version":3,"names":["Hls","PlayerState","IDLE","READY","BUFFERING","PLAYING","PAUSED","SEEKING","WAITING_FOR_SEGMENT","ERROR","EnterprisePlayer","constructor","videoElement","camId","onStateChange","baseUrl","video","state","segments","hls","virtualTimeline","_updateState","addEventListener","e","_handleError","_onTimeUpdate","newState","console","log","loadSegments","Array","isArray","length","warn","map","s","start","Number","start_ts","startTs","end","end_ts","endTs","file","sort","a","b","filter","seekTo","targetEpochMs","autoPlay","activeSegment","find","actualStart","Date","toLocaleTimeString","nextSegment","playlistUrl","_loadHlsSource","play","url","startEpoch","destroy","isSupported","enableWorker","lowLatencyMode","maxBufferLength","loadSource","attachMedia","on","Events","MANIFEST_PARSED","event","data","fatal","error","FRAG_CHANGED","frag","currentFragProgramDateTime","programDateTime","currentFragStartPTS","canPlayType","src","getCurrentTime","offset","currentTime","now","pause"],"sources":["I:/dispecerat/github_release/dss-edge/local-ui/src/services/EnterprisePlayer.js"],"sourcesContent":["import Hls from 'hls.js';\r\n\r\n/**\r\n * Enterprise Player State Machine\r\n * \r\n * IDLE: Player initialized, waiting for data.\r\n * READY: Data loaded, timeline built, ready to play.\r\n * BUFFERING: Loading video segments (HLS/MSE).\r\n * PLAYING: Video is actively playing.\r\n * PAUSED: Video is paused by user.\r\n * SEEKING: User or logic requested a time jump.\r\n * WAITING_FOR_SEGMENT: Playhead is in a gap, waiting or skipping.\r\n * ERROR: Critical failure.\r\n */\r\nexport const PlayerState = {\r\n    IDLE: 'IDLE',\r\n    READY: 'READY',\r\n    BUFFERING: 'BUFFERING',\r\n    PLAYING: 'PLAYING',\r\n    PAUSED: 'PAUSED',\r\n    SEEKING: 'SEEKING',\r\n    WAITING_FOR_SEGMENT: 'WAITING_FOR_SEGMENT',\r\n    ERROR: 'ERROR'\r\n};\r\n\r\nexport default class EnterprisePlayer {\r\n    constructor(videoElement, camId, onStateChange, baseUrl = '/api') {\r\n        this.video = videoElement;\r\n        this.camId = camId;\r\n        this.baseUrl = baseUrl;\r\n        this.onStateChange = onStateChange || (() => { });\r\n\r\n        this.state = PlayerState.IDLE;\r\n        this.segments = [];\r\n        this.hls = null;\r\n        this.virtualTimeline = []; // { start, end, file }\r\n\r\n        this._updateState(PlayerState.IDLE);\r\n\r\n        // Bind video events\r\n        this.video.addEventListener('waiting', () => this._updateState(PlayerState.BUFFERING));\r\n        this.video.addEventListener('playing', () => this._updateState(PlayerState.PLAYING));\r\n        this.video.addEventListener('pause', () => this._updateState(PlayerState.PAUSED));\r\n        this.video.addEventListener('error', (e) => this._handleError(e));\r\n        this.video.addEventListener('timeupdate', () => this._onTimeUpdate());\r\n    }\r\n\r\n    _updateState(newState) {\r\n        if (this.state === newState) return;\r\n        console.log(`[Player] State: ${this.state} -> ${newState}`);\r\n        this.state = newState;\r\n        this.onStateChange(this.state);\r\n    }\r\n\r\n    /**\r\n     * 1. Load Data & Validate\r\n     */\r\n    loadSegments(segments) {\r\n        if (!Array.isArray(segments) || segments.length === 0) {\r\n            console.warn(\"[Player] No segments provided.\");\r\n            this._updateState(PlayerState.IDLE);\r\n            return;\r\n        }\r\n\r\n        // Validate & Sort\r\n        this.segments = segments\r\n            .map(s => ({\r\n                start: Number(s.start_ts || s.startTs),\r\n                end: Number(s.end_ts || s.endTs),\r\n                file: s.file\r\n            }))\r\n            .sort((a, b) => a.start - b.start)\r\n            .filter(s => s.end > s.start); // Remove invalid\r\n\r\n        if (this.segments.length === 0) {\r\n            console.warn(\"[Player] All segments were invalid.\");\r\n            return;\r\n        }\r\n\r\n        console.log(`[Player] Loaded ${this.segments.length} valid segments.`);\r\n        this._updateState(PlayerState.READY);\r\n    }\r\n\r\n    /**\r\n     * 2. Intelligent Play/Seek\r\n     */\r\n    async seekTo(targetEpochMs, autoPlay = true) {\r\n        if (this.state === PlayerState.IDLE) {\r\n            console.warn(\"[Player] Cannot seek in IDLE state. Load segments first.\");\r\n            return;\r\n        }\r\n\r\n        this._updateState(PlayerState.SEEKING);\r\n\r\n        // A. SNAP TO SEGMENT (Keyframe Awareness Strategy)\r\n        // Check if target is inside a segment\r\n        let activeSegment = this.segments.find(s => targetEpochMs >= s.start && targetEpochMs <= s.end);\r\n        let actualStart = targetEpochMs;\r\n\r\n        // B. GAP HANDLING (Jump to next)\r\n        if (!activeSegment) {\r\n            console.log(`[Player] Target ${new Date(targetEpochMs).toLocaleTimeString()} is in a GAP.`);\r\n            const nextSegment = this.segments.find(s => s.start > targetEpochMs);\r\n            if (nextSegment) {\r\n                console.log(`[Player] Jumping to next segment: ${new Date(nextSegment.start).toLocaleTimeString()}`);\r\n                activeSegment = nextSegment;\r\n                actualStart = nextSegment.start;\r\n            } else {\r\n                console.log(\"[Player] No future segments found. End of timeline.\");\r\n                this._updateState(PlayerState.PAUSED); // Or finished\r\n                return;\r\n            }\r\n        }\r\n\r\n        // C. LOAD SOURCE (HLS Manifest Generation)\r\n        // We request a playlist starting from this specific timestamp\r\n        // The backend should return an m3u8 starting at the nearest keyframe for this 'start' param\r\n        const playlistUrl = `${this.baseUrl}/playback/playlist/${this.camId}.m3u8?start=${actualStart}&end=${actualStart + 3600000}`; // Load 1 hr ahead\r\n\r\n        this._loadHlsSource(playlistUrl, actualStart);\r\n\r\n        if (autoPlay) {\r\n            try {\r\n                await this.video.play();\r\n            } catch (e) {\r\n                console.warn(\"[Player] Autoplay prevented:\", e);\r\n                this._updateState(PlayerState.PAUSED);\r\n            }\r\n        }\r\n    }\r\n\r\n    _loadHlsSource(url, startEpoch) {\r\n        if (this.hls) {\r\n            this.hls.destroy();\r\n            this.hls = null;\r\n        }\r\n\r\n        if (Hls.isSupported()) {\r\n            this.hls = new Hls({\r\n                enableWorker: true,\r\n                lowLatencyMode: false, // For playback we want stability, not low latency\r\n                maxBufferLength: 30,\r\n            });\r\n\r\n            this.hls.loadSource(url);\r\n            this.hls.attachMedia(this.video);\r\n\r\n            this.hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {\r\n                console.log(\"[Player] Manifest Loaded.\");\r\n                // HLS.js usually handles the start offset if the manifest is correct\r\n                // But we can double check\r\n                this._updateState(PlayerState.BUFFERING);\r\n            });\r\n\r\n            this.hls.on(Hls.Events.ERROR, (event, data) => {\r\n                if (data.fatal) {\r\n                    console.error(\"[Player] Fatal HLS Error:\", data);\r\n                    this._updateState(PlayerState.ERROR);\r\n                    this.hls.destroy();\r\n                }\r\n            });\r\n\r\n            // Sync current HLS time mapping\r\n            this.hls.on(Hls.Events.FRAG_CHANGED, (e, data) => {\r\n                if (data.frag) {\r\n                    this.currentFragProgramDateTime = data.frag.programDateTime;\r\n                    this.currentFragStartPTS = data.frag.start;\r\n                }\r\n            });\r\n\r\n        } else if (this.video.canPlayType('application/vnd.apple.mpegurl')) {\r\n            // Safari / Native HLS\r\n            this.video.src = url;\r\n        }\r\n    }\r\n\r\n    _onTimeUpdate() {\r\n        // Calculate current \"Real World\" time\r\n        // This is tricky with HLS. We need Program Date Time from fragments if possible\r\n        // Or we can rely on the backend manifest being 1-to-1 with requested time if it's VOD\r\n\r\n        // Simple Gap Check for now (if playing linearly)\r\n        // If we fall off the edge of a segment, this logic should fire\r\n    }\r\n\r\n    /**\r\n     * Get Current Epoch Time\r\n     * Uses HLS Program Date Time if available, otherwise estimates.\r\n     */\r\n    getCurrentTime() {\r\n        if (this.hls && this.currentFragProgramDateTime) {\r\n            const offset = this.video.currentTime - this.currentFragStartPTS;\r\n            return this.currentFragProgramDateTime + (offset * 1000);\r\n        }\r\n        // Fallback or Native HLS might need different handling\r\n        return Date.now();\r\n    }\r\n\r\n    pause() {\r\n        this.video.pause();\r\n    }\r\n\r\n    play() {\r\n        this.video.play();\r\n    }\r\n\r\n    destroy() {\r\n        if (this.hls) this.hls.destroy();\r\n        // Remove listeners (optional if element is destroyed)\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}