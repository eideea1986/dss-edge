{"ast":null,"code":"export default class PlaybackCoreV2{constructor(videoElement,camId){let baseUrl=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'/api';this.video=videoElement;this.camId=camId;this.baseUrl=baseUrl;this.mediaSource=null;this.sourceBuffer=null;this.SEGMENT_SEC=6;this.TARGET_BUFFER=20;this.nextTs=null;this.isFetching=false;this.started=false;this.isSeeking=false;this.ensureInterval=null;this.stallInterval=null;this.abortController=null;this.gapRetries=0;this.MAX_GAP_RETRIES=15;}start(startEpochMs){console.log(\"[PlaybackCore] Starting at \".concat(new Date(startEpochMs).toLocaleTimeString()));this.nextTs=startEpochMs;this.isSeeking=false;this.started=false;this.gapRetries=0;if(this.mediaSource)this.destroy();this.mediaSource=new MediaSource();this.video.src=URL.createObjectURL(this.mediaSource);this.video.playbackRate=1.0;this.mediaSource.addEventListener('sourceopen',this.onSourceOpen.bind(this));// BUFFER LOOP\nthis.ensureInterval=setInterval(this.ensureBuffer.bind(this),500);// STALL / GAP JUMP LOOP (CRITICAL FIX)\nthis.stallInterval=setInterval(this.monitorStall.bind(this),1000);}destroy(){if(this.ensureInterval)clearInterval(this.ensureInterval);if(this.stallInterval)clearInterval(this.stallInterval);if(this.abortController)this.abortController.abort();if(this.video){this.video.pause();this.video.removeAttribute('src');this.video.load();}this.mediaSource=null;this.sourceBuffer=null;}onSourceOpen(){if(this.sourceBuffer||this.mediaSource.readyState!=='open')return;// USE SAFE CODEC (Main Profile Level 3.0) - Best Compatibility\nconst codecs=['video/mp4; codecs=\"avc1.4d401e\"','video/mp4; codecs=\"avc1.64001f\"'];for(const codec of codecs){if(MediaSource.isTypeSupported(codec)){try{console.log(\"[MSE] Using codec: \".concat(codec));this.sourceBuffer=this.mediaSource.addSourceBuffer(codec);this.sourceBuffer.mode='segments';return;}catch(e){console.warn(\"[MSE] Failed to add SourceBuffer for \".concat(codec),e);}}}console.error(\"[MSE] No suitable codec found!\");}async ensureBuffer(){if(this.isSeeking||this.gapRetries>this.MAX_GAP_RETRIES)return;if(!this.sourceBuffer||this.sourceBuffer.updating)return;// Wait for append\nif(this.isFetching||this.nextTs===null)return;if(this.mediaSource.readyState!=='open')return;const current=this.video.currentTime||0;const bufferedEnd=this.getBufferedEnd();// Fetch if buffer is small (< 20s) OR if we haven't started yet\nif(!this.started||bufferedEnd-current<this.TARGET_BUFFER){this.isFetching=true;await this.fetchAndAppend(this.nextTs);this.isFetching=false;}}async fetchAndAppend(ts){if(this.isSeeking)return;const url=\"\".concat(this.baseUrl,\"/playback/segment/\").concat(this.camId,\"?ts=\").concat(ts,\"&dur=\").concat(this.SEGMENT_SEC);try{this.abortController=new AbortController();// 8s timeout\nconst tm=setTimeout(()=>this.abortController.abort(),8000);const res=await fetch(url,{signal:this.abortController.signal});clearTimeout(tm);if(!res.ok){if(res.status===404)await this.skipGap(ts);return;}const buf=await res.arrayBuffer();if(this.isSeeking)return;if(buf.byteLength>0){await this.appendBuffer(buf);this.gapRetries=0;// Reset on success\n// AUTO START if we have enough buffer\nif(!this.started&&!this.isSeeking){const end=this.getBufferedEnd();if(end>0.5){// Got some data? Play.\ntry{await this.video.play();this.started=true;}catch(e){}}}}else{console.warn(\"[MSE] Empty segment received\");}this.nextTs+=this.SEGMENT_SEC*1000;}catch(e){if(e.name!=='AbortError')console.error(\"[MSE] Fetch Error:\",e);}finally{this.abortController=null;}}async skipGap(failedTs){this.gapRetries++;if(this.gapRetries>this.MAX_GAP_RETRIES){console.warn('[MSE] Too many gaps. Stopping.');return;}console.warn(\"[MSE] GAP at \".concat(failedTs,\". Skipping +\").concat(this.SEGMENT_SEC,\"s\"));this.nextTs+=this.SEGMENT_SEC*1000;// If playing \"on black\", jump playhead too\n// if (this.video.readyState > 0 && !this.video.paused) {\n//     // Optionally jump video time if we are stuck at end\n// }\n}appendBuffer(buffer){return new Promise(resolve=>{if(!this.sourceBuffer||this.mediaSource.readyState!=='open')return resolve();const onUpdateEnd=()=>{this.sourceBuffer.removeEventListener('updateend',onUpdateEnd);resolve();};this.sourceBuffer.addEventListener('updateend',onUpdateEnd);try{this.sourceBuffer.appendBuffer(buffer);}catch(e){console.error(\"[MSE] Append Error:\",e);// If QuotaExceeded, remove played buffer\nif(e.name==='QuotaExceededError'){this.flushPlayedBuffer();}this.sourceBuffer.removeEventListener('updateend',onUpdateEnd);resolve();}});}// CRITICAL: JUMP OVER GAPS IN BUFFER\nmonitorStall(){if(!this.video||this.video.paused||this.isSeeking)return;const ct=this.video.currentTime;const buffered=this.video.buffered;if(buffered.length===0)return;// Find which range we are in (or just past)\nfor(let i=0;i<buffered.length;i++){const start=buffered.start(i);const end=buffered.end(i);// If we are very close to the end of a range (< 0.5s)\nif(Math.abs(end-ct)<0.5){// Is there a next range?\nif(i+1<buffered.length){const nextStart=buffered.start(i+1);// If the gap is small enough (< 3s), JUMP IT\nif(nextStart-end<3.0){console.warn(\"[MSE] Jumping MICRO-GAP: \".concat(end.toFixed(2),\" -> \").concat(nextStart.toFixed(2)));this.video.currentTime=nextStart+0.1;return;}}}}// LOGGING\nconst bufEnd=this.getBufferedEnd();console.log(\"[MSE] T:\".concat(ct.toFixed(1),\" Buf:\").concat(bufEnd.toFixed(1),\" Ahead:\").concat((bufEnd-ct).toFixed(1)));}flushPlayedBuffer(){if(!this.sourceBuffer||this.sourceBuffer.updating)return;const ct=this.video.currentTime;if(ct>30){try{this.sourceBuffer.remove(0,ct-10);}catch(e){}}}getBufferedEnd(){if(!this.video||!this.video.buffered||this.video.buffered.length===0)return 0;return this.video.buffered.end(this.video.buffered.length-1);}async seekTo(epochMs){if(!this.mediaSource||!this.sourceBuffer)return;console.log('[MSE] SEEK',new Date(epochMs).toLocaleTimeString());this.isSeeking=true;this.gapRetries=0;this.video.pause();// Cancel Fetch\nif(this.abortController)this.abortController.abort();this.isFetching=false;// Wait for update\nif(this.sourceBuffer.updating){await new Promise(r=>this.sourceBuffer.addEventListener('updateend',r,{once:true}));}// Flush Buffer\ntry{const ranges=this.video.buffered;if(ranges.length>0){this.sourceBuffer.remove(ranges.start(0),ranges.end(ranges.length-1));await new Promise(r=>this.sourceBuffer.addEventListener('updateend',r,{once:true}));}}catch(e){}this.video.currentTime=0;// Reset safe\nthis.nextTs=epochMs;this.started=false;this.isSeeking=false;// Ensure loop will kick in and fetch nextTs\n}getCurrentEpochMs(){if(!this.started||!this.nextTs)return this.nextTs||0;const bufferedDuration=this.getBufferedEnd();const playheadPos=this.video.currentTime;return this.nextTs-Math.max(0,bufferedDuration-playheadPos)*1000;}}","map":{"version":3,"names":["PlaybackCoreV2","constructor","videoElement","camId","baseUrl","arguments","length","undefined","video","mediaSource","sourceBuffer","SEGMENT_SEC","TARGET_BUFFER","nextTs","isFetching","started","isSeeking","ensureInterval","stallInterval","abortController","gapRetries","MAX_GAP_RETRIES","start","startEpochMs","console","log","concat","Date","toLocaleTimeString","destroy","MediaSource","src","URL","createObjectURL","playbackRate","addEventListener","onSourceOpen","bind","setInterval","ensureBuffer","monitorStall","clearInterval","abort","pause","removeAttribute","load","readyState","codecs","codec","isTypeSupported","addSourceBuffer","mode","e","warn","error","updating","current","currentTime","bufferedEnd","getBufferedEnd","fetchAndAppend","ts","url","AbortController","tm","setTimeout","res","fetch","signal","clearTimeout","ok","status","skipGap","buf","arrayBuffer","byteLength","appendBuffer","end","play","name","failedTs","buffer","Promise","resolve","onUpdateEnd","removeEventListener","flushPlayedBuffer","paused","ct","buffered","i","Math","abs","nextStart","toFixed","bufEnd","remove","seekTo","epochMs","r","once","ranges","getCurrentEpochMs","bufferedDuration","playheadPos","max"],"sources":["I:/dispecerat/github_release/dss-edge/local-ui/src/services/PlaybackCoreV2.js"],"sourcesContent":["export default class PlaybackCoreV2 {\r\n    constructor(videoElement, camId, baseUrl = '/api') {\r\n        this.video = videoElement;\r\n        this.camId = camId;\r\n        this.baseUrl = baseUrl;\r\n\r\n        this.mediaSource = null;\r\n        this.sourceBuffer = null;\r\n\r\n        this.SEGMENT_SEC = 6;\r\n        this.TARGET_BUFFER = 20;\r\n\r\n        this.nextTs = null;\r\n        this.isFetching = false;\r\n        this.started = false;\r\n        this.isSeeking = false;\r\n\r\n        this.ensureInterval = null;\r\n        this.stallInterval = null;\r\n        this.abortController = null;\r\n\r\n        this.gapRetries = 0;\r\n        this.MAX_GAP_RETRIES = 15;\r\n    }\r\n\r\n    start(startEpochMs) {\r\n        console.log(`[PlaybackCore] Starting at ${new Date(startEpochMs).toLocaleTimeString()}`);\r\n        this.nextTs = startEpochMs;\r\n        this.isSeeking = false;\r\n        this.started = false;\r\n        this.gapRetries = 0;\r\n\r\n        if (this.mediaSource) this.destroy();\r\n\r\n        this.mediaSource = new MediaSource();\r\n        this.video.src = URL.createObjectURL(this.mediaSource);\r\n        this.video.playbackRate = 1.0;\r\n\r\n        this.mediaSource.addEventListener('sourceopen', this.onSourceOpen.bind(this));\r\n\r\n        // BUFFER LOOP\r\n        this.ensureInterval = setInterval(this.ensureBuffer.bind(this), 500);\r\n\r\n        // STALL / GAP JUMP LOOP (CRITICAL FIX)\r\n        this.stallInterval = setInterval(this.monitorStall.bind(this), 1000);\r\n    }\r\n\r\n    destroy() {\r\n        if (this.ensureInterval) clearInterval(this.ensureInterval);\r\n        if (this.stallInterval) clearInterval(this.stallInterval);\r\n        if (this.abortController) this.abortController.abort();\r\n\r\n        if (this.video) {\r\n            this.video.pause();\r\n            this.video.removeAttribute('src');\r\n            this.video.load();\r\n        }\r\n\r\n        this.mediaSource = null;\r\n        this.sourceBuffer = null;\r\n    }\r\n\r\n    onSourceOpen() {\r\n        if (this.sourceBuffer || this.mediaSource.readyState !== 'open') return;\r\n\r\n        // USE SAFE CODEC (Main Profile Level 3.0) - Best Compatibility\r\n        const codecs = ['video/mp4; codecs=\"avc1.4d401e\"', 'video/mp4; codecs=\"avc1.64001f\"'];\r\n\r\n        for (const codec of codecs) {\r\n            if (MediaSource.isTypeSupported(codec)) {\r\n                try {\r\n                    console.log(`[MSE] Using codec: ${codec}`);\r\n                    this.sourceBuffer = this.mediaSource.addSourceBuffer(codec);\r\n                    this.sourceBuffer.mode = 'segments';\r\n                    return;\r\n                } catch (e) {\r\n                    console.warn(`[MSE] Failed to add SourceBuffer for ${codec}`, e);\r\n                }\r\n            }\r\n        }\r\n        console.error(\"[MSE] No suitable codec found!\");\r\n    }\r\n\r\n    async ensureBuffer() {\r\n        if (this.isSeeking || this.gapRetries > this.MAX_GAP_RETRIES) return;\r\n        if (!this.sourceBuffer || this.sourceBuffer.updating) return; // Wait for append\r\n        if (this.isFetching || this.nextTs === null) return;\r\n        if (this.mediaSource.readyState !== 'open') return;\r\n\r\n        const current = this.video.currentTime || 0;\r\n        const bufferedEnd = this.getBufferedEnd();\r\n\r\n        // Fetch if buffer is small (< 20s) OR if we haven't started yet\r\n        if (!this.started || (bufferedEnd - current) < this.TARGET_BUFFER) {\r\n            this.isFetching = true;\r\n            await this.fetchAndAppend(this.nextTs);\r\n            this.isFetching = false;\r\n        }\r\n    }\r\n\r\n    async fetchAndAppend(ts) {\r\n        if (this.isSeeking) return;\r\n\r\n        const url = `${this.baseUrl}/playback/segment/${this.camId}?ts=${ts}&dur=${this.SEGMENT_SEC}`;\r\n\r\n        try {\r\n            this.abortController = new AbortController();\r\n            // 8s timeout\r\n            const tm = setTimeout(() => this.abortController.abort(), 8000);\r\n\r\n            const res = await fetch(url, { signal: this.abortController.signal });\r\n            clearTimeout(tm);\r\n\r\n            if (!res.ok) {\r\n                if (res.status === 404) await this.skipGap(ts);\r\n                return;\r\n            }\r\n\r\n            const buf = await res.arrayBuffer();\r\n            if (this.isSeeking) return;\r\n\r\n            if (buf.byteLength > 0) {\r\n                await this.appendBuffer(buf);\r\n                this.gapRetries = 0; // Reset on success\r\n\r\n                // AUTO START if we have enough buffer\r\n                if (!this.started && !this.isSeeking) {\r\n                    const end = this.getBufferedEnd();\r\n                    if (end > 0.5) { // Got some data? Play.\r\n                        try { await this.video.play(); this.started = true; } catch (e) { }\r\n                    }\r\n                }\r\n            } else {\r\n                console.warn(\"[MSE] Empty segment received\");\r\n            }\r\n\r\n            this.nextTs += (this.SEGMENT_SEC * 1000);\r\n\r\n        } catch (e) {\r\n            if (e.name !== 'AbortError') console.error(\"[MSE] Fetch Error:\", e);\r\n        } finally {\r\n            this.abortController = null;\r\n        }\r\n    }\r\n\r\n    async skipGap(failedTs) {\r\n        this.gapRetries++;\r\n        if (this.gapRetries > this.MAX_GAP_RETRIES) {\r\n            console.warn('[MSE] Too many gaps. Stopping.');\r\n            return;\r\n        }\r\n\r\n        console.warn(`[MSE] GAP at ${failedTs}. Skipping +${this.SEGMENT_SEC}s`);\r\n        this.nextTs += (this.SEGMENT_SEC * 1000);\r\n\r\n        // If playing \"on black\", jump playhead too\r\n        // if (this.video.readyState > 0 && !this.video.paused) {\r\n        //     // Optionally jump video time if we are stuck at end\r\n        // }\r\n    }\r\n\r\n    appendBuffer(buffer) {\r\n        return new Promise(resolve => {\r\n            if (!this.sourceBuffer || this.mediaSource.readyState !== 'open') return resolve();\r\n\r\n            const onUpdateEnd = () => {\r\n                this.sourceBuffer.removeEventListener('updateend', onUpdateEnd);\r\n                resolve();\r\n            };\r\n            this.sourceBuffer.addEventListener('updateend', onUpdateEnd);\r\n\r\n            try {\r\n                this.sourceBuffer.appendBuffer(buffer);\r\n            } catch (e) {\r\n                console.error(\"[MSE] Append Error:\", e);\r\n                // If QuotaExceeded, remove played buffer\r\n                if (e.name === 'QuotaExceededError') {\r\n                    this.flushPlayedBuffer();\r\n                }\r\n                this.sourceBuffer.removeEventListener('updateend', onUpdateEnd);\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    // CRITICAL: JUMP OVER GAPS IN BUFFER\r\n    monitorStall() {\r\n        if (!this.video || this.video.paused || this.isSeeking) return;\r\n\r\n        const ct = this.video.currentTime;\r\n        const buffered = this.video.buffered;\r\n\r\n        if (buffered.length === 0) return;\r\n\r\n        // Find which range we are in (or just past)\r\n        for (let i = 0; i < buffered.length; i++) {\r\n            const start = buffered.start(i);\r\n            const end = buffered.end(i);\r\n\r\n            // If we are very close to the end of a range (< 0.5s)\r\n            if (Math.abs(end - ct) < 0.5) {\r\n                // Is there a next range?\r\n                if (i + 1 < buffered.length) {\r\n                    const nextStart = buffered.start(i + 1);\r\n                    // If the gap is small enough (< 3s), JUMP IT\r\n                    if (nextStart - end < 3.0) {\r\n                        console.warn(`[MSE] Jumping MICRO-GAP: ${end.toFixed(2)} -> ${nextStart.toFixed(2)}`);\r\n                        this.video.currentTime = nextStart + 0.1;\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // LOGGING\r\n        const bufEnd = this.getBufferedEnd();\r\n        console.log(`[MSE] T:${ct.toFixed(1)} Buf:${bufEnd.toFixed(1)} Ahead:${(bufEnd - ct).toFixed(1)}`);\r\n    }\r\n\r\n    flushPlayedBuffer() {\r\n        if (!this.sourceBuffer || this.sourceBuffer.updating) return;\r\n        const ct = this.video.currentTime;\r\n        if (ct > 30) {\r\n            try { this.sourceBuffer.remove(0, ct - 10); } catch (e) { }\r\n        }\r\n    }\r\n\r\n    getBufferedEnd() {\r\n        if (!this.video || !this.video.buffered || this.video.buffered.length === 0) return 0;\r\n        return this.video.buffered.end(this.video.buffered.length - 1);\r\n    }\r\n\r\n    async seekTo(epochMs) {\r\n        if (!this.mediaSource || !this.sourceBuffer) return;\r\n\r\n        console.log('[MSE] SEEK', new Date(epochMs).toLocaleTimeString());\r\n        this.isSeeking = true;\r\n        this.gapRetries = 0;\r\n        this.video.pause();\r\n\r\n        // Cancel Fetch\r\n        if (this.abortController) this.abortController.abort();\r\n        this.isFetching = false;\r\n\r\n        // Wait for update\r\n        if (this.sourceBuffer.updating) {\r\n            await new Promise(r => this.sourceBuffer.addEventListener('updateend', r, { once: true }));\r\n        }\r\n\r\n        // Flush Buffer\r\n        try {\r\n            const ranges = this.video.buffered;\r\n            if (ranges.length > 0) {\r\n                this.sourceBuffer.remove(ranges.start(0), ranges.end(ranges.length - 1));\r\n                await new Promise(r => this.sourceBuffer.addEventListener('updateend', r, { once: true }));\r\n            }\r\n        } catch (e) { }\r\n\r\n        this.video.currentTime = 0; // Reset safe\r\n        this.nextTs = epochMs;\r\n        this.started = false;\r\n        this.isSeeking = false;\r\n\r\n        // Ensure loop will kick in and fetch nextTs\r\n    }\r\n\r\n    getCurrentEpochMs() {\r\n        if (!this.started || !this.nextTs) return this.nextTs || 0;\r\n        const bufferedDuration = this.getBufferedEnd();\r\n        const playheadPos = this.video.currentTime;\r\n        return this.nextTs - (Math.max(0, bufferedDuration - playheadPos) * 1000);\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}